This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-18T17:39:49.598Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
agents/
  trader/
    examples/
      autonomouse_trader.rs
      simple_trader.rs
      test_full_system.rs
      test_vector_store.rs
    src/
      agents/
        data_ingestion.rs
        execution.rs
        mod.rs
        prediction.rs
        twitter.rs
      bin/
        sync.rs
      data_ingestion/
        mod.rs
      database/
        mod.rs
        positions.rs
        sync.rs
      decision/
        mod.rs
      dex/
        jupiter.rs
        mod.rs
      execution/
        mod.rs
      integrations/
        twitter.rs
      market_data/
        birdeye.rs
        loaders.rs
        mod.rs
        provider.rs
        pumpfun.rs
        storage.rs
        streaming.rs
        vector_store.rs
      personality/
        mod.rs
      prediction/
        mod.rs
      storage/
        schema.rs
      strategy/
        execution.rs
        llm.rs
        mod.rs
        pipeline.rs
        risk.rs
        technical.rs
      twitter/
        mod.rs
      analysis.rs
      lib.rs
      main.rs
      market_data.rs
      state.rs
      twitter.rs
      wallet.rs
    Cargo.toml
    docker-compose.yml
docs/
  examples/
    advanced_pid_controller_tuner_example/
      src/
        main.rs
      Cargo.toml
      README.md
    agent_state_machine/
      examples/
        interactive_storytelling/
          character_agent.rs
          dialogue_agent.rs
          environment_agent.rs
          main.rs
          narrative_agent.rs
          README.md
        arxiv_test.rs
        research_assistant.rs
        serpapi_test.rs
        simple_chat.rs
      src/
        lib.rs
        machine.rs
        state.rs
      .gitignore
      Cargo.toml
      README.md
    agents/
      close_empty_token_accounts.rs
      create_gibwork_task.rs
      create_solana_tools.rs
      defi_trading.rs
      deploy_collection.rs
      deploy_token.rs
      dynamic_tools.rs
      get_balance.rs
      jupiter_fetch_price.rs
      jupiter_stake_sol.rs
      jupiter_swap.rs
      main.rs
      market_analysis.rs
      market_opportunity.rs
      mint_nft_to_collection.rs
      nft_analysis.rs
      pumpfun_launch_token.rs
      pyth_fetch_price.rs
      rugcheck.rs
      running_locally.rs
      token_security.rs
    close_empty_token_accounts/
      src/
        main.rs
      Cargo.toml
    degenspartan/
      instructions/
        base.txt
        suffix.txt
      adjectives.txt
      bio.txt
      lore.txt
      post_examples.txt
      previous_messages.txt
      styles.txt
      topics.txt
    deploy_collection/
      src/
        main.rs
      Cargo.toml
    deploy_token/
      src/
        main.rs
      Cargo.toml
    discord_rig_bot/
      documents/
        backup.rs
        Rig_code_samples.md
        Rig_examples.md
        Rig_faq.md
        Rig_guide.md
      src/
        docs.md
        main.rs
        rig_agent.rs
      Cargo.toml
    entity_extraction_example/
      src/
        main.rs
      Cargo.toml
      README.md
    flight_search_assistant/
      src/
        flight_search_tool.rs
        main.rs
      Cargo.toml
      README.md
    get_balance/
      src/
        main.rs
      Cargo.toml
    gibwork/
      src/
        main.rs
      Cargo.toml
    jupiter/
      src/
        main.rs
      Cargo.toml
    mint_nft/
      src/
        main.rs
      Cargo.toml
    ollama/
      src/
        main.rs
      Cargo.toml
    pid_controller_tuner_example/
      src/
        main.rs
      Cargo.toml
      README.md
    plugin/
      src/
        main.rs
      .gitignore
      Cargo.toml
    pumpfun/
      src/
        main.rs
      Cargo.toml
    rag_system/
      src/
        main.rs
      Cargo.toml
      README.md
    rig/
      common/
        mongodb.rs
      agent_autonomous.rs
      agent_evaluator_optimizer.rs
      agent_orchestrator.rs
      agent_parallelization.rs
      agent_prompt_chaining.rs
      agent_routing.rs
      agent_with_context.rs
      agent_with_deepseek.rs
      agent_with_galadriel.rs
      agent_with_grok.rs
      agent_with_hyperbolic.rs
      agent_with_loaders.rs
      agent_with_moonshot.rs
      agent_with_ollama.rs
      agent_with_tools.rs
      agent.rs
      anthropic_agent.rs
      anthropic_streaming_with_tools.rs
      anthropic_streaming.rs
      calculator_chatbot.rs
      chain.rs
      cohere_connector.rs
      debate.rs
      extractor_with_deepseek.rs
      extractor.rs
      gemini_agent.rs
      gemini_embeddings.rs
      image.rs
      loaders.rs
      multi_agent.rs
      multi_extract.rs
      multi_turn_agent.rs
      perplexity_agent.rs
      rag_dynamic_tools.rs
      rag.rs
      sentiment_classifier.rs
      simple_model.rs
      vector_search_cohere.rs
      vector_search_mongodb.rs
      vector_search.rs
      xai_embeddings.rs
    rig_concurrent_demo/
      src/
        Concurrent_Processing_with_Rig.rs
        main.rs
      Cargo.toml
      README.md
    rss_summarizer/
      src/
        main.rs
      Cargo.toml
      README.md
    rugcheck/
      src/
        main.rs
      Cargo.toml
    rustbuddy/
      src/
        main.rs
      Cargo.toml
    simple_agent/
      src/
        main.rs
      Cargo.toml
    synthetic_data_example/
      src/
        main.rs
      Cargo.toml
      README.md
    text_classification_example/
      src/
        main.rs
      Cargo.toml
      README.md
    tic-tac-toe_example/
      src/
        main.rs
      Cargo.toml
      README.md
    token_security/
      src/
        main.rs
      Cargo.toml
memory-bank/
  activeContext.md
  codeReview.md
  developmentWorkflow.md
  operationalContext.md
  productContext.md
  projectBoundaries.md
  projectbrief.md
  techContext.md
migrations/
  01_initial_schema.sql
  01_mongodb_setup.rs
  02_mongodb_schema.rs
  02_trade_status.sql
  03_mongodb_trade_status.rs
  03_position_allocations.sql
  04_mongodb_allocations.rs
  04_vector_store.sql
  05_init_vector_store.sql
  05_mongodb_vector_store.rs
scripts/
  capture_market_data.rs
  init_mongodb.rs
  init_vector_store.rs
  run_agent.rs
  run_migrations.rs
  setup_mongodb.rs
  test_vector_search.rs
src/
  actions/
    helius/
      create_webhook.rs
      delete_webhook.rs
      get_assets_by_owner.rs
      get_webhook.rs
      mod.rs
      transaction_parsing.rs
    solana/
      close_empty_token_accounts.rs
      get_balance.rs
      get_tps.rs
      mod.rs
      request_faucet_funds.rs
      transfer.rs
  agent/
    analyst.rs
    mod.rs
    portfolio_optimizer.rs
    risk_manager.rs
    trader.rs
  birdeye/
    api.rs
    mod.rs
  character/
    mod.rs
  characteristics/
    adjectives.rs
    bio.rs
    lore.rs
    mod.rs
    post_examples.rs
    previous_messages.rs
    styles.rs
    topics.rs
  clients/
    twitter.rs
  config/
    agent_config.rs
    market_config.rs
    mod.rs
    mongodb.rs
  core/
    agent.rs
    characteristics.rs
    instruction_builder.rs
    mod.rs
    runtime.rs
  database/
    mod.rs
    sync.rs
  evaluators/
  logging/
    mod.rs
  market_data/
    birdeye.rs
  models/
    market_config.rs
    market_signal.rs
    mod.rs
    token_analytics.rs
    token_info.rs
  personality/
    mod.rs
  prompts/
    system.txt
  providers/
    birdeye.rs
    discord.rs
    mod.rs
    twitter.rs
  services/
    mod.rs
    token_analytics.rs
    token_data_service.rs
    token_data.rs
  strategy/
    llm.rs
    mod.rs
  trading/
    mod.rs
    trading_engine.rs
  twitter/
    mod.rs
  utils/
    mod.rs
  vector_store/
    mod.rs
  error.rs
  lib.rs
  main.rs
  memory.rs
tests/
  integration/
    mod.rs
    test_utils.rs
    token_analytics_tests.rs
    trade_flow_test.rs
    twitter_tests.rs
.gitignore
.pre-commit-config.yaml
Cargo.toml
CONTRIBUTING.md
playground-1.mongodb.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="agents/trader/examples/autonomouse_trader.rs">
use anyhow::Result;
use dotenv::dotenv;
use rig_solana_trader::{
    market_data::MarketDataProvider,
    strategy::{
        TradingStrategy, StrategyConfig, analytics::PerformanceAnalyzer,
        pipeline::TradingPipeline, risk::RiskManager, execution::ExecutionEngine,
    },
};
use solana_sdk::signature::{Keypair, read_keypair_file};
use std::{env, sync::Arc};
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;
use tokio::time::{sleep, Duration};
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .with_target(false)
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_level(true)
        .pretty()
        .init();
    // Load environment variables
    dotenv().ok();
    info!("Starting autonomous trading agent...");
    // Initialize OpenAI client and agent
    let openai_client = openai::Client::from_env();
    let agent = openai_client.agent("gpt-4").build();
    // Load wallet
    let wallet = if let Ok(private_key) = env::var("SOLANA_PRIVATE_KEY") {
        let bytes = bs58::decode(&private_key)
            .into_vec()
            .expect("Invalid private key");
        Keypair::from_bytes(&bytes).expect("Invalid keypair")
    } else {
        read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
            .expect("Failed to read keypair file")
    };
    info!("Wallet loaded: {}", wallet.pubkey());
    // Initialize market data provider
    let market_data = Arc::new(MarketDataProvider::new(
        &env::var("BIRDEYE_API_KEY")?,
        &env::var("SOLANA_RPC_URL")?,
    ).await?);
    // Initialize strategy components
    let strategy_config = StrategyConfig {
        max_position_sol: env::var("MAX_POSITION_SIZE_SOL")?.parse()?,
        min_position_sol: env::var("MIN_POSITION_SIZE_SOL")?.parse()?,
        max_tokens: env::var("MAX_TOKENS_PER_WALLET")?.parse()?,
        min_confidence: env::var("MIN_CONFIDENCE_THRESHOLD")?.parse()?,
        min_liquidity_usd: env::var("MIN_LIQUIDITY_USD")?.parse()?,
        max_slippage: env::var("MAX_SLIPPAGE")?.parse()?,
    };
    let strategy = Arc::new(TradingStrategy::new(agent, strategy_config));
    // Initialize risk manager with initial portfolio value
    let risk_manager = Arc::new(RiskManager::new(
        env::var("INITIAL_PORTFOLIO_VALUE")?.parse()?,
        env::var("MAX_DRAWDOWN")?.parse()?,
    ));
    // Initialize execution engine without Jupiter API key
    let execution_engine = Arc::new(ExecutionEngine::new(
        &env::var("SOLANA_RPC_URL")?,
        strategy_config.max_slippage,
        wallet.pubkey(),
    )?);
    // Initialize trading pipeline
    let pipeline = TradingPipeline::new(
        market_data.clone(),
        strategy.clone(),
        risk_manager.clone(),
        execution_engine.clone(),
    );
    // Initialize performance analyzer
    let mut performance_analyzer = PerformanceAnalyzer::new(
        env::var("INITIAL_PORTFOLIO_VALUE")?.parse()?,
    );
    info!("All components initialized, starting trading loop...");
    // Main trading loop
    loop {
        // 1. Get trending tokens
        let trending_tokens = market_data.get_trending_tokens(10).await?;
        info!("Found {} trending tokens to analyze", trending_tokens.len());
        // 2. Process each token
        for token in trending_tokens {
            if let Some(result) = pipeline.process_token(&token.address).await? {
                // Record trade result
                performance_analyzer.record_trade(result.into());
                // Log performance metrics
                let metrics = performance_analyzer.get_metrics();
                info!(
                    "Trading Performance: Win Rate: {:.2}%, Total P/L: {:.2} SOL, Sharpe: {:.2}",
                    metrics.win_rate * 100.0,
                    metrics.total_profit_loss,
                    metrics.sharpe_ratio
                );
                // Analyze strategy performance
                let analysis = performance_analyzer.analyze_strategy_performance("default")?;
                if !analysis.recommended_adjustments.is_empty() {
                    info!("Strategy Recommendations:");
                    for recommendation in analysis.recommended_adjustments {
                        info!("- {}", recommendation);
                    }
                }
            }
        }
        // 3. Monitor existing positions
        pipeline.monitor_positions().await?;
        // 4. Wait before next iteration
        sleep(Duration::from_secs(60)).await;
    }
}
</file>

<file path="agents/trader/examples/simple_trader.rs">
use anyhow::Result;
use dotenv::dotenv;
use rig::providers::openai;
use rig_solana_trader::SolanaTrader;
use solana_sdk::signature::{read_keypair_file, Keypair};
use std::env;
use std::sync::Arc;
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;
#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables
    dotenv().ok();
    // Initialize logging with timestamps
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .with_target(false)
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_level(true)
        .with_target(true)
        .with_ansi(true)
        .with_timestamp(true)
        .pretty()
        .init();
    info!("Starting Solana trading bot...");
    // Create OpenAI client and agent
    let openai_client = openai::Client::from_env();
    let agent = openai_client.agent("gpt-4o").build();
    // Load wallet from private key
    let wallet = if let Ok(private_key) = env::var("SOLANA_PRIVATE_KEY") {
        let bytes = bs58::decode(&private_key)
            .into_vec()
            .expect("Invalid private key");
        Keypair::from_bytes(&bytes).expect("Invalid keypair")
    } else {
        // Fallback to local keypair file
        read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
            .expect("Failed to read keypair file")
    };
    info!("Wallet loaded: {}", wallet.pubkey());
    // Create trader instance
    let mut trader = SolanaTrader::new(
        agent,
        env::var("BIRDEYE_API_KEY")?,
        env::var("JUPITER_API_KEY")?,
        env::var("SOLANA_RPC_URL")?,
        wallet,
        env::var("MAX_POSITION_SIZE_SOL")?.parse()?,
        env::var("MIN_POSITION_SIZE_SOL")?.parse()?,
        "So11111111111111111111111111111111111111112".to_string(), // SOL mint
        env::var("JUPITER_SLIPPAGE")?.parse::<f64>()? as u64 * 100, // Convert percentage to bps
        env::var("TWITTER_USERNAME")?,
        env::var("TWITTER_COOKIES")?,
    );
    // Add allowed Twitter interactions
    info!("Configuring allowed Twitter interactions...");
    trader.add_allowed_twitter_interaction("vitalik".to_string());
    trader.add_allowed_twitter_interaction("solana".to_string());
    trader.add_allowed_twitter_interaction("aeyakovenko".to_string());
    trader.add_allowed_twitter_interaction("cryptogodfatha".to_string());
    trader.add_allowed_twitter_interaction("0xMert_".to_string());
    trader.add_allowed_twitter_interaction("DefiLlama".to_string());
    // Start trading loop
    info!("Starting trading loop...");
    info!("Press Ctrl+C to stop the bot");
    // Handle Ctrl+C gracefully
    let trader = Arc::new(trader);
    let trader_clone = Arc::clone(&trader);
    tokio::select! {
        _ = tokio::signal::ctrl_c() => {
            info!("Received Ctrl+C, shutting down...");
        }
        result = trader_clone.start_trading_loop() => {
            if let Err(e) = result {
                tracing::error!("Trading loop error: {}", e);
            }
        }
    }
    info!("Bot stopped successfully");
    Ok(())
}
</file>

<file path="agents/trader/examples/test_full_system.rs">
use anyhow::Result;
use chrono::Utc;
use rig_solana_trader::{
    database::DatabaseClient,
    market_data::{MarketDataProvider, loaders::MarketDataLoader},
    strategy::{TradingStrategy, pipeline::TradingPipeline},
    execution::ExecutionEngine,
    agents::TradingAgentSystem,
    market_data::vector_store::{TokenAnalysis, TokenVectorStore},
    strategy::{StrategyConfig, StrategyParameters, RiskLevel},
};
use rig::providers::openai::Client as OpenAIClient;
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;
use std::path::PathBuf;
use sqlx::postgres::PgPoolOptions;
use uuid::Uuid;
use std::time::Duration;
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::DEBUG)
        .pretty()
        .init();
    // Load environment variables
    dotenv::dotenv().ok();
    // Initialize OpenAI client
    let openai_api_key = std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
    let openai_client = OpenAIClient::new(&openai_api_key);
    let model = openai_client.completion_model("gpt-4o");
    // Initialize PostgreSQL connection
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .idle_timeout(Duration::from_secs(3))
        .connect(&database_url)
        .await?;
    // Initialize database client
    let db_client = DatabaseClient::new(&database_url).await?;
    // Initialize vector store
    let vector_store = TokenVectorStore::new(pool.clone());
    // Initialize market data components
    let market_data = MarketDataProvider::new(&openai_api_key, db_client.clone()).await?;
    let data_loader = MarketDataLoader::new();
    // Create test strategy config
    let strategy_config = StrategyConfig {
        id: Uuid::new_v4(),
        name: "Test Strategy".to_string(),
        description: "A test trading strategy".to_string(),
        risk_level: RiskLevel::Medium,
        parameters: StrategyParameters {
            min_market_cap: 1_000_000.0,
            min_volume_24h: 100_000.0,
            min_price_change: -5.0,
            max_price_change: 5.0,
            max_slippage: 1.0,
        },
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };
    // Initialize trading components
    let strategy = TradingStrategy::new(model.clone(), strategy_config.clone());
    let execution = ExecutionEngine::new(strategy_config.parameters.max_slippage);
    // Initialize trading pipeline
    let pipeline = TradingPipeline::new(market_data.clone(), strategy, execution);
    // Initialize multi-agent system
    let agents = TradingAgentSystem::new(model);
    // Test tokens
    let test_tokens = vec![
        "So11111111111111111111111111111111111111112", // Wrapped SOL
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
        "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // BONK
    ];
    for token in test_tokens {
        info!("Processing token {}", token);
        // 1. Load and analyze market data
        let market_report = data_loader.load_market_report("data/market_reports/latest.txt").await?;
        let whitepaper = data_loader.load_token_whitepaper("data/whitepapers/token.pdf").await?;
        // 2. Get multi-agent analysis
        let token_data = format!(
            "Token: {}\nMarket Report:\n{}\nWhitepaper:\n{}",
            token, market_report, whitepaper
        );
        let decision = agents.make_trading_decision(&token_data).await?;
        info!("Agent decision: {}", decision);
        // 3. Execute through pipeline
        let tx_signature = pipeline.execute_trade(token.to_string()).await?;
        info!("Transaction executed: {}", tx_signature);
        // 4. Store analysis in vector store
        let analysis = TokenAnalysis {
            id: Uuid::new_v4(),
            token_address: token.to_string(),
            sentiment_score: decision.sentiment_score,
            technical_score: decision.technical_score,
            risk_score: decision.risk_score,
            symbol: token.to_string(),
            description: format!("Analysis for {}", token),
            recent_events: vec![decision.reasoning.clone()],
            market_sentiment: decision.market_sentiment.clone(),
            timestamp: Utc::now(),
        };
        // Generate embeddings and store
        let embeddings = rig_core::embeddings::EmbeddingsBuilder::new(model.clone())
            .documents(vec![analysis.clone()])?
            .build()
            .await?;
        vector_store.add_analysis(analysis, embeddings).await?;
    }
    // Save strategy config
    let strategy_id = db_client.insert_document("strategies", &strategy_config).await?;
    info!("Created strategy with ID: {}", strategy_id);
    Ok(())
}
</file>

<file path="agents/trader/examples/test_vector_store.rs">
use anyhow::Result;
use chrono::Utc;
use rig_solana_trader::{
    market_data::vector_store::{TokenAnalysis, TokenVectorStore},
    database::DatabaseClient,
};
use sqlx::postgres::PgPoolOptions;
use uuid::Uuid;
#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables
    dotenv::dotenv().ok();
    // Initialize PostgreSQL connection
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .idle_timeout(std::time::Duration::from_secs(3))
        .connect(&database_url)
        .await?;
    // Initialize vector store
    let vector_store = TokenVectorStore::new(pool);
    // Create test analysis
    let analysis = TokenAnalysis {
        id: Uuid::new_v4(),
        token_address: "So11111111111111111111111111111111111111112".to_string(),
        symbol: "SOL".to_string(),
        description: "Solana's native token".to_string(),
        recent_events: vec![
            "Network upgrade successful".to_string(),
            "New DeFi protocol launched".to_string(),
        ],
        market_sentiment: "Bullish".to_string(),
        timestamp: Utc::now(),
    };
    // Generate embeddings
    let openai_client = rig_core::providers::openai::Client::from_env();
    let model = openai_client.embedding_model(rig_core::providers::openai::TEXT_EMBEDDING_3_SMALL);
    let embeddings = rig_core::embeddings::EmbeddingsBuilder::new(model)
        .documents(vec![analysis.clone()])?
        .build()
        .await?;
    // Add analysis to vector store
    vector_store.add_analysis(analysis, embeddings).await?;
    // Search for similar tokens
    let similar_tokens = vector_store
        .search_similar("high performance blockchain token", 5)
        .await?;
    println!("Found {} similar tokens:", similar_tokens.len());
    for token in similar_tokens {
        println!("- {} ({})", token.symbol, token.market_sentiment);
    }
    Ok(())
}
</file>

<file path="agents/trader/src/agents/data_ingestion.rs">
use rig_core::{
    agent::Agent,
    message_bus::{Message, MessageBus},
    storage::VectorStorage,
};
use rig_solana_trader::{personality::StoicPersonality, storage::MarketData};
use std::sync::Arc;
pub struct DataIngestionAgent {
    bus: MessageBus,
    storage: Arc<dyn VectorStorage>,
    personality: Arc<StoicPersonality>,
}
impl DataIngestionAgent {
    pub fn new(
        bus: MessageBus,
        storage: Arc<dyn VectorStorage>,
        personality: Arc<StoicPersonality>,
    ) -> Self {
        Self { bus, storage, personality }
    }
}
#[async_trait]
impl Agent for DataIngestionAgent {
    async fn run(&self) -> anyhow::Result<()> {
        let mut receiver = self.bus.subscribe("market_data");
        while let Ok(msg) = receiver.recv().await {
            if let Message::MarketData(data) = msg {
                // Store raw data
                self.storage
                    .insert("market_data", data.to_embedding())
                    .await?;
                // Process with personality constraints
                let processed = self.personality.process_market_data(data).await?;
                // Store processed data
                self.storage
                    .insert("processed_market", processed.to_embedding())
                    .await?;
                // Publish to message bus
                self.bus.publish(Message::ProcessedMarketData(processed)).await;
            }
        }
        Ok(())
    }
}
</file>

<file path="agents/trader/src/agents/execution.rs">
use rig_core::{
    agent::Agent,
    message_bus::{Message, MessageBus},
    storage::VectorStorage,
};
use rig_solana_trader::{personality::StoicPersonality, trading::TradeExecution};
use solana_sdk::signature::Signature;
use std::sync::Arc;
pub struct ExecutionAgent {
    bus: MessageBus,
    storage: Arc<dyn VectorStorage>,
    personality: Arc<StoicPersonality>,
}
impl ExecutionAgent {
    pub fn new(
        bus: MessageBus,
        storage: Arc<dyn VectorStorage>,
        personality: Arc<StoicPersonality>,
    ) -> Self {
        Self { bus, storage, personality }
    }
}
#[async_trait]
impl Agent for ExecutionAgent {
    async fn run(&self) -> anyhow::Result<()> {
        let mut receiver = self.bus.subscribe("trade_decisions");
        while let Ok(msg) = receiver.recv().await {
            if let Message::TradeDecision(decision) = msg {
                // Execute trade on Solana
                let sig: Signature = self.personality.execute_trade(&decision).await?;
                // Store execution record
                let execution = TradeExecution {
                    tx_hash: sig.to_string(),
                    mint_address: decision.mint,
                    amount: decision.amount,
                    risk_assessment: decision.risk_score,
                    vector_embedding: decision.to_embedding(),
                    timestamp: Utc::now(),
                };
                self.storage
                    .insert("trade_history", execution)
                    .await?;
                self.bus.publish(Message::TradeExecuted(execution)).await;
            }
        }
        Ok(())
    }
}
</file>

<file path="agents/trader/src/agents/mod.rs">
use rig::{
    agent::{Agent, AgentBuilder},
    chat::{Chat, CompletionModel, Message, PromptError},
    providers::openai::Client as OpenAIClient,
    Result,
};
use serde::{Deserialize, Serialize};
use tracing::debug;
use cainam_trader::market_data::{MarketData, TokenMetadata};
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketAnalysis {
    pub token: TokenMetadata,
    pub sentiment_score: f64,
    pub risk_score: f64,
    pub recommendation: String,
    pub reasoning: String,
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RiskAssessment {
    pub token: TokenMetadata,
    pub liquidity_risk: f64,
    pub volatility_risk: f64,
    pub market_risk: f64,
    pub overall_risk: f64,
    pub risk_factors: Vec<String>,
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecutionPlan {
    pub token: TokenMetadata,
    pub action: String,
    pub size: f64,
    pub target_price: f64,
    pub stop_loss: f64,
    pub take_profit: f64,
    pub reasoning: String,
}
pub struct TradingAgentSystem {
    market_analyst: Agent,
    risk_manager: Agent,
    execution_specialist: Agent,
}
impl TradingAgentSystem {
    pub async fn new(openai_client: OpenAIClient) -> Result<Self> {
        // Initialize market analyst agent
        let market_analyst = AgentBuilder::new(openai_client)
            .name("Market Analyst")
            .description("Analyzes market data and provides trading recommendations")
            .model(CompletionModel::GPT4)
            .client(openai_client.clone())
            .build()?;
        // Initialize risk manager agent
        let risk_manager = AgentBuilder::new(openai_client)
            .name("Risk Manager")
            .description("Assesses trading risks and provides risk management recommendations")
            .model(CompletionModel::GPT4)
            .client(openai_client.clone())
            .build()?;
        // Initialize execution specialist agent
        let execution_specialist = AgentBuilder::new(openai_client)
            .name("Execution Specialist")
            .description("Plans and optimizes trade execution")
            .model(CompletionModel::GPT4)
            .client(openai_client)
            .build()?;
        Ok(Self {
            market_analyst,
            risk_manager,
            execution_specialist,
        })
    }
    pub async fn analyze_market(&self, market_data: &MarketData) -> Result<MarketAnalysis> {
        debug!("Analyzing market data for {}", market_data.token.symbol);
        let prompt = format!(
            "Analyze the following market data and provide a trading recommendation:\n\
            Token: {} ({})\n\
            Price: ${}\n\
            24h Volume: ${}\n\
            Market Cap: ${}\n\
            Social Sentiment: {}\n\
            Technical Indicators:\n\
            - RSI (14): {}\n\
            - MACD: {}\n\
            - MA50: {}\n\
            - MA200: {}\n\
            \n\
            Provide your analysis in JSON format with the following fields:\n\
            - sentiment_score: A score between 0 and 1\n\
            - risk_score: A score between 0 and 1\n\
            - recommendation: A brief trading recommendation\n\
            - reasoning: Your detailed reasoning",
            market_data.token.symbol,
            market_data.token.address,
            market_data.token.price_usd.unwrap_or_default(),
            market_data.token.volume_24h.unwrap_or_default(),
            market_data.token.market_cap.unwrap_or_default(),
            market_data.social_sentiment.unwrap_or_default(),
            market_data.technical_indicators.rsi_14.unwrap_or_default(),
            market_data.technical_indicators.macd.unwrap_or_default(),
            market_data.technical_indicators.ma_50.unwrap_or_default(),
            market_data.technical_indicators.ma_200.unwrap_or_default(),
        );
        let response = self.market_analyst
            .chat(&[Message::user(&prompt)])
            .await?;
        let analysis: MarketAnalysis = serde_json::from_str(&response.content)?;
        Ok(analysis)
    }
    pub async fn assess_risk(&self, market_data: &MarketData, analysis: &MarketAnalysis) -> Result<RiskAssessment> {
        debug!("Assessing risk for {}", market_data.token.symbol);
        let prompt = format!(
            "Assess the trading risks for the following token based on market data and analysis:\n\
            Token: {} ({})\n\
            Market Analysis:\n\
            - Sentiment Score: {}\n\
            - Risk Score: {}\n\
            - Recommendation: {}\n\
            \n\
            Market Data:\n\
            - Price: ${}\n\
            - 24h Volume: ${}\n\
            - Market Cap: ${}\n\
            \n\
            Provide your assessment in JSON format with the following fields:\n\
            - liquidity_risk: A score between 0 and 1\n\
            - volatility_risk: A score between 0 and 1\n\
            - market_risk: A score between 0 and 1\n\
            - overall_risk: A weighted average of the above risks\n\
            - risk_factors: An array of specific risk factors identified",
            market_data.token.symbol,
            market_data.token.address,
            analysis.sentiment_score,
            analysis.risk_score,
            analysis.recommendation,
            market_data.token.price_usd.unwrap_or_default(),
            market_data.token.volume_24h.unwrap_or_default(),
            market_data.token.market_cap.unwrap_or_default(),
        );
        let response = self.risk_manager
            .chat(&[Message::user(&prompt)])
            .await?;
        let assessment: RiskAssessment = serde_json::from_str(&response.content)?;
        Ok(assessment)
    }
    pub async fn plan_execution(
        &self,
        market_data: &MarketData,
        analysis: &MarketAnalysis,
        risk: &RiskAssessment,
    ) -> Result<ExecutionPlan> {
        debug!("Planning execution for {}", market_data.token.symbol);
        let prompt = format!(
            "Plan the execution of a trade based on the following analysis and risk assessment:\n\
            Token: {} ({})\n\
            Current Price: ${}\n\
            \n\
            Market Analysis:\n\
            - Sentiment Score: {}\n\
            - Risk Score: {}\n\
            - Recommendation: {}\n\
            \n\
            Risk Assessment:\n\
            - Overall Risk: {}\n\
            - Risk Factors: {}\n\
            \n\
            Provide your execution plan in JSON format with the following fields:\n\
            - action: 'BUY' or 'SELL'\n\
            - size: Position size in SOL\n\
            - target_price: Entry price target\n\
            - stop_loss: Stop loss price\n\
            - take_profit: Take profit price\n\
            - reasoning: Detailed reasoning for the execution plan",
            market_data.token.symbol,
            market_data.token.address,
            market_data.token.price_usd.unwrap_or_default(),
            analysis.sentiment_score,
            analysis.risk_score,
            analysis.recommendation,
            risk.overall_risk,
            risk.risk_factors.join(", "),
        );
        let response = self.execution_specialist
            .chat(&[Message::user(&prompt)])
            .await?;
        let plan: ExecutionPlan = serde_json::from_str(&response.content)?;
        Ok(plan)
    }
}
</file>

<file path="agents/trader/src/agents/prediction.rs">
use rig_core::{
    agent::Agent,
    message_bus::{Message, MessageBus},
    storage::VectorStorage,
};
use rig_solana_trader::{personality::StoicPersonality, storage::MarketData};
use std::sync::Arc;
pub struct PredictionAgent {
    bus: MessageBus,
    storage: Arc<dyn VectorStorage>,
    personality: Arc<StoicPersonality>,
}
impl PredictionAgent {
    pub fn new(
        bus: MessageBus,
        storage: Arc<dyn VectorStorage>,
        personality: Arc<StoicPersonality>,
    ) -> Self {
        Self { bus, storage, personality }
    }
}
#[async_trait]
impl Agent for PredictionAgent {
    async fn run(&self) -> anyhow::Result<()> {
        let mut receiver = self.bus.subscribe("processed_market");
        while let Ok(msg) = receiver.recv().await {
            if let Message::ProcessedMarketData(data) = msg {
                // Find similar historical patterns
                let similar = self.storage
                    .nearest("market_data", data.to_embedding(), 5)
                    .await?;
                // Generate prediction with risk constraints
                let prediction = self.personality
                    .generate_prediction(data, similar)
                    .await?;
                self.bus.publish(Message::Prediction(prediction)).await;
            }
        }
        Ok(())
    }
}
</file>

<file path="agents/trader/src/agents/twitter.rs">
use rig_core::{
    agent::Agent,
    message_bus::{Message, MessageBus},
};
use rig_solana_trader::{personality::StoicPersonality, twitter::TwitterClient};
use std::sync::Arc;
pub struct TwitterAgent {
    bus: MessageBus,
    client: TwitterClient,
    personality: Arc<StoicPersonality>,
}
impl TwitterAgent {
    pub fn new(bus: MessageBus, personality: Arc<StoicPersonality>) -> Self {
        Self {
            bus,
            client: TwitterClient::new(),
            personality,
        }
    }
}
#[async_trait]
impl Agent for TwitterAgent {
    async fn run(&self) -> anyhow::Result<()> {
        let mut receiver = self.bus.subscribe("trade_executed");
        while let Ok(msg) = receiver.recv().await {
            if let Message::TradeExecuted(execution) = msg {
                let tweet = self.personality
                    .generate_trade_tweet(&execution)
                    .await?;
                self.client.post_tweet(&tweet).await?;
            }
        }
        Ok(())
    }
}
</file>

<file path="agents/trader/src/bin/sync.rs">
//! Market Data Synchronization Service
//!
//! This binary runs a service that continuously synchronizes market data from various sources
//! (primarily BirdEye) into MongoDB for analysis and trading decisions. It handles:
//!
//! - Fetching trending tokens at configurable intervals
//! - Storing token states with price, volume, and market data
//! - Detailed logging of all operations for monitoring
//! - Graceful shutdown on Ctrl+C
//!
//! # Configuration
//! The service is configured through environment variables:
//! - `MONGODB_URI`: MongoDB connection string (default: mongodb://localhost:32770)
//! - `BIRDEYE_API_KEY`: API key for BirdEye data
//! - `DATA_SYNC_INTERVAL_SECONDS`: Interval between syncs (default: 60)
//! - `RUST_LOG`: Logging level configuration
//!
//! # Usage
//! ```bash
//! cargo run --bin sync
//! ```
use crate::config::mongodb::MongoConfig;
use crate::config::pool::MongoPoolConfig;
use anyhow::Result;
use chrono::Utc;
use dotenvy::dotenv;
use rig_mongodb::MongoDbPool;
use rig_solana_trader::{
    database::DatabaseClient,
    market_data::{
        birdeye::BirdEyeProvider, AggregatedDataProvider, DataProvider, MarketTrend, TokenMetadata,
    },
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tracing::{debug, error, info, instrument, warn};
use tracing_subscriber::{fmt, EnvFilter};
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TokenState {
    address: String,
    symbol: String,
    name: String,
    price_usd: f64,
    price_sol: f64,
    volume_24h: f64,
    market_cap: f64,
    price_change_24h: f64,
    volume_change_24h: f64,
    timestamp: chrono::DateTime<Utc>,
}
struct DataSyncService {
    data_provider: Arc<AggregatedDataProvider>,
    db: Arc<DatabaseClient>,
}
impl DataSyncService {
    #[instrument]
    fn new(data_provider: Arc<AggregatedDataProvider>, db: Arc<DatabaseClient>) -> Self {
        info!("Creating new DataSyncService instance");
        let service = Self { data_provider, db };
        service.start_sync_tasks();
        info!("DataSyncService initialized successfully");
        service
    }
    #[instrument(skip(self))]
    fn start_sync_tasks(&self) {
        let data_provider = Arc::clone(&self.data_provider);
        let db = Arc::clone(&self.db);
        info!("Starting market data sync task");
        tokio::spawn(async move {
            loop {
                info!("Beginning new market data sync cycle");
                debug!("Fetching trending tokens from data provider");
                match data_provider.as_ref().get_trending_tokens(100).await {
                    Ok(trends) => {
                        info!(
                            token_count = trends.len(),
                            "Successfully fetched trending tokens"
                        );
                        for trend in trends {
                            debug!(
                                token.address = %trend.token_address,
                                token.symbol = %trend.metadata.symbol,
                                token.name = %trend.metadata.name,
                                token.price_usd = trend.metadata.price_usd,
                                token.volume_24h = trend.metadata.volume_24h,
                                token.price_change_24h = trend.price_change_24h,
                                "Processing token data"
                            );
                            let token_state = TokenState {
                                address: trend.token_address.clone(),
                                symbol: trend.metadata.symbol.clone(),
                                name: trend.metadata.name.clone(),
                                price_usd: trend.metadata.price_usd,
                                price_sol: trend.metadata.price_sol,
                                volume_24h: trend.metadata.volume_24h,
                                market_cap: trend.metadata.market_cap,
                                price_change_24h: trend.price_change_24h,
                                volume_change_24h: trend.volume_change_24h,
                                timestamp: Utc::now(),
                            };
                            debug!(
                                token.symbol = %token_state.symbol,
                                token.price_usd = token_state.price_usd,
                                token.volume_24h = token_state.volume_24h,
                                "Inserting token state into MongoDB"
                            );
                            match db.insert_one("token_states", &token_state).await {
                                Ok(_) => info!(
                                    token.symbol = %token_state.symbol,
                                    token.price_usd = token_state.price_usd,
                                    token.volume_24h = token_state.volume_24h,
                                    token.price_change_24h = token_state.price_change_24h,
                                    "Successfully stored token state"
                                ),
                                Err(e) => error!(
                                    token.symbol = %token_state.symbol,
                                    error = %e,
                                    "Failed to insert token state"
                                ),
                            }
                        }
                    }
                    Err(e) => {
                        error!(
                            error = %e,
                            "Failed to fetch trending tokens"
                        );
                    }
                }
                info!("Market data sync cycle complete");
                debug!("Sleeping for 60 seconds before next sync cycle");
                tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
            }
        });
    }
}
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    // Initialize MongoDB with custom sync configuration
    let config = MongoConfig {
        database: "solana_trades".to_string(),
        pool: MongoPoolConfig {
            min_pool_size: 2,
            max_pool_size: 5,
            connect_timeout: std::time::Duration::from_secs(30),
        },
        ..Default::default()
    };
    info!("Connecting to MongoDB at {}", config.uri);
    let pool = config.create_pool().await?;
    info!("Successfully connected to MongoDB");
    // Initialize collections with proper schemas
    let db = pool.database(&config.database);
    // Setup collections for trade sync
    db.create_collection(
        "token_states",
        Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "token_address",
                "granularity": "minutes"
            }
        }),
    )
    .await?;
    db.collection("token_states")
        .create_index(
            doc! {
                "token_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    // Start sync process
    sync_tokens(pool).await?;
    Ok(())
}
async fn sync_tokens(pool: Arc<MongoDbPool>) -> Result<()> {
    // ...existing sync code...
}
</file>

<file path="agents/trader/src/data_ingestion/mod.rs">
use solana_client::rpc_client::RpcClient;
use std::sync::Arc;
use rig_core::message_bus::{MessageBus, Message};
pub struct SolanaIngestor {
    rpc_client: Arc<RpcClient>,
    message_bus: MessageBus,
}
impl SolanaIngestor {
    pub fn new(message_bus: MessageBus) -> Self {
        Self {
            rpc_client: Arc::new(RpcClient::new("https://api.mainnet-beta.solana.com")),
            message_bus
        }
    }
    pub async fn run(self) {
        loop {
            let block = self.rpc_client.get_latest_blockhash().await.unwrap();
            let transactions = self.rpc_client.get_block(&block).await.unwrap();
            self.message_bus.publish(Message::BlockData {
                block_hash: block,
                transactions,
                timestamp: Utc::now()
            }).await;
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    }
}
pub struct SentimentAnalyzer {
    llm: Arc<dyn CompletionModel>,
    message_bus: MessageBus,
}
impl SentimentAnalyzer {
    pub fn new(message_bus: MessageBus) -> Self {
        Self {
            llm: Arc::new(DeepSeek::new()),
            message_bus
        }
    }
    pub async fn analyze(&self, text: &str) -> f32 {
        let prompt = format!("Analyze sentiment of this crypto-related text. Return only a number between -1 (negative) and 1 (positive): {}", text);
        self.llm.complete(&prompt).await
            .parse()
            .unwrap_or(0.0)
    }
}
</file>

<file path="agents/trader/src/database/mod.rs">
//! Database Module
//!
//! This module handles all MongoDB interactions for the trading bot. It manages:
//! - Market data storage and retrieval
//! - Trade history
//! - Position tracking
//! - Risk model persistence
//! - Sentiment analysis data
//!
//! # Environment Variables
//! Required environment variables:
//! - `DATABASE_URL`: MongoDB connection string
//!
//! # Example
//! ```no_run
//! use rig_solana_trader::database::DatabaseClient;
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     let client = DatabaseClient::new("mongodb://user:pass@localhost/db", "trading_db").await?;
//!     Ok(())
//! }
//! ```
use rig_mongodb::{MongoDbPool, bson::doc};
use std::sync::Arc;
use anyhow::Result;
use tracing::{debug, info};
use crate::config::mongodb::MongoConfig;
pub mod positions;
pub mod sync;
/// Database client for interacting with MongoDB
pub struct DatabaseClient {
    pool: Arc<MongoDbPool>,
    database: String,
}
impl DatabaseClient {
    /// Create a new database client
    pub async fn new(uri: &str, database: &str) -> Result<Arc<Self>> {
        debug!("Initializing MongoDB client");
        let config = MongoConfig {
            uri: uri.to_string(),
            database: database.to_string(),
            ..Default::default()
        };
        let pool = config.create_pool().await?;
        // Initialize collections and indexes
        info!("Initializing MongoDB collections and indexes...");
        Self::init_collections(&pool, database).await?;
        info!("MongoDB client initialized successfully");
        Ok(Arc::new(Self {
            pool,
            database: database.to_string(),
        }))
    }
    async fn init_collections(pool: &MongoDbPool, database: &str) -> Result<()> {
        let db = pool.database(database);
        // Create token states collection with timeseries
        db.create_collection("token_states", Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "address",
                "granularity": "minutes"
            }
        })).await?;
        // Create index for efficient queries
        db.collection("token_states").create_index(
            doc! {
                "address": 1,
                "timestamp": -1
            },
            None,
        ).await?;
        Ok(())
    }
    /// Get the database pool
    pub fn pool(&self) -> Arc<MongoDbPool> {
        self.pool.clone()
    }
    /// Get the database name
    pub fn database(&self) -> &str {
        &self.database
    }
}
</file>

<file path="agents/trader/src/database/positions.rs">
use anyhow::Result;
use serde::{Serialize, Deserialize};
use sqlx::{Pool, Postgres};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use crate::strategy::{PortfolioPosition, PartialSell};
#[derive(Debug, Serialize, Deserialize)]
pub struct Position {
    pub id: Uuid,
    pub token_address: String,
    pub entry_price: f64,
    pub quantity: f64,
    pub entry_timestamp: DateTime<Utc>,
    pub last_update: DateTime<Utc>,
    pub partial_sells: Vec<PartialSell>,
    pub status: PositionStatus,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PartialSell {
    pub price: f64,
    pub quantity: f64,
    pub timestamp: DateTime<Utc>,
}
#[derive(Debug, Serialize, Deserialize)]
pub enum PositionStatus {
    Open,
    Closed,
    PartiallyExited,
}
pub struct PositionsCollection {
    pool: Pool<Postgres>,
}
impl PositionsCollection {
    pub fn new(pool: Pool<Postgres>) -> Self {
        Self { pool }
    }
    pub async fn create_position(&self, position: &Position) -> Result<Uuid> {
        let json = serde_json::to_value(position)?;
        sqlx::query!(
            "INSERT INTO positions (id, document) VALUES ($1, $2)",
            position.id,
            json
        )
        .execute(&self.pool)
        .await?;
        Ok(position.id)
    }
    pub async fn get_position(&self, id: Uuid) -> Result<Option<Position>> {
        let row = sqlx::query!(
            "SELECT document FROM positions WHERE id = $1",
            id
        )
        .fetch_optional(&self.pool)
        .await?;
        match row {
            Some(row) => Ok(Some(serde_json::from_value(row.document)?)),
            None => Ok(None),
        }
    }
    pub async fn get_position_by_token(&self, token_address: &str) -> Result<Option<Position>> {
        let row = sqlx::query!(
            "SELECT document FROM positions WHERE document->>'token_address' = $1",
            token_address
        )
        .fetch_optional(&self.pool)
        .await?;
        match row {
            Some(row) => Ok(Some(serde_json::from_value(row.document)?)),
            None => Ok(None),
        }
    }
    pub async fn update_position(&self, position: &Position) -> Result<bool> {
        let json = serde_json::to_value(position)?;
        let result = sqlx::query!(
            "UPDATE positions SET document = $1 WHERE id = $2",
            json,
            position.id
        )
        .execute(&self.pool)
        .await?;
        Ok(result.rows_affected() > 0)
    }
    pub async fn add_partial_sell(
        &self,
        token_address: &str,
        price: f64,
        quantity: f64,
    ) -> Result<bool> {
        let mut position = match self.get_position_by_token(token_address).await? {
            Some(p) => p,
            None => return Ok(false),
        };
        let partial_sell = PartialSell {
            price,
            quantity,
            timestamp: Utc::now(),
        };
        position.partial_sells.push(partial_sell);
        position.status = PositionStatus::PartiallyExited;
        position.last_update = Utc::now();
        self.update_position(&position).await
    }
    pub async fn close_position(&self, token_address: &str) -> Result<bool> {
        let mut position = match self.get_position_by_token(token_address).await? {
            Some(p) => p,
            None => return Ok(false),
        };
        position.status = PositionStatus::Closed;
        position.last_update = Utc::now();
        self.update_position(&position).await
    }
    pub async fn get_open_positions(&self) -> Result<Vec<Position>> {
        let rows = sqlx::query!(
            "SELECT document FROM positions WHERE document->>'status' = 'Open'"
        )
        .fetch_all(&self.pool)
        .await?;
        let positions = rows
            .into_iter()
            .map(|row| serde_json::from_value(row.document))
            .collect::<Result<Vec<Position>, _>>()?;
        Ok(positions)
    }
    pub async fn get_portfolio_stats(&self) -> Result<PortfolioStats> {
        let positions = self.get_open_positions().await?;
        let mut stats = PortfolioStats {
            total_value_sol: 0.0,
            total_value_usd: 0.0,
            total_realized_pnl_sol: 0.0,
            total_unrealized_pnl_sol: 0.0,
            position_count: positions.len(),
            profitable_positions: 0,
        };
        for pos in positions {
            stats.total_value_sol += pos.quantity * pos.entry_price;
            stats.total_value_usd += pos.quantity * pos.entry_price;
            stats.total_realized_pnl_sol += pos.partial_sells.iter()
                .map(|sell| (sell.price - pos.entry_price) * sell.quantity)
                .sum();
            stats.total_unrealized_pnl_sol += (pos.entry_price - pos.entry_price) * pos.quantity;
            if pos.partial_sells.iter()
                .map(|sell| (sell.price - pos.entry_price) * sell.quantity)
                .sum::<f64>() > 0.0 {
                stats.profitable_positions += 1;
            }
        }
        Ok(stats)
    }
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PortfolioStats {
    pub total_value_sol: f64,
    pub total_value_usd: f64,
    pub total_realized_pnl_sol: f64,
    pub total_unrealized_pnl_sol: f64,
    pub position_count: usize,
    pub profitable_positions: usize,
}
</file>

<file path="agents/trader/src/database/sync.rs">
use crate::personality::StoicPersonality;
use crate::market_data::{DataProvider, MarketTrend};
use crate::twitter::TwitterClient;
use crate::strategy::{TradeAction, TradeRecommendation, TradingStrategy};
use crate::dex::jupiter::JupiterDex;
use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use tracing::{debug, info, warn};
use rig::completion::CompletionModel;
use solana_sdk::signature::Keypair;
use uuid::Uuid;
use rig_mongodb::{MongoDbPool, bson::doc};
use std::sync::Arc;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenState {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub price_usd: f64,
    pub price_sol: f64,
    pub volume_24h: f64,
    pub market_cap: f64,
    pub price_change_24h: f64,
    pub volume_change_24h: f64,
    pub timestamp: DateTime<Utc>,
}
pub struct SyncCollection {
    pool: Arc<MongoDbPool>,
    database: String,
}
impl SyncCollection {
    pub fn new(pool: Arc<MongoDbPool>, database: String) -> Self {
        Self { pool, database }
    }
    pub async fn save_token_state(&self, state: &TokenState) -> Result<()> {
        let collection = self.pool
            .database(&self.database)
            .collection("token_states");
        collection.insert_one(state, None).await?;
        Ok(())
    }
    pub async fn get_token_state(&self, token_address: &str) -> Result<Option<TokenState>> {
        let collection = self.pool
            .database(&self.database)
            .collection("token_states");
        let filter = doc! {
            "address": token_address
        };
        let options = rig_mongodb::options::FindOneOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        collection.find_one(filter, options)
            .await
            .map_err(anyhow::Error::from)
    }
    pub async fn get_token_history(
        &self,
        token_address: &str,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
    ) -> Result<Vec<TokenState>> {
        let collection = self.pool
            .database(&self.database)
            .collection("token_states");
        let filter = doc! {
            "address": token_address,
            "timestamp": {
                "$gte": start_time,
                "$lte": end_time
            }
        };
        let options = rig_mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        let cursor = collection.find(filter, options).await?;
        cursor.try_collect().await.map_err(anyhow::Error::from)
    }
    pub async fn cleanup_old_data(&self, retention_days: i64) -> Result<u64> {
        let cutoff = Utc::now() - chrono::Duration::days(retention_days);
        let collection = self.pool
            .database(&self.database)
            .collection::<TokenState>("token_states");
        let filter = doc! {
            "timestamp": { "$lt": cutoff }
        };
        let result = collection.delete_many(filter, None).await?;
        debug!("Cleaned up {} old token state records", result.deleted_count);
        Ok(result.deleted_count)
    }
}
pub struct DataSyncService<M: CompletionModel> {
    db: Arc<SyncCollection>,
    data_provider: Box<dyn DataProvider>,
    twitter: TwitterClient,
    trading_strategy: TradingStrategy<M>,
    dex: JupiterDex,
    personality: StoicPersonality,
    wallet: Keypair,
    sync_interval: u64,
}
impl<M: CompletionModel> DataSyncService<M> {
    pub fn new(
        db: SyncCollection,
        data_provider: Box<dyn DataProvider>,
        twitter: TwitterClient,
        trading_strategy: TradingStrategy<M>,
        dex: JupiterDex,
        wallet: Keypair,
        sync_interval: u64,
    ) -> Self {
        Self {
            db: Arc::new(db),
            data_provider,
            twitter,
            trading_strategy,
            dex,
            personality: StoicPersonality::new(),
            wallet,
            sync_interval,
        }
    }
    pub async fn start(&self) -> Result<()> {
        info!("Starting data sync service");
        loop {
            if let Err(e) = self.sync_market_data().await {
                tracing::error!("Error syncing market data: {}", e);
            }
            tokio::time::sleep(tokio::time::Duration::from_secs(self.sync_interval)).await;
        }
    }
    pub async fn sync_market_data(&self) -> Result<()> {
        info!("Starting market data sync cycle");
        // Fetch trending tokens
        info!("Fetching trending tokens from BirdEye");
        let trends = self.data_provider.get_trending_tokens(20).await?;
        info!("Found {} trending tokens", trends.len());
        // Insert token states and analyze trading opportunities
        for trend in trends {
            info!(
                "Processing token {} ({}) - Price: ${:.4}, 24h Change: {:.2}%, Volume: ${:.2}M",
                trend.metadata.name,
                trend.metadata.symbol,
                trend.metadata.price_usd,
                trend.price_change_24h,
                trend.metadata.volume_24h / 1_000_000.0
            );
            let state = self.market_trend_to_token_state(trend.clone());
            info!("Inserting token state into PostgreSQL");
            self.db.save_token_state(&state)?;
            // Format market data for LLM analysis
            let prompt = format!(
                "Analyze trading opportunity for {} ({}). Price: ${:.4}, 24h Change: {:.2}%, Volume: ${:.2}M",
                trend.metadata.name,
                trend.metadata.symbol,
                trend.metadata.price_usd,
                trend.price_change_24h,
                trend.metadata.volume_24h / 1_000_000.0
            );
            // Analyze trading opportunity
            info!("Analyzing trading opportunity with LLM");
            if let Ok(analysis) = self.trading_strategy.analyze_trading_opportunity(&prompt, 1.0).await {
                // Parse the analysis into a trade recommendation
                if let Ok(trade) = serde_json::from_str::<TradeRecommendation>(&analysis) {
                    info!(
                        "Received trade recommendation: Action={:?}, Amount={} SOL, Confidence={:.2}, Risk={}",
                        trade.action, trade.amount_in_sol, trade.confidence, trade.risk_assessment
                    );
                    // Execute trade if confidence is high enough
                    if trade.confidence >= 0.8 {
                        match trade.action {
                            TradeAction::Buy => {
                                info!("Executing BUY order for {} SOL worth of {}", 
                                    trade.amount_in_sol, trend.metadata.symbol);
                                if let Ok(signature) = self.dex.execute_swap(
                                    "So11111111111111111111111111111111111111112", // SOL
                                    &trade.token_address,
                                    trade.amount_in_sol as u64,
                                    &self.wallet,
                                ).await {
                                    info!("Trade executed successfully. Signature: {}", signature);
                                    // Generate and post tweet about the trade
                                    info!("Generating tweet for successful buy");
                                    let tweet = self.personality.generate_trade_tweet(
                                        &format!(
                                            "Action: Buy\nAmount: {} SOL\nToken: {}\nPrice: ${:.4}\nMarket Cap: ${:.2}M\n24h Volume: ${:.2}M\n24h Change: {:.2}%\nContract: {}\nTransaction: {}\nAnalysis: {}\nRisk Assessment: {}\nMarket Analysis:\n- Volume: {}\n- Price Trend: {}\n- Liquidity: {}\n- Momentum: {}",
                                            trade.amount_in_sol,
                                            trend.metadata.symbol,
                                            trend.metadata.price_usd,
                                            trend.metadata.market_cap / 1_000_000.0,
                                            trend.metadata.volume_24h / 1_000_000.0,
                                            trend.price_change_24h,
                                            trend.token_address,
                                            signature,
                                            trade.reasoning,
                                            trade.risk_assessment,
                                            trade.market_analysis.volume_analysis,
                                            trade.market_analysis.price_trend,
                                            trade.market_analysis.liquidity_assessment,
                                            trade.market_analysis.momentum_indicators
                                        ),
                                        "buy",
                                        trade.confidence,
                                    ).await?;
                                    info!("Posting tweet: {}", tweet);
                                    if let Err(e) = self.twitter.post_tweet(&tweet).await {
                                        warn!("Failed to post trade tweet: {}", e);
                                    }
                                } else {
                                    warn!("Failed to execute buy order");
                                }
                            },
                            TradeAction::Sell => {
                                info!("Executing SELL order for {} SOL worth of {}", 
                                    trade.amount_in_sol, trend.metadata.symbol);
                                if let Ok(signature) = self.dex.execute_swap(
                                    &trade.token_address,
                                    "So11111111111111111111111111111111111111112", // SOL
                                    trade.amount_in_sol as u64,
                                    &self.wallet,
                                ).await {
                                    info!("Trade executed successfully. Signature: {}", signature);
                                    // Generate and post tweet about the trade
                                    info!("Generating tweet for successful sell");
                                    let tweet = self.personality.generate_trade_tweet(
                                        &format!(
                                            "Action: Sell\nAmount: {} SOL\nToken: {}\nPrice: ${:.4}\nMarket Cap: ${:.2}M\n24h Volume: ${:.2}M\n24h Change: {:.2}%\nContract: {}\nTransaction: {}\nAnalysis: {}\nRisk Assessment: {}\nMarket Analysis:\n- Volume: {}\n- Price Trend: {}\n- Liquidity: {}\n- Momentum: {}",
                                            trade.amount_in_sol,
                                            trend.metadata.symbol,
                                            trend.metadata.price_usd,
                                            trend.metadata.market_cap / 1_000_000.0,
                                            trend.metadata.volume_24h / 1_000_000.0,
                                            trend.price_change_24h,
                                            trend.token_address,
                                            signature,
                                            trade.reasoning,
                                            trade.risk_assessment,
                                            trade.market_analysis.volume_analysis,
                                            trade.market_analysis.price_trend,
                                            trade.market_analysis.liquidity_assessment,
                                            trade.market_analysis.momentum_indicators
                                        ),
                                        "sell",
                                        trade.confidence,
                                    ).await?;
                                    info!("Posting tweet: {}", tweet);
                                    if let Err(e) = self.twitter.post_tweet(&tweet).await {
                                        warn!("Failed to post trade tweet: {}", e);
                                    }
                                } else {
                                    warn!("Failed to execute sell order");
                                }
                            },
                            TradeAction::Hold => {
                                info!("Decision: HOLD {} - {}", 
                                    trend.metadata.symbol, trade.reasoning);
                            }
                        }
                    } else {
                        info!("Skipping trade due to low confidence: {:.2}", trade.confidence);
                    }
                } else {
                    warn!("Failed to parse trade recommendation");
                }
            } else {
                warn!("Failed to get trading analysis from LLM");
            }
        }
        info!("Market data sync cycle complete");
        Ok(())
    }
    fn market_trend_to_token_state(&self, trend: MarketTrend) -> TokenState {
        TokenState {
            address: trend.token_address,
            symbol: trend.metadata.symbol,
            name: trend.metadata.name,
            price_sol: trend.metadata.price_sol,
            price_usd: trend.metadata.price_usd,
            market_cap: trend.metadata.market_cap,
            volume_24h: trend.metadata.volume_24h,
            price_change_24h: trend.price_change_24h,
            volume_change_24h: 0.0, // Placeholder, update as needed
            timestamp: Utc::now(),
        }
    }
}
</file>

<file path="agents/trader/src/decision/mod.rs">
use rig_core::message_bus::{MessageBus, Message};
use rig_solana_trader::personality::StoicPersonality;
pub struct PPODecisionAgent {
    message_bus: MessageBus,
    policy_network: PolicyNetwork,
    personality: StoicPersonality,
}
impl PPODecisionAgent {
    pub fn new(message_bus: MessageBus) -> Self {
        Self {
            message_bus,
            policy_network: PolicyNetwork::new(),
            personality: StoicPersonality::new()
        }
    }
    async fn decide_action(&mut self, state: &State) -> Action {
        // Combine LLM analysis with PPO
        let llm_analysis = self.personality.analyze_state(state).await;
        let ppo_action = self.policy_network.forward(state);
        // Risk management
        if state.risk_level > self.personality.risk_tolerance {
            return Action::Hold;
        }
        // Combine signals
        match (llm_analysis, ppo_action) {
            (Analysis::Buy, Action::Buy) => Action::Buy,
            (Analysis::Sell, Action::Sell) => Action::Sell,
            _ => Action::Hold
        }
    }
}
</file>

<file path="agents/trader/src/dex/jupiter.rs">
use anyhow::Result;
use base64::{Engine as _, engine::general_purpose::STANDARD};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    signature::{Keypair, Signer},
    transaction::Transaction,
};
#[derive(Debug, Deserialize, Serialize)]
pub struct QuoteResponse {
    pub data: QuoteData,
}
#[derive(Debug, Deserialize, Serialize)]
pub struct QuoteData {
    pub in_amount: String,
    pub out_amount: String,
    pub price_impact: f64,
    pub minimum_out_amount: String,
}
#[derive(Debug, Deserialize)]
pub struct SwapResponse {
    pub data: SwapData,
}
#[derive(Debug, Deserialize)]
pub struct SwapData {
    pub transaction: String,
}
pub struct JupiterDex {
    client: Client,
    rpc_client: RpcClient,
    api_key: String,
    slippage: f64,
}
impl JupiterDex {
    pub fn new(rpc_url: &str, api_key: String, slippage: f64) -> Self {
        Self {
            client: Client::new(),
            rpc_client: RpcClient::new(rpc_url.to_string()),
            api_key,
            slippage,
        }
    }
    pub async fn get_quote(&self, input_mint: &str, output_mint: &str, amount: u64) -> Result<QuoteResponse> {
        let url = format!(
            "https://price.jup.ag/v4/quote?inputMint={}&outputMint={}&amount={}&slippageBps={}",
            input_mint, output_mint, amount, (self.slippage * 100.0) as u32
        );
        let response = self.client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<QuoteResponse>()
            .await?;
        Ok(response)
    }
    pub async fn execute_swap(
        &self,
        input_mint: &str,
        output_mint: &str,
        amount: u64,
        wallet: &Keypair,
    ) -> Result<String> {
        // Get quote first
        let quote = self.get_quote(input_mint, output_mint, amount).await?;
        // Get swap transaction
        let url = "https://quote-api.jup.ag/v4/swap";
        let swap_request = serde_json::json!({
            "quoteResponse": quote,
            "userPublicKey": wallet.pubkey().to_string(),
            "wrapUnwrapSOL": true
        });
        let response = self.client
            .post(url)
            .header("X-API-KEY", &self.api_key)
            .json(&swap_request)
            .send()
            .await?
            .json::<SwapResponse>()
            .await?;
        // Decode and sign transaction
        let transaction_data = STANDARD.decode(response.data.transaction)?;
        let mut transaction: Transaction = bincode::deserialize(&transaction_data)?;
        transaction.sign(&[wallet], self.rpc_client.get_latest_blockhash()?);
        // Send transaction
        let signature = self.rpc_client.send_transaction(&transaction)?;
        Ok(signature.to_string())
    }
    pub async fn check_token_tradable(&self, token_address: &str) -> Result<bool> {
        // Try to get quotes in both directions (token -> SOL and SOL -> token)
        let sol_mint = "So11111111111111111111111111111111111111112";
        let amount = 1_000_000; // 1 SOL in lamports
        let to_token = self.get_quote(sol_mint, token_address, amount).await;
        let from_token = self.get_quote(token_address, sol_mint, amount).await;
        Ok(to_token.is_ok() && from_token.is_ok())
    }
}
</file>

<file path="agents/trader/src/dex/mod.rs">
pub mod jupiter;
pub use jupiter::JupiterDex;
</file>

<file path="agents/trader/src/execution/mod.rs">
use solana_sdk::{
    signature::{Keypair, Signature},
    transaction::Transaction,
};
use anchor_lang::prelude::*;
use anyhow::Result;
use rig_core::message_bus::MessageBus;
use std::sync::Arc;
#[derive(Debug, Clone)]
pub struct TradeParams {
    pub mint: String,
    pub amount: f64,
    pub slippage: u8,
    pub units: u64,
}
pub struct SolanaExecutor {
    keypair: Arc<Keypair>,
    message_bus: MessageBus,
    risk_threshold: f64,
}
impl SolanaExecutor {
    pub fn new(keypair: Arc<Keypair>, message_bus: MessageBus) -> Self {
        Self {
            keypair,
            message_bus,
            risk_threshold: 0.2,
        }
    }
    pub async fn execute_trade(&self, action: TradeAction) -> Result<Signature> {
        let program = anchor_spl::token::ID;
        let accounts = self.build_accounts(&action.params.mint);
        let tx = Transaction::new_signed_with_payer(
            &[Instruction::new_with_bytes(
                program,
                &action.encode(),
                accounts,
            )],
            Some(&self.keypair.pubkey()),
            &[&self.keypair],
            Hash::default(),
        );
        self.validate_risk(&action).await?;
        self.message_bus
            .publish(TradeEvent::new(action.clone()))
            .await;
        self.message_bus.rpc_client.send_transaction(&tx).await
    }
    async fn validate_risk(&self, action: &TradeAction) -> Result<()> {
        let position_size = match action.action_type {
            TradeType::Buy => action.params.amount,
            TradeType::Sell => -action.params.amount,
        };
        if position_size.abs() > self.risk_threshold {
            return Err(anyhow::anyhow!(
                "Position size {} exceeds risk threshold {}",
                position_size,
                self.risk_threshold
            ));
        }
        Ok(())
    }
    fn build_accounts(&self, mint: &str) -> Vec<AccountMeta> {
        // Implementation depends on your specific program accounts
        vec![]
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TradeType {
    Buy,
    Sell,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeAction {
    pub action_type: TradeType,
    pub params: TradeParams,
    pub analysis: Option<TradeAnalysis>,
}
impl TradeAction {
    pub fn encode(&self) -> Vec<u8> {
        // Implementation depends on your program's instruction format
        vec![]
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeAnalysis {
    pub market_cap: f64,
    pub volume_ratio: f64,
    pub risk_assessment: f64,
}
</file>

<file path="agents/trader/src/integrations/twitter.rs">
use oauth1::Token;
use reqwest::Client;
use rig_solana_trader::personality::StoicPersonality;
pub struct TwitterClient {
    client: Client,
    personality: StoicPersonality,
}
impl TwitterClient {
    pub fn new(personality: StoicPersonality) -> Self {
        Self {
            client: Client::new(),
            personality,
        }
    }
    pub async fn post_trade(&self, action: &TradeAction, tx_hash: &str) -> Result<()> {
        let tweet = self.personality
            .generate_trade_tweet(action, tx_hash)
            .await?;
        let token = Token::new(
            &std::env::var("TWITTER_API_KEY")?,
            &std::env::var("TWITTER_API_SECRET")?,
        );
        let access = Token::new(
            &std::env::var("TWITTER_ACCESS_TOKEN")?,
            &std::env::var("TWITTER_ACCESS_SECRET")?,
        );
        let auth_header = oauth1::authorize("POST", "https://api.twitter.com/2/tweets", &token, Some(&access), None);
        self.client
            .post("https://api.twitter.com/2/tweets")
            .header("Authorization", auth_header)
            .json(&serde_json::json!({ "text": tweet }))
            .send()
            .await?;
        Ok(())
    }
}
</file>

<file path="agents/trader/src/market_data/birdeye.rs">
//! BirdEye API Integration
//!
//! This module implements the BirdEye API client for fetching Solana token data.
//! BirdEye provides comprehensive market data including:
//! - Token metadata and prices
//! - Trading volume and liquidity
//! - Price changes and market trends
//!
//! # Rate Limits
//! BirdEye API has the following limits:
//! - 10 requests per second
//! - 100,000 requests per day
//! - 100 tokens per request for trending endpoints
//!
//! # Error Handling
//! The implementation includes:
//! - Automatic retry on rate limit errors (429)
//! - Exponential backoff for failed requests
//! - Detailed error logging for debugging
//!
//! # Configuration
//! Required environment variables:
//! - `BIRDEYE_API_KEY`: API key from BirdEye
//!
//! # Endpoints
//! - GET /token/meta: Token metadata
//! - GET /token/list: Token listings
//! - GET /token/trending: Trending tokens
//! - GET /token/price: Real-time prices
use crate::market_data::{
    DataProvider, MarketTrend, OnChainMetrics, PricePoint, SocialMetrics, TokenMetadata,
};
use anyhow::Result;
use async_trait::async_trait;
use chrono::DateTime;
use reqwest::Client;
use serde::Deserialize;
use std::collections::HashMap;
use tracing::{debug, info, instrument};
#[derive(Debug, Deserialize)]
struct BirdEyeTokenResponse {
    data: BirdEyeTokenData,
    success: bool,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenData {
    address: String,
    symbol: String,
    name: String,
    price: f64,
    volume_24h: f64,
    decimals: u8,
    price_sol: f64,
    market_cap: f64,
    fully_diluted_market_cap: Option<f64>,
    circulating_supply: Option<f64>,
    total_supply: Option<f64>,
    price_change_24h: Option<f64>,
    volume_change_24h: Option<f64>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTrendingResponse {
    data: BirdEyeTrendingResponseData,
    success: bool,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTrendingResponseData {
    #[serde(rename = "updateUnixTime")]
    update_unix_time: i64,
    #[serde(rename = "updateTime")]
    update_time: String,
    tokens: Vec<BirdEyeTrendingToken>,
    total: i64,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTrendingToken {
    address: String,
    decimals: u8,
    liquidity: f64,
    #[serde(rename = "logoURI")]
    logo_uri: Option<String>,
    name: String,
    symbol: String,
    #[serde(rename = "volume_24hUSD")]
    volume_24h_usd: Option<f64>,
    rank: Option<i64>,
    price: f64,
    #[serde(rename = "priceChange24h")]
    price_change_24h: Option<f64>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeNewListingResponse {
    success: bool,
    data: BirdEyeNewListingData,
}
#[derive(Debug, Deserialize)]
struct BirdEyeNewListingData {
    items: Vec<BirdEyeNewListingToken>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeNewListingToken {
    address: String,
    symbol: String,
    name: String,
    decimals: u8,
    source: String,
    #[serde(rename = "liquidityAddedAt")]
    liquidity_added_at: String,
    #[serde(rename = "logoURI")]
    logo_uri: Option<String>,
    liquidity: f64,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenListResponse {
    success: bool,
    data: BirdEyeTokenListData,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenListData {
    #[serde(rename = "updateUnixTime")]
    update_unix_time: i64,
    #[serde(rename = "updateTime")]
    update_time: String,
    tokens: Vec<BirdEyeTokenListToken>,
    total: i64,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenListToken {
    address: String,
    decimals: u8,
    #[serde(rename = "lastTradeUnixTime")]
    last_trade_unix_time: i64,
    liquidity: f64,
    #[serde(rename = "logoURI")]
    logo_uri: Option<String>,
    mc: f64,
    name: String,
    symbol: String,
    #[serde(rename = "v24hChangePercent")]
    v24h_change_percent: f64,
    #[serde(rename = "v24hUSD")]
    v24h_usd: f64,
}
#[derive(Debug, Deserialize)]
struct BirdEyeWalletResponse {
    success: bool,
    data: BirdEyeWalletData,
}
#[derive(Debug, Deserialize)]
struct BirdEyeWalletData {
    wallet: String,
    #[serde(rename = "totalUsd")]
    total_usd: f64,
    items: Vec<BirdEyeWalletToken>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeWalletToken {
    address: String,
    decimals: u8,
    balance: i64,
    #[serde(rename = "uiAmount")]
    ui_amount: f64,
    #[serde(rename = "chainId")]
    chain_id: String,
    name: String,
    symbol: String,
    icon: Option<String>,
    #[serde(rename = "logoURI")]
    logo_uri: Option<String>,
    #[serde(rename = "priceUsd")]
    price_usd: f64,
    #[serde(rename = "valueUsd")]
    value_usd: f64,
}
#[derive(Debug, Deserialize, Clone)]
struct BirdEyeTransactionResponse {
    success: bool,
    data: HashMap<String, Vec<BirdEyeTransaction>>,
}
#[derive(Debug, Deserialize, Clone)]
struct BirdEyeTransaction {
    #[serde(rename = "txHash")]
    tx_hash: String,
    #[serde(rename = "blockNumber")]
    block_number: i64,
    #[serde(rename = "blockTime")]
    block_time: String,
    status: bool,
    from: String,
    to: String,
    fee: i64,
    #[serde(rename = "mainAction")]
    main_action: String,
    #[serde(rename = "balanceChange")]
    balance_change: Vec<BirdEyeBalanceChange>,
    #[serde(rename = "contractLabel")]
    contract_label: Option<BirdEyeContractLabel>,
}
#[derive(Debug, Deserialize, Clone)]
struct BirdEyeBalanceChange {
    amount: f64,
    symbol: String,
    name: String,
    decimals: u8,
    address: String,
    #[serde(rename = "logoURI")]
    logo_uri: Option<String>,
    token_account: Option<String>,
    owner: Option<String>,
    #[serde(rename = "programId")]
    program_id: Option<String>,
}
#[derive(Debug, Deserialize, Clone)]
struct BirdEyeContractLabel {
    address: String,
    name: String,
    metadata: BirdEyeContractMetadata,
}
#[derive(Debug, Deserialize, Clone)]
struct BirdEyeContractMetadata {
    icon: String,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenMetadataResponse {
    data: HashMap<String, BirdEyeTokenMetadata>,
    success: bool,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenMetadata {
    address: String,
    name: String,
    symbol: String,
    decimals: u8,
    extensions: BirdEyeTokenExtensions,
    #[serde(rename = "logo_uri")]
    logo_uri: Option<String>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeTokenExtensions {
    #[serde(rename = "coingecko_id")]
    coingecko_id: Option<String>,
    #[serde(rename = "serum_v3_usdc")]
    serum_v3_usdc: Option<String>,
    #[serde(rename = "serum_v3_usdt")]
    serum_v3_usdt: Option<String>,
    website: Option<String>,
    telegram: Option<String>,
    twitter: Option<String>,
    description: Option<String>,
    discord: Option<String>,
    medium: Option<String>,
}
#[derive(Debug, Deserialize)]
struct BirdEyeMarketDataResponse {
    data: BirdEyeMarketData,
    success: bool,
}
#[derive(Debug, Deserialize)]
struct BirdEyeMarketData {
    address: String,
    price: f64,
    liquidity: f64,
    supply: f64,
    marketcap: f64,
    #[serde(rename = "circulating_supply")]
    circulating_supply: f64,
    #[serde(rename = "circulating_marketcap")]
    circulating_marketcap: f64,
}
#[derive(Debug)]
pub struct BirdEyeProvider {
    api_key: String,
    client: Client,
}
impl BirdEyeProvider {
    pub fn new(api_key: String) -> Self {
        info!("Initializing BirdEye API provider");
        Self {
            api_key,
            client: Client::new(),
        }
    }
    #[instrument(skip(self), fields(api = "birdeye"))]
    async fn get_trending_by_rank(&self) -> Result<Vec<MarketTrend>> {
        debug!("Fetching trending tokens by rank");
        let url = "https://public-api.birdeye.so/defi/token_trending?sort_by=rank&sort_type=asc&offset=0&limit=20";
        self.get_trending_tokens_internal(url).await
    }
    #[instrument(skip(self), fields(api = "birdeye"))]
    async fn get_trending_by_volume(&self) -> Result<Vec<MarketTrend>> {
        debug!("Fetching trending tokens by volume");
        let url = "https://public-api.birdeye.so/defi/token_trending?sort_by=volume_24hUSD&sort_type=asc&offset=0&limit=20";
        self.get_trending_tokens_internal(url).await
    }
    #[instrument(skip(self), fields(api = "birdeye"))]
    async fn get_trending_by_liquidity(&self) -> Result<Vec<MarketTrend>> {
        debug!("Fetching trending tokens by liquidity");
        let url = "https://public-api.birdeye.so/defi/token_trending?sort_by=liquidity&sort_type=asc&offset=0&limit=20";
        self.get_trending_tokens_internal(url).await
    }
    async fn get_new_listings(&self, limit: usize) -> Result<Vec<MarketTrend>> {
        let url = format!(
            "https://public-api.birdeye.so/defi/v2/tokens/new_listing?time_to=10000000000&limit={}&meme_platform_enabled=true",
            limit
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeNewListingResponse>()
            .await?;
        Ok(response
            .data
            .items
            .into_iter()
            .map(|token| MarketTrend {
                token_address: token.address.clone(),
                metadata: TokenMetadata {
                    address: token.address,
                    symbol: token.symbol,
                    name: token.name,
                    decimals: token.decimals,
                    price_usd: 0.0, // Not available in new listings
                    price_sol: 0.0,
                    volume_24h: 0.0,
                    market_cap: 0.0,
                    fully_diluted_market_cap: 0.0,
                    circulating_supply: 0.0,
                    total_supply: 0.0,
                },
                price_change_24h: 0.0,
                volume_change_24h: 0.0,
                social_volume_24h: 0,
                dev_activity_24h: 0,
            })
            .collect())
    }
    async fn get_token_list_by_volume(
        &self,
        _limit: usize,
        _min_liquidity: f64,
    ) -> Result<Vec<MarketTrend>> {
        let url = "https://public-api.birdeye.so/defi/tokenlist?sort_by=v24hUSD&sort_type=desc&offset=0&limit=50&min_liquidity=100";
        self.get_token_list_internal(url).await
    }
    async fn get_token_list_by_market_cap(
        &self,
        _limit: usize,
        _min_liquidity: f64,
    ) -> Result<Vec<MarketTrend>> {
        let url = "https://public-api.birdeye.so/defi/tokenlist?sort_by=mc&sort_type=desc&offset=0&limit=50&min_liquidity=100";
        self.get_token_list_internal(url).await
    }
    async fn get_token_list_by_price_change(
        &self,
        _limit: usize,
        _min_liquidity: f64,
    ) -> Result<Vec<MarketTrend>> {
        let url = "https://public-api.birdeye.so/defi/tokenlist?sort_by=v24hChangePercent&sort_type=desc&offset=0&limit=50&min_liquidity=100";
        self.get_token_list_internal(url).await
    }
    async fn get_token_list_internal(&self, url: &str) -> Result<Vec<MarketTrend>> {
        let response = self
            .client
            .get(url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeTokenListResponse>()
            .await?;
        Ok(response
            .data
            .tokens
            .into_iter()
            .map(|token| MarketTrend {
                token_address: token.address.clone(),
                metadata: TokenMetadata {
                    address: token.address,
                    symbol: token.symbol,
                    name: token.name,
                    decimals: token.decimals,
                    price_usd: 0.0, // Need to fetch separately
                    price_sol: 0.0,
                    volume_24h: token.v24h_usd,
                    market_cap: token.mc,
                    fully_diluted_market_cap: 0.0,
                    circulating_supply: 0.0,
                    total_supply: 0.0,
                },
                price_change_24h: token.v24h_change_percent,
                volume_change_24h: 0.0,
                social_volume_24h: 0,
                dev_activity_24h: 0,
            })
            .collect())
    }
    async fn get_wallet_tokens(&self, wallet_address: &str) -> Result<BirdEyeWalletData> {
        let url = format!(
            "https://public-api.birdeye.so/v1/wallet/token_list?wallet={}",
            wallet_address
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeWalletResponse>()
            .await?;
        Ok(response.data)
    }
    async fn get_wallet_transactions(
        &self,
        wallet_address: &str,
        limit: usize,
    ) -> Result<Vec<BirdEyeTransaction>> {
        let url = format!(
            "https://public-api.birdeye.so/v1/wallet/tx_list?wallet={}&limit={}",
            wallet_address, limit
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeTransactionResponse>()
            .await?;
        Ok(response.data.get("solana").cloned().unwrap_or_default())
    }
    #[instrument(skip(self), fields(api = "birdeye"))]
    async fn get_trending_tokens_internal(&self, url: &str) -> Result<Vec<MarketTrend>> {
        debug!(url = %url, "Making API request");
        let response = self
            .client
            .get(url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeTrendingResponse>()
            .await?;
        info!(
            token_count = response.data.tokens.len(),
            "Successfully parsed trending tokens"
        );
        Ok(response
            .data
            .tokens
            .into_iter()
            .map(|token| MarketTrend {
                token_address: token.address.clone(),
                metadata: TokenMetadata {
                    address: token.address,
                    symbol: token.symbol,
                    name: token.name,
                    decimals: token.decimals,
                    price_usd: token.price,
                    price_sol: token.price, // Price is in USD
                    volume_24h: token.volume_24h_usd.unwrap_or(0.0),
                    market_cap: 0.0, // Not available in trending response
                    fully_diluted_market_cap: 0.0,
                    circulating_supply: 0.0,
                    total_supply: 0.0,
                },
                price_change_24h: token.price_change_24h.unwrap_or(0.0),
                volume_change_24h: 0.0, // Not available in trending response
                social_volume_24h: 0,
                dev_activity_24h: 0,
            })
            .collect())
    }
}
#[async_trait]
impl DataProvider for BirdEyeProvider {
    async fn get_token_metadata(&self, token_address: &str) -> Result<TokenMetadata> {
        let url = format!(
            "https://public-api.birdeye.so/defi/v3/token/meta-data/multiple?list_address={}",
            token_address
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeTokenMetadataResponse>()
            .await?;
        let metadata = response
            .data
            .get(token_address)
            .ok_or_else(|| anyhow::anyhow!("Token metadata not found"))?;
        // Get market data
        let market_url = format!(
            "https://public-api.birdeye.so/defi/v3/token/market-data?address={}",
            token_address
        );
        let market_data = self
            .client
            .get(&market_url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<BirdEyeMarketDataResponse>()
            .await?;
        Ok(TokenMetadata {
            address: metadata.address.clone(),
            symbol: metadata.symbol.clone(),
            name: metadata.name.clone(),
            decimals: metadata.decimals,
            price_usd: market_data.data.price,
            price_sol: market_data.data.price, // Price is in USD
            volume_24h: 0.0,                   // Not available in this endpoint
            market_cap: market_data.data.marketcap,
            fully_diluted_market_cap: market_data.data.marketcap,
            circulating_supply: market_data.data.circulating_supply,
            total_supply: market_data.data.supply,
        })
    }
    #[instrument(skip(self), fields(api = "birdeye"))]
    async fn get_trending_tokens(&self, _limit: usize) -> Result<Vec<MarketTrend>> {
        debug!("Fetching trending tokens from all sources");
        let mut all_trends = Vec::new();
        // Collect trends from all sorting methods
        if let Ok(mut trends) = self.get_trending_by_rank().await {
            debug!(count = trends.len(), "Got trending by rank");
            all_trends.append(&mut trends);
        }
        if let Ok(mut trends) = self.get_trending_by_volume().await {
            debug!(count = trends.len(), "Got trending by volume");
            all_trends.append(&mut trends);
        }
        if let Ok(mut trends) = self.get_trending_by_liquidity().await {
            debug!(count = trends.len(), "Got trending by liquidity");
            all_trends.append(&mut trends);
        }
        // Deduplicate by token address
        let mut unique_trends = HashMap::new();
        for trend in all_trends {
            unique_trends
                .entry(trend.token_address.clone())
                .or_insert(trend);
        }
        let trends: Vec<_> = unique_trends.into_values().collect();
        info!(
            total_trends = trends.len(),
            "Successfully aggregated trending tokens"
        );
        Ok(trends)
    }
    async fn get_historical_prices(&self, address: &str) -> Result<Vec<PricePoint>> {
        let url = format!(
            "https://public-api.birdeye.so/public/price_history?address={}&type=hour&limit=168",
            address
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<serde_json::Value>()
            .await?;
        let data = response["data"]
            .as_array()
            .ok_or_else(|| anyhow::anyhow!("Invalid response format"))?;
        let prices: Vec<PricePoint> = data
            .iter()
            .filter_map(|point| {
                let timestamp = point["timestamp"].as_i64()?;
                let price = point["value"].as_f64()?;
                let volume = point["volume"].as_f64().unwrap_or(0.0);
                Some(PricePoint {
                    timestamp: DateTime::from_timestamp(timestamp, 0)?,
                    price,
                    volume,
                })
            })
            .collect();
        Ok(prices)
    }
    async fn get_onchain_metrics(&self, address: &str) -> Result<OnChainMetrics> {
        let url = format!(
            "https://public-api.birdeye.so/public/token_holders?address={}",
            address
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?
            .json::<serde_json::Value>()
            .await?;
        let data = response["data"]
            .as_object()
            .ok_or_else(|| anyhow::anyhow!("Invalid response format"))?;
        Ok(OnChainMetrics {
            unique_holders: data["unique_holders"].as_u64().unwrap_or(0) as u32,
            active_wallets_24h: data["active_wallets_24h"].as_u64().unwrap_or(0) as u32,
            transactions_24h: data["transactions_24h"].as_u64().unwrap_or(0) as u32,
            average_transaction_size: data["avg_transaction_size"].as_f64().unwrap_or(0.0),
            whale_transactions_24h: data["whale_transactions_24h"].as_u64().unwrap_or(0) as u32,
        })
    }
    async fn get_social_metrics(&self, _address: &str) -> Result<SocialMetrics> {
        // BirdEye doesn't provide social metrics
        Err(anyhow::anyhow!("Social metrics not available from BirdEye"))
    }
}
</file>

<file path="agents/trader/src/market_data/loaders.rs">
use rig::loaders::{FileLoader, PDFLoader};
use anyhow::Result;
use tracing::debug;
use std::path::Path;
pub struct MarketDataLoader {
    file_loader: FileLoader,
    pdf_loader: PDFLoader,
}
impl MarketDataLoader {
    pub fn new() -> Self {
        Self {
            file_loader: FileLoader::new(),
            pdf_loader: PDFLoader::new(),
        }
    }
    pub async fn load_market_report(&self, path: impl AsRef<Path>) -> Result<String> {
        debug!("Loading market report from {:?}", path.as_ref());
        let content = if path.as_ref().extension().map_or(false, |ext| ext == "pdf") {
            self.pdf_loader.load(path).await?
        } else {
            self.file_loader.load(path).await?
        };
        Ok(content)
    }
    pub async fn load_token_whitepaper(&self, path: impl AsRef<Path>) -> Result<String> {
        debug!("Loading token whitepaper from {:?}", path.as_ref());
        self.pdf_loader.load(path).await
    }
    pub async fn load_technical_analysis(&self, path: impl AsRef<Path>) -> Result<String> {
        debug!("Loading technical analysis from {:?}", path.as_ref());
        self.file_loader.load(path).await
    }
}
</file>

<file path="agents/trader/src/market_data/mod.rs">
pub mod birdeye;
pub mod streaming;
pub mod storage;
pub mod sentiment;
pub mod macro_indicators;
pub mod feature_engineering;
pub mod vector_store;
use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, debug, warn};
use vector_store::{TokenVectorStore, TokenAnalysis};
use crate::database::DatabaseClient;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedTokenMetadata {
    // Base token data
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    // Price metrics
    pub price_usd: f64,
    pub price_sol: f64,
    pub price_change_1h: f64,
    pub price_change_24h: f64,
    pub price_change_7d: f64,
    // Volume metrics
    pub volume_24h: f64,
    pub volume_change_24h: f64,
    pub volume_by_price_24h: f64, // Volume weighted by price
    // Market metrics
    pub market_cap: f64,
    pub fully_diluted_market_cap: f64,
    pub circulating_supply: f64,
    pub total_supply: f64,
    // Liquidity metrics
    pub liquidity_usd: f64,
    pub liquidity_sol: f64,
    pub liquidity_change_24h: f64,
    // Technical indicators
    pub rsi_14: Option<f64>,
    pub macd: Option<f64>,
    pub macd_signal: Option<f64>,
    pub bollinger_upper: Option<f64>,
    pub bollinger_lower: Option<f64>,
    // On-chain metrics
    pub unique_holders: u32,
    pub active_wallets_24h: u32,
    pub whale_transactions_24h: u32,
    pub average_transaction_size: f64,
    // Sentiment metrics
    pub social_score: Option<f64>,
    pub social_volume: Option<u32>,
    pub social_sentiment: Option<f64>,
    pub dev_activity: Option<u32>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MacroIndicator {
    pub timestamp: DateTime<Utc>,
    pub sol_dominance: f64,
    pub total_market_cap: f64,
    pub total_volume_24h: f64,
    pub market_trend: String,
    pub fear_greed_index: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureVector {
    pub token_address: String,
    pub timestamp: DateTime<Utc>,
    pub features: Vec<f64>,
    pub feature_names: Vec<String>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketTrend {
    pub token_address: String,
    pub metadata: TokenMetadata,
    pub price_change_24h: f64,
    pub volume_change_24h: f64,
    pub social_volume_24h: u32,
    pub dev_activity_24h: u32,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: DateTime<Utc>,
    pub price: f64,
    pub volume: f64,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OnChainMetrics {
    pub unique_holders: u32,
    pub active_wallets_24h: u32,
    pub transactions_24h: u32,
    pub average_transaction_size: f64,
    pub whale_transactions_24h: u32,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SocialMetrics {
    pub twitter_followers: u32,
    pub twitter_engagement_rate: f64,
    pub discord_members: u32,
    pub github_stars: u32,
    pub telegram_members: u32,
}
#[async_trait]
pub trait DataProvider: Send + Sync + std::fmt::Debug {
    async fn get_token_metadata(&self, token_address: &str) -> Result<EnhancedTokenMetadata>;
    async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<MarketTrend>>;
    async fn get_historical_prices(&self, address: &str, timeframe: &str) -> Result<Vec<PricePoint>>;
    async fn get_macro_indicators(&self) -> Result<MacroIndicator>;
    async fn get_social_metrics(&self, address: &str) -> Result<SocialMetrics>;
    async fn get_feature_vector(&self, token_address: &str) -> Result<FeatureVector>;
}
#[derive(Debug)]
pub struct AggregatedDataProvider {
    providers: Vec<Arc<dyn DataProvider>>,
    cache: Arc<RwLock<DataCache>>,
}
impl AggregatedDataProvider {
    pub fn new(providers: Vec<Arc<dyn DataProvider>>) -> Self {
        Self {
            providers,
            cache: Arc::new(RwLock::new(DataCache::default())),
        }
    }
}
#[async_trait]
impl DataProvider for AggregatedDataProvider {
    async fn get_token_metadata(&self, token_address: &str) -> Result<EnhancedTokenMetadata> {
        // Try each provider in sequence until one succeeds
        for provider in &self.providers {
            if let Ok(metadata) = provider.get_token_metadata(token_address).await {
                return Ok(metadata);
            }
        }
        Err(anyhow::anyhow!("No provider could fetch token metadata"))
    }
    async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<MarketTrend>> {
        let mut all_trends = Vec::new();
        // Collect trends from all providers
        for provider in &self.providers {
            if let Ok(mut trends) = provider.get_trending_tokens(limit).await {
                all_trends.append(&mut trends);
            }
        }
        // Deduplicate by token address
        let mut unique_trends = HashMap::new();
        for trend in all_trends {
            unique_trends.entry(trend.token_address.clone())
                .or_insert(trend);
        }
        Ok(unique_trends.into_values().take(limit).collect())
    }
    async fn get_historical_prices(&self, address: &str, timeframe: &str) -> Result<Vec<PricePoint>> {
        // Try each provider in sequence until one succeeds
        for provider in &self.providers {
            if let Ok(prices) = provider.get_historical_prices(address, timeframe).await {
                return Ok(prices);
            }
        }
        Err(anyhow::anyhow!("No provider could fetch historical prices"))
    }
    async fn get_macro_indicators(&self) -> Result<MacroIndicator> {
        // Try each provider in sequence until one succeeds
        for provider in &self.providers {
            if let Ok(indicators) = provider.get_macro_indicators().await {
                return Ok(indicators);
            }
        }
        Err(anyhow::anyhow!("No provider could fetch macro indicators"))
    }
    async fn get_social_metrics(&self, address: &str) -> Result<SocialMetrics> {
        // Try each provider in sequence until one succeeds
        for provider in &self.providers {
            if let Ok(metrics) = provider.get_social_metrics(address).await {
                return Ok(metrics);
            }
        }
        Err(anyhow::anyhow!("No provider could fetch social metrics"))
    }
    async fn get_feature_vector(&self, token_address: &str) -> Result<FeatureVector> {
        // Try each provider in sequence until one succeeds
        for provider in &self.providers {
            if let Ok(vector) = provider.get_feature_vector(token_address).await {
                return Ok(vector);
            }
        }
        Err(anyhow::anyhow!("No provider could fetch feature vector"))
    }
}
#[derive(Debug, Default)]
struct DataCache {
    metadata_cache: HashMap<String, (EnhancedTokenMetadata, DateTime<Utc>)>,
    trends_cache: HashMap<String, (Vec<MarketTrend>, DateTime<Utc>)>,
}
pub struct MarketDataProvider {
    vector_store: TokenVectorStore,
    db_client: DatabaseClient,
    // ... existing fields ...
}
impl MarketDataProvider {
    pub async fn new(openai_api_key: &str, db_client: DatabaseClient) -> Result<Self> {
        let vector_store = TokenVectorStore::new(openai_api_key, db_client.clone()).await?;
        Ok(Self {
            vector_store,
            db_client,
            // ... initialize other fields ...
        })
    }
    pub async fn analyze_token(&mut self, token_address: &str) -> Result<()> {
        debug!("Analyzing token {}", token_address);
        // Get token metadata and market data
        let metadata = self.get_token_metadata(token_address).await?;
        let market_data = self.get_market_data(token_address).await?;
        // Create token analysis
        let analysis = TokenAnalysis {
            token_address: token_address.to_string(),
            symbol: metadata.symbol.clone(),
            description: metadata.description.unwrap_or_default(),
            recent_events: market_data.recent_events,
            market_sentiment: self.analyze_market_sentiment(&market_data).await?,
        };
        // Add to vector store (which will also persist to database)
        self.vector_store.add_token_analysis(analysis).await?;
        Ok(())
    }
    pub async fn find_similar_tokens(&self, query: &str, limit: usize) -> Result<Vec<TokenAnalysis>> {
        debug!("Finding tokens similar to query: {}", query);
        let results = self.vector_store.find_similar_tokens(query, limit).await?;
        Ok(results.into_iter().map(|(_, _, analysis)| analysis).collect())
    }
    pub async fn get_token_sentiment(&self, token_address: &str) -> Result<Option<String>> {
        self.vector_store.get_token_sentiment(token_address).await
    }
    async fn analyze_market_sentiment(&self, market_data: &MarketData) -> Result<String> {
        // TODO: Implement sentiment analysis using LLM
        // For now return a placeholder
        Ok("neutral".to_string())
    }
    // ... existing methods ...
}
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    struct MockProvider {
        name: String,
    }
    #[async_trait]
    impl DataProvider for MockProvider {
        async fn get_token_metadata(&self, address: &str) -> Result<EnhancedTokenMetadata> {
            Ok(EnhancedTokenMetadata {
                address: address.to_string(),
                symbol: "TEST".to_string(),
                name: format!("Test Token {}", self.name),
                decimals: 9,
                price_usd: 1.0,
                price_sol: 0.01,
                price_change_1h: 0.0,
                price_change_24h: 0.0,
                price_change_7d: 0.0,
                volume_24h: 1000000.0,
                volume_change_24h: 0.0,
                volume_by_price_24h: 0.0,
                market_cap: 10000000.0,
                fully_diluted_market_cap: 20000000.0,
                circulating_supply: 1000000.0,
                total_supply: 2000000.0,
                liquidity_usd: 0.0,
                liquidity_sol: 0.0,
                liquidity_change_24h: 0.0,
                rsi_14: None,
                macd: None,
                macd_signal: None,
                bollinger_upper: None,
                bollinger_lower: None,
                unique_holders: 0,
                active_wallets_24h: 0,
                whale_transactions_24h: 0,
                average_transaction_size: 0.0,
                social_score: None,
                social_volume: None,
                social_sentiment: None,
                dev_activity: None,
            })
        }
        async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<MarketTrend>> {
            let mut trends = Vec::new();
            for i in 0..limit {
                trends.push(MarketTrend {
                    token_address: format!("addr{}", i),
                    price_change_24h: 10.0,
                    volume_change_24h: 1000000.0,
                    social_volume_24h: 1000,
                    dev_activity_24h: 50,
                    metadata: TokenMetadata {
                        address: format!("addr{}", i),
                        symbol: "TEST".to_string(),
                        name: format!("Test Token {} {}", self.name, i),
                        decimals: 9,
                        price_usd: 1.0,
                        price_sol: 0.01,
                        volume_24h: 1000000.0,
                        market_cap: 10000000.0,
                        fully_diluted_market_cap: 20000000.0,
                        circulating_supply: 1000000.0,
                        total_supply: 2000000.0,
                    },
                });
            }
            Ok(trends)
        }
        async fn get_historical_prices(&self, _address: &str, _timeframe: &str) -> Result<Vec<PricePoint>> {
            Ok(vec![
                PricePoint {
                    timestamp: Utc::now(),
                    price: 1.0,
                    volume: 1000000.0,
                }
            ])
        }
        async fn get_macro_indicators(&self) -> Result<MacroIndicator> {
            Ok(MacroIndicator {
                timestamp: Utc::now(),
                sol_dominance: 0.5,
                total_market_cap: 1000000000.0,
                total_volume_24h: 10000000.0,
                market_trend: "Bullish".to_string(),
                fear_greed_index: 70,
            })
        }
        async fn get_social_metrics(&self, _address: &str) -> Result<SocialMetrics> {
            Ok(SocialMetrics {
                twitter_followers: 10000,
                twitter_engagement_rate: 1000,
                discord_members: 5000,
                telegram_members: 3000,
                github_stars: 100,
            })
        }
        async fn get_feature_vector(&self, _token_address: &str) -> Result<FeatureVector> {
            Ok(FeatureVector {
                token_address: "test_addr".to_string(),
                timestamp: Utc::now(),
                features: vec![0.5, 0.3, 0.8],
                feature_names: vec!["Social Score".to_string(), "Dev Activity".to_string(), "Liquidity Change".to_string()],
            })
        }
    }
    #[tokio::test]
    async fn test_aggregated_provider() {
        let mut provider = AggregatedDataProvider::new();
        provider.add_provider(Box::new(MockProvider { name: "A".to_string() }));
        provider.add_provider(Box::new(MockProvider { name: "B".to_string() }));
        let trends = provider.get_aggregated_trends(5).await.unwrap();
        assert_eq!(trends.len(), 5);
        let metadata = provider.get_token_metadata("test_addr").await.unwrap();
        assert_eq!(metadata.symbol, "TEST");
        let (onchain, social) = provider.get_comprehensive_metrics("test_addr").await.unwrap();
        assert_eq!(onchain.unique_holders, 1000);
        assert_eq!(social.twitter_followers, 10000);
    }
}
</file>

<file path="agents/trader/src/market_data/provider.rs">
use rig_core::{
    providers::{
        DataProvider,
        openai::Client as OpenAIClient,
        twitter::TwitterClient,
        solana::SolanaClient,
    },
    Result,
};
use serde::{Deserialize, Serialize};
use tracing::{info, debug};
use crate::vector_store::TokenVectorStore;
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TokenMetadata {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    pub total_supply: u64,
    pub market_cap: Option<f64>,
    pub volume_24h: Option<f64>,
    pub price_usd: Option<f64>,
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketData {
    pub token: TokenMetadata,
    pub price_history: Vec<PricePoint>,
    pub social_sentiment: Option<f64>,
    pub technical_indicators: TechnicalIndicators,
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PricePoint {
    pub timestamp: i64,
    pub price: f64,
    pub volume: f64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TechnicalIndicators {
    pub rsi_14: Option<f64>,
    pub macd: Option<f64>,
    pub ma_50: Option<f64>,
    pub ma_200: Option<f64>,
}
pub struct MarketDataProvider {
    openai_client: OpenAIClient,
    twitter_client: TwitterClient,
    solana_client: SolanaClient,
    vector_store: TokenVectorStore,
}
impl MarketDataProvider {
    pub async fn new(
        openai_api_key: &str,
        twitter_bearer_token: &str,
        solana_rpc_url: &str,
        vector_store: TokenVectorStore,
    ) -> Result<Self> {
        Ok(Self {
            openai_client: OpenAIClient::new(openai_api_key),
            twitter_client: TwitterClient::new(twitter_bearer_token),
            solana_client: SolanaClient::new(solana_rpc_url),
            vector_store,
        })
    }
    pub async fn get_token_metadata(&self, token_address: &str) -> Result<TokenMetadata> {
        debug!("Fetching metadata for token {}", token_address);
        // Get on-chain data
        let mint = self.solana_client.get_mint(token_address).await?;
        // Get market data from external sources
        let market_data = self.solana_client.get_token_market_data(token_address).await?;
        Ok(TokenMetadata {
            address: token_address.to_string(),
            symbol: mint.symbol,
            name: mint.name,
            decimals: mint.decimals,
            total_supply: mint.supply,
            market_cap: market_data.market_cap,
            volume_24h: market_data.volume_24h,
            price_usd: market_data.price_usd,
        })
    }
    pub async fn get_market_data(&self, token_address: &str) -> Result<MarketData> {
        debug!("Fetching market data for token {}", token_address);
        // Get token metadata
        let token = self.get_token_metadata(token_address).await?;
        // Get price history
        let price_history = self.solana_client
            .get_token_price_history(token_address)
            .await?;
        // Get social sentiment
        let social_sentiment = self.analyze_social_sentiment(&token.symbol).await?;
        // Calculate technical indicators
        let technical_indicators = self.calculate_technical_indicators(&price_history)?;
        Ok(MarketData {
            token,
            price_history,
            social_sentiment,
            technical_indicators,
        })
    }
    async fn analyze_social_sentiment(&self, symbol: &str) -> Result<Option<f64>> {
        debug!("Analyzing social sentiment for {}", symbol);
        // Get recent tweets
        let tweets = self.twitter_client
            .search_tweets(&format!("${}", symbol))
            .await?;
        if tweets.is_empty() {
            return Ok(None);
        }
        // Analyze sentiment using OpenAI
        let sentiment = self.openai_client
            .analyze_sentiment(&tweets.join("\n"))
            .await?;
        Ok(Some(sentiment))
    }
    fn calculate_technical_indicators(&self, price_history: &[PricePoint]) -> Result<TechnicalIndicators> {
        if price_history.is_empty() {
            return Ok(TechnicalIndicators::default());
        }
        // Calculate indicators
        let prices: Vec<f64> = price_history.iter().map(|p| p.price).collect();
        Ok(TechnicalIndicators {
            rsi_14: Some(self.calculate_rsi(&prices, 14)?),
            macd: Some(self.calculate_macd(&prices)?),
            ma_50: Some(self.calculate_moving_average(&prices, 50)?),
            ma_200: Some(self.calculate_moving_average(&prices, 200)?),
        })
    }
    fn calculate_rsi(&self, prices: &[f64], period: usize) -> Result<f64> {
        // TODO: Implement RSI calculation
        Ok(50.0)
    }
    fn calculate_macd(&self, prices: &[f64]) -> Result<f64> {
        // TODO: Implement MACD calculation
        Ok(0.0)
    }
    fn calculate_moving_average(&self, prices: &[f64], period: usize) -> Result<f64> {
        if prices.len() < period {
            return Ok(prices.last().copied().unwrap_or_default());
        }
        let sum: f64 = prices.iter().rev().take(period).sum();
        Ok(sum / period as f64)
    }
}
</file>

<file path="agents/trader/src/market_data/pumpfun.rs">
use reqwest::Client;
use serde::Deserialize;
#[derive(Debug, Deserialize)]
pub struct PumpFunMarketData {
    pub current_market_cap: f64,
    pub bonding_market_cap: f64,
    pub buy_volume_4h: f64,
    pub sell_volume_4h: f64,
}
pub struct MarketDataClient {
    client: Client,
    api_key: String,
}
impl MarketDataClient {
    const BASE_URL: &'static str = "https://api.pumpfunapi.org";
    pub fn new(api_key: String) -> Self {
        Self {
            client: Client::new(),
            api_key,
        }
    }
    pub async fn get_token_data(&self, mint: &str) -> Result<PumpFunMarketData> {
        let response = self.client
            .get(&format!("{}/pumpfun/new/tokens", Self::BASE_URL))
            .header("Authorization", &self.api_key)
            .send()
            .await?
            .json::<PumpFunMarketData>()
            .await?;
        Ok(response)
    }
    pub fn analyze_market(&self, data: &PumpFunMarketData) -> f64 {
        let liquidity_ratio = data.bonding_market_cap / data.current_market_cap.max(1.0);
        let volume_ratio = data.buy_volume_4h / data.sell_volume_4h.max(1.0);
        liquidity_ratio * volume_ratio
    }
}
</file>

<file path="agents/trader/src/market_data/storage.rs">
use super::{TokenMetadata, MarketTrend, PricePoint, OnChainMetrics, SocialMetrics};
use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::sync::RwLock;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenData {
    pub metadata: TokenMetadata,
    pub price_history: Vec<PricePoint>,
    pub onchain_metrics: Option<OnChainMetrics>,
    pub social_metrics: Option<SocialMetrics>,
    pub last_updated: DateTime<Utc>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketSnapshot {
    pub timestamp: DateTime<Utc>,
    pub trends: Vec<MarketTrend>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub token_address: String,
    pub entry_price: f64,
    pub quantity: f64,
    pub entry_time: DateTime<Utc>,
    pub partial_sells: Vec<PartialSell>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PartialSell {
    pub price: f64,
    pub quantity: f64,
    pub timestamp: DateTime<Utc>,
}
pub struct MarketDataStorage {
    token_data: Arc<RwLock<HashMap<String, TokenData>>>,
    market_snapshots: Arc<RwLock<Vec<MarketSnapshot>>>,
    positions: Arc<RwLock<HashMap<String, Position>>>,
    max_snapshots: usize,
    data_dir: PathBuf,
}
impl MarketDataStorage {
    pub fn new(max_snapshots: usize) -> Self {
        let data_dir = PathBuf::from("data");
        if !data_dir.exists() {
            fs::create_dir_all(&data_dir).expect("Failed to create data directory");
        }
        let mut storage = Self {
            token_data: Arc::new(RwLock::new(HashMap::new())),
            market_snapshots: Arc::new(RwLock::new(Vec::new())),
            positions: Arc::new(RwLock::new(HashMap::new())),
            max_snapshots,
            data_dir,
        };
        storage.load_from_disk();
        storage
    }
    fn load_from_disk(&mut self) {
        self.load_token_data();
        self.load_market_snapshots();
        self.load_positions();
    }
    fn load_token_data(&self) {
        let path = self.data_dir.join("token_data.json");
        if path.exists() {
            if let Ok(content) = fs::read_to_string(&path) {
                if let Ok(data) = serde_json::from_str::<HashMap<String, TokenData>>(&content) {
                    let mut token_data = self.token_data.blocking_write();
                    *token_data = data;
                }
            }
        }
    }
    fn load_market_snapshots(&self) {
        let path = self.data_dir.join("market_snapshots.json");
        if path.exists() {
            if let Ok(content) = fs::read_to_string(&path) {
                if let Ok(data) = serde_json::from_str::<Vec<MarketSnapshot>>(&content) {
                    let mut snapshots = self.market_snapshots.blocking_write();
                    *snapshots = data;
                }
            }
        }
    }
    fn load_positions(&self) {
        let path = self.data_dir.join("positions.json");
        if path.exists() {
            if let Ok(content) = fs::read_to_string(&path) {
                if let Ok(data) = serde_json::from_str::<HashMap<String, Position>>(&content) {
                    let mut positions = self.positions.blocking_write();
                    *positions = data;
                }
            }
        }
    }
    async fn save_to_disk(&self) -> Result<()> {
        self.save_token_data().await?;
        self.save_market_snapshots().await?;
        self.save_positions().await?;
        Ok(())
    }
    async fn save_token_data(&self) -> Result<()> {
        let path = self.data_dir.join("token_data.json");
        let token_data = self.token_data.read().await;
        let content = serde_json::to_string_pretty(&*token_data)?;
        fs::write(&path, content)?;
        Ok(())
    }
    async fn save_market_snapshots(&self) -> Result<()> {
        let path = self.data_dir.join("market_snapshots.json");
        let snapshots = self.market_snapshots.read().await;
        let content = serde_json::to_string_pretty(&*snapshots)?;
        fs::write(&path, content)?;
        Ok(())
    }
    async fn save_positions(&self) -> Result<()> {
        let path = self.data_dir.join("positions.json");
        let positions = self.positions.read().await;
        let content = serde_json::to_string_pretty(&*positions)?;
        fs::write(&path, content)?;
        Ok(())
    }
    pub async fn add_position(&self, position: Position) -> Result<()> {
        let mut positions = self.positions.write().await;
        positions.insert(position.token_address.clone(), position);
        drop(positions);
        self.save_positions().await?;
        Ok(())
    }
    pub async fn update_position(&self, token_address: &str, partial_sell: PartialSell) -> Result<()> {
        let mut positions = self.positions.write().await;
        if let Some(position) = positions.get_mut(token_address) {
            position.partial_sells.push(partial_sell);
            drop(positions);
            self.save_positions().await?;
        }
        Ok(())
    }
    pub async fn get_position(&self, token_address: &str) -> Option<Position> {
        self.positions.read().await.get(token_address).cloned()
    }
    pub async fn get_all_positions(&self) -> HashMap<String, Position> {
        self.positions.read().await.clone()
    }
    pub async fn update_token_data(
        &self,
        address: &str,
        metadata: Option<TokenMetadata>,
        price_point: Option<PricePoint>,
        onchain: Option<OnChainMetrics>,
        social: Option<SocialMetrics>,
    ) -> Result<()> {
        let mut data = self.token_data.write().await;
        let token_data = data.entry(address.to_string())
            .or_insert_with(|| TokenData {
                metadata: metadata.clone().unwrap_or_else(|| TokenMetadata {
                    address: address.to_string(),
                    symbol: String::new(),
                    name: String::new(),
                    decimals: 0,
                    price_usd: 0.0,
                    price_sol: 0.0,
                    volume_24h: 0.0,
                    market_cap: 0.0,
                    fully_diluted_market_cap: 0.0,
                    circulating_supply: 0.0,
                    total_supply: 0.0,
                }),
                price_history: Vec::new(),
                onchain_metrics: None,
                social_metrics: None,
                last_updated: Utc::now(),
            });
        if let Some(meta) = metadata {
            token_data.metadata = meta;
        }
        if let Some(price) = price_point {
            token_data.price_history.push(price);
            // Keep only last 24 hours of price points (assuming 1-minute intervals)
            if token_data.price_history.len() > 1440 {
                token_data.price_history.remove(0);
            }
        }
        if let Some(metrics) = onchain {
            token_data.onchain_metrics = Some(metrics);
        }
        if let Some(metrics) = social {
            token_data.social_metrics = Some(metrics);
        }
        token_data.last_updated = Utc::now();
        drop(data);
        self.save_token_data().await?;
        Ok(())
    }
    pub async fn add_market_snapshot(&self, trends: Vec<MarketTrend>) -> Result<()> {
        let mut snapshots = self.market_snapshots.write().await;
        snapshots.push(MarketSnapshot {
            timestamp: Utc::now(),
            trends,
        });
        while snapshots.len() > self.max_snapshots {
            snapshots.remove(0);
        }
        drop(snapshots);
        self.save_market_snapshots().await?;
        Ok(())
    }
    pub async fn get_token_data(&self, address: &str) -> Option<TokenData> {
        self.token_data.read().await.get(address).cloned()
    }
    pub async fn get_token_price_history(&self, address: &str) -> Option<Vec<PricePoint>> {
        self.token_data.read().await
            .get(address)
            .map(|data| data.price_history.clone())
    }
    pub async fn get_market_snapshots(&self, limit: Option<usize>) -> Vec<MarketSnapshot> {
        let snapshots = self.market_snapshots.read().await;
        match limit {
            Some(n) => snapshots.iter().rev().take(n).cloned().collect(),
            None => snapshots.clone(),
        }
    }
    pub async fn get_trending_tokens_history(&self) -> Vec<(DateTime<Utc>, Vec<String>)> {
        let snapshots = self.market_snapshots.read().await;
        snapshots.iter()
            .map(|snapshot| (
                snapshot.timestamp,
                snapshot.trends.iter()
                    .map(|trend| trend.token_address.clone())
                    .collect()
            ))
            .collect()
    }
    pub async fn analyze_token_momentum(&self, address: &str) -> Option<f64> {
        if let Some(data) = self.get_token_data(address).await {
            if data.price_history.len() < 2 {
                return None;
            }
            // Calculate price momentum over available history
            let price_changes: Vec<f64> = data.price_history.windows(2)
                .map(|window| {
                    let [prev, curr] = window else { unreachable!() };
                    (curr.price - prev.price) / prev.price
                })
                .collect();
            // Weight recent changes more heavily
            let weighted_sum: f64 = price_changes.iter()
                .enumerate()
                .map(|(i, change)| change * (i + 1) as f64)
                .sum();
            let weights_sum: f64 = (1..=price_changes.len()).sum::<usize>() as f64;
            Some(weighted_sum / weights_sum)
        } else {
            None
        }
    }
    pub async fn get_token_correlation(&self, token1: &str, token2: &str) -> Option<f64> {
        let (hist1, hist2) = match (
            self.get_token_price_history(token1).await,
            self.get_token_price_history(token2).await,
        ) {
            (Some(h1), Some(h2)) => (h1, h2),
            _ => return None,
        };
        if hist1.is_empty() || hist2.is_empty() {
            return None;
        }
        // Get overlapping time periods
        let start_time = hist1[0].timestamp.max(hist2[0].timestamp);
        let end_time = hist1.last().unwrap().timestamp.min(hist2.last().unwrap().timestamp);
        let prices1: Vec<f64> = hist1.iter()
            .filter(|p| p.timestamp >= start_time && p.timestamp <= end_time)
            .map(|p| p.price)
            .collect();
        let prices2: Vec<f64> = hist2.iter()
            .filter(|p| p.timestamp >= start_time && p.timestamp <= end_time)
            .map(|p| p.price)
            .collect();
        if prices1.len() < 2 || prices2.len() < 2 {
            return None;
        }
        // Calculate correlation coefficient
        let mean1 = prices1.iter().sum::<f64>() / prices1.len() as f64;
        let mean2 = prices2.iter().sum::<f64>() / prices2.len() as f64;
        let mut covariance = 0.0;
        let mut var1 = 0.0;
        let mut var2 = 0.0;
        for i in 0..prices1.len() {
            let diff1 = prices1[i] - mean1;
            let diff2 = prices2[i] - mean2;
            covariance += diff1 * diff2;
            var1 += diff1 * diff1;
            var2 += diff2 * diff2;
        }
        let correlation = covariance / (var1.sqrt() * var2.sqrt());
        Some(correlation)
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[tokio::test]
    async fn test_market_data_storage() {
        let storage = MarketDataStorage::new(100);
        // Test token data storage
        let address = "test_token";
        let metadata = TokenMetadata {
            address: address.to_string(),
            symbol: "TEST".to_string(),
            name: "Test Token".to_string(),
            decimals: 9,
            price_usd: 1.0,
            price_sol: 0.01,
            volume_24h: 1000000.0,
            market_cap: 10000000.0,
            fully_diluted_market_cap: 20000000.0,
            circulating_supply: 1000000.0,
            total_supply: 2000000.0,
        };
        storage.update_token_data(
            address,
            Some(metadata.clone()),
            Some(PricePoint {
                timestamp: Utc::now(),
                price: 1.0,
                volume: 1000000.0,
            }),
            None,
            None,
        ).await.unwrap();
        let data = storage.get_token_data(address).await.unwrap();
        assert_eq!(data.metadata.symbol, "TEST");
        assert_eq!(data.price_history.len(), 1);
    }
}
</file>

<file path="agents/trader/src/market_data/streaming.rs">
use anyhow::Result;
use futures::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::broadcast::{self, Sender};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{error, info};
use url::Url;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceUpdate {
    pub token_address: String,
    pub price: f64,
    pub volume: f64,
    pub timestamp: i64,
}
pub struct MarketDataStream {
    price_updates: Sender<PriceUpdate>,
    watched_tokens: HashMap<String, String>, // token_address -> symbol
}
impl MarketDataStream {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(100);
        Self {
            price_updates: tx,
            watched_tokens: HashMap::new(),
        }
    }
    pub fn subscribe(&self) -> broadcast::Receiver<PriceUpdate> {
        self.price_updates.subscribe()
    }
    pub fn watch_token(&mut self, token_address: String, symbol: String) {
        self.watched_tokens.insert(token_address, symbol);
    }
    pub async fn stream_token_data(&self) -> Result<()> {
        let ws_url = Url::parse("wss://public-api.birdeye.so/socket")?;
        let (ws_stream, _) = connect_async(ws_url).await?;
        let (mut write, mut read) = ws_stream.split();
        // Subscribe to price updates for watched tokens
        for token_address in self.watched_tokens.keys() {
            let subscribe_msg = serde_json::json!({
                "event": "subscribe",
                "channel": format!("price:{}", token_address),
            });
            write.send(Message::Text(subscribe_msg.to_string())).await?;
        }
        // Handle incoming messages
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    if let Ok(update) = serde_json::from_str::<PriceUpdate>(&text) {
                        if let Err(e) = self.price_updates.send(update.clone()) {
                            error!("Failed to broadcast price update: {}", e);
                        }
                    }
                }
                Ok(Message::Close(_)) => {
                    info!("WebSocket connection closed");
                    break;
                }
                Err(e) => {
                    error!("WebSocket error: {}", e);
                    break;
                }
                _ => {}
            }
        }
        Ok(())
    }
}
</file>

<file path="agents/trader/src/market_data/vector_store.rs">
use rig_core::{
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStoreIndex},
    Embed,
};
use rig_postgres::PostgresVectorStore;
use serde::{Deserialize, Serialize};
use anyhow::Result;
use tracing::{info, debug};
use crate::database::DatabaseClient;
use chrono::Utc;
use uuid::Uuid;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenAnalysis {
    pub id: Uuid,
    pub token_address: String,
    pub sentiment_score: f64,
    pub technical_score: f64,
    pub risk_score: f64,
    pub symbol: String,
    pub description: String,
    pub recent_events: Vec<String>,
    pub market_sentiment: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}
pub struct TokenVectorStore {
    store: PostgresVectorStore,
}
impl TokenVectorStore {
    pub fn new(pool: Pool<Postgres>) -> Self {
        // Initialize OpenAI client for embeddings
        let openai_client = rig_core::providers::openai::Client::from_env();
        let model = openai_client.embedding_model(rig_core::providers::openai::TEXT_EMBEDDING_3_SMALL);
        // Initialize PostgreSQL vector store
        let store = PostgresVectorStore::with_defaults(model, pool);
        Self { store }
    }
    pub async fn add_analysis(&self, analysis: TokenAnalysis, embeddings: Embeddings) -> Result<()> {
        info!("Saving token analysis to vector store");
        self.store.insert_document(&analysis, embeddings.embeddings[0].clone()).await?;
        Ok(())
    }
    pub async fn search_similar(&self, query: &str, limit: usize) -> Result<Vec<TokenAnalysis>> {
        info!("Searching for similar tokens");
        let results = self.store.top_n::<TokenAnalysis>(query, limit).await?;
        info!("Found {} similar tokens", results.len());
        Ok(results.into_iter().map(|(_, _, doc)| doc).collect())
    }
    pub async fn get_analysis(&self, token_address: &str) -> Result<Option<TokenAnalysis>> {
        let query = format!("token_address = '{}'", token_address);
        let results = self.store.find_documents::<TokenAnalysis>(&query).await?;
        Ok(results.into_iter().next())
    }
}
</file>

<file path="agents/trader/src/personality/mod.rs">
use rig_core::agent::Agent;
use rig::completion::{CompletionModel, Prompt};
use anyhow::Result;
use std::collections::HashSet;
use std::time::Duration;
use std::collections::HashMap;
use thiserror::Error;
use crate::market_data::{MarketData, MarketContext};
use solana_sdk::nonce::State;
pub struct StoicPersonality {
    allowed_interactions: HashSet<String>,
    base_prompt: String,
    max_position_size: f64,
    risk_tolerance: f64,
    trade_cooldown: Duration,
    technical_indicators: Vec<String>,
    market_context: HashMap<String, f64>,
    agent: Agent<dyn CompletionModel>,
}
#[derive(Error, Debug)]
pub enum StoicPersonalityError {
    #[error("Risk tolerance exceeded maximum allowed value")]
    RiskToleranceExceeded,
    #[error("Invalid position size: {0}")]
    InvalidPositionSize(f64),
    #[error("Market data incomplete: {0}")]
    IncompleteMarketData(String),
    #[error("LLM response validation failed: {0}")]
    ResponseValidation(String),
}
impl StoicPersonality {
    pub fn new() -> Self {
        Self {
            allowed_interactions: HashSet::new(),
            base_prompt: r#"You are a stoic trading bot. Your responses should reflect stoic principles:
1. Emotional detachment from market movements
2. Focus on rational decision making based on data
3. Acceptance of market conditions
4. Long-term value perspective
5. Risk management emphasis
When tweeting about trades:
1. Always include exact amounts (e.g. "Bought 0.5 SOL worth of $TICKER")
2. Include market cap ("MC: $xxxM")
3. Always include contract address ("CA: address")
4. Always include Solscan transaction link
5. End with a stoic analysis based on actual market indicators:
   - Volume trends
   - Price action
   - Market depth
   - Social sentiment
   - Development activity"#.to_string(),
            max_position_size: 1.0,
            risk_tolerance: 0.2,
            trade_cooldown: Duration::from_secs(300),
            technical_indicators: vec![
                "RSI".into(),
                "MACD".into(),
                "Volume".into()
            ],
            market_context: HashMap::new(),
            agent: Agent::new(rig_core::providers::openai::Client::from_env()),
        }
    }
    pub fn add_allowed_interaction(&mut self, twitter_handle: String) {
        self.allowed_interactions.insert(twitter_handle);
    }
    pub fn is_interaction_allowed(&self, twitter_handle: &str) -> bool {
        self.allowed_interactions.contains(twitter_handle)
    }
    pub async fn generate_trade_tweet<M: CompletionModel>(
        &self,
        agent: &Agent<M>,
        trade_details: &str,
        market_data: &MarketData,
    ) -> Result<String> {
        let prompt = format!(
            r#"{}
Generate a tweet about this trade using the following template:
[BUY/SELL] {:.2} SOL worth of {}
MC: ${:.2}M | Risk: {:.1}% | Vol: {:.2}%
CA: <contract_address>
🔍 https://solscan.io/tx/<tx_id>
Technical Indicators:
{}
Market Context:
{}
[Stoic Analysis]
{}
Trade details:
{}
Requirements:
1. Use exact numbers from the trade details
2. Include all template fields
3. Keep stoic analysis focused on actual market data
4. Stay under 280 characters
5. Use cashtags for token symbols"#,
            self.base_prompt,
            self.max_position_size,
            market_data.market_cap / 1_000_000.0,
            self.risk_tolerance * 100.0,
            market_data.volatility * 100.0,
            self.technical_indicators.join("\n"),
            self.format_market_context(),
            trade_details
        );
        let response = agent.prompt(&prompt).await?;
        Ok(self.postprocess_tweet(response))
    }
    fn postprocess_tweet(&self, tweet: String) -> String {
        let mut processed = tweet.trim().to_string();
        if !processed.contains("#StoicTrading") {
            processed.push_str("\n\n#StoicTrading #Solana #AlgoTrading");
        }
        processed.chars().take(280).collect()
    }
    pub async fn generate_reply<M: CompletionModel>(
        &self,
        agent: &Agent<M>,
        tweet_text: &str,
        author: &str,
        market_context: &MarketContext,
    ) -> Result<Option<String>> {
        if !self.is_interaction_allowed(author) {
            return Ok(None);
        }
        let prompt = format!(
            r#"{}
Respond to this tweet considering current market conditions:
Market Trend: {}
Sector Performance: {:.2}%
Sentiment Score: {:.2}
Tweet to respond to:
{}
Requirements:
1. Only respond if the tweet warrants a response
2. Be helpful but maintain stoic detachment
3. Focus on data-driven insights from these indicators: {}
4. Never give financial advice
5. Stay under 280 characters"#,
            self.base_prompt,
            market_context.market_trend,
            market_context.sector_performance,
            market_context.sentiment_score,
            tweet_text,
            self.technical_indicators.join(", ")
        );
        let response = agent.prompt(&prompt).await?;
        if response.trim().is_empty() || response.to_lowercase().contains("no response") {
            Ok(None)
        } else {
            Ok(Some(response.to_string()))
        }
    }
    pub fn with_max_position_size(mut self, size: f64) -> Self {
        assert!(size > 0.0, "Position size must be positive");
        self.max_position_size = size;
        self
    }
    pub fn with_risk_tolerance(mut self, tolerance: f64) -> Self {
        self.risk_tolerance = tolerance.clamp(0.0, 1.0);
        self
    }
    pub fn with_technical_indicators(mut self, indicators: Vec<String>) -> Self {
        self.technical_indicators = indicators;
        self
    }
    fn format_market_context(&self) -> String {
        self.market_context
            .iter()
            .map(|(k, v)| format!("{}: {:.2}", k, v))
            .collect::<Vec<String>>()
            .join("\n")
    }
    pub async fn analyze_state(&self, state: &solana_sdk::nonce::State) -> Analysis {
        let prompt = format!("{} Analyze market state:\n{}", 
            self.base_prompt,
            state.to_markdown()
        );
        self.agent.prompt(&prompt)
            .await
            .parse()
            .unwrap_or(Analysis::Hold)
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    #[test]
    fn test_personality_defaults() {
        let personality = StoicPersonality::default();
        assert!(personality.base_prompt.contains("stoic"));
        assert!(personality.allowed_interactions.is_empty());
    }
    #[test]
    fn test_allowed_interactions() {
        let mut personality = StoicPersonality::new();
        personality.add_allowed_interaction("vitalik".to_string());
        assert!(personality.is_interaction_allowed("vitalik"));
        assert!(!personality.is_interaction_allowed("random_user"));
    }
    #[test]
    fn test_configuration() {
        let personality = StoicPersonality::new()
            .with_max_position_size(2.5)
            .with_risk_tolerance(0.3)
            .with_technical_indicators(vec!["EMA".into(), "OBV".into()]);
        assert_eq!(personality.max_position_size, 2.5);
        assert_eq!(personality.risk_tolerance, 0.3);
        assert_eq!(personality.technical_indicators, vec!["EMA", "OBV"]);
    }
    #[tokio::test]
    async fn test_tweet_generation() {
        let personality = StoicPersonality::new();
        let mock_agent = Agent::new(MockCompletionModel::default());
        let market_data = MarketData {
            market_cap: 50_000_000.0,
            volatility: 0.15,
            // ... other fields ...
        };
        let tweet = personality
            .generate_trade_tweet(&mock_agent, "Test trade", &market_data)
            .await
            .unwrap();
        assert!(tweet.contains("#StoicTrading"));
        assert!(tweet.len() <= 280);
    }
    #[test]
    fn test_market_context_formatting() {
        let mut personality = StoicPersonality::new();
        personality.market_context.insert("Liquidity".into(), 1.5);
        personality.market_context.insert("Funding Rate".into(), -0.02);
        let formatted = personality.format_market_context();
        assert!(formatted.contains("Liquidity: 1.50"));
        assert!(formatted.contains("Funding Rate: -0.02"));
    }
}
</file>

<file path="agents/trader/src/prediction/mod.rs">
use rig::message_bus::{MessageBus, Message};
use rig_postgres::PostgresVectorStore;
use std::sync::Arc;
use tch::{nn, Device, Tensor};
use crate::models::TokenAnalytics;
use openai::Client;
use anyhow::Result;
struct Transformer {
    model: nn::Sequential,
}
impl Transformer {
    fn new() -> Self {
        let vs = nn::VarStore::new(Device::Cpu);
        let model = nn::seq()
            .add(nn::linear(&vs.root(), 512, 512, Default::default()))
            .add_fn(|xs| xs.relu())
            .add(nn::linear(&vs.root(), 512, 1, Default::default()));
        Self { model }
    }
    fn load(path: &str) -> Self {
        let mut vs = nn::VarStore::new(Device::Cpu);
        let model = nn::seq()
            .add(nn::linear(&vs.root(), 512, 512, Default::default()))
            .add_fn(|xs| xs.relu())
            .add(nn::linear(&vs.root(), 512, 1, Default::default()));
        vs.load(path).unwrap();
        Self { model }
    }
    fn predict(&self, context: &[f32]) -> f32 {
        let input = Tensor::of_slice(context).view([-1, 512]);
        let output = self.model.forward(&input);
        output.double_value(&[0]) as f32
    }
}
pub struct TransformerPredictor {
    message_bus: MessageBus,
    vector_store: Arc<PostgresVectorStore>,
}
impl TransformerPredictor {
    pub fn new(message_bus: MessageBus, vector_store: Arc<PostgresVectorStore>) -> Self {
        Self { message_bus, vector_store }
    }
    async fn train(&self) {
        // Load time-series data from vector store
        let data = self.vector_store.get_embeddings("price_history").await;
        let mut model = Transformer::new();
        let optimizer = tch::nn::Adam::default();
        // Train the model
        for _ in 0..100 {  // epochs
            let loss = model.model.forward(&Tensor::of_slice(&data));
            optimizer.backward_step(&loss);
        }
        model.model.save("weights.bin").unwrap();
    }
    async fn predict(&self, context: &[f32]) -> f32 {
        // Load pre-trained weights
        let mut model = Transformer::load("weights.bin");
        model.predict(context)
    }
}
pub struct PricePredictor {
    message_bus: MessageBus,
    vector_store: Arc<PostgresVectorStore>,
    client: Client,
}
impl PricePredictor {
    pub fn new(message_bus: MessageBus, vector_store: Arc<PostgresVectorStore>, api_key: &str) -> Self {
        Self { 
            message_bus, 
            vector_store,
            client: Client::new(api_key),
        }
    }
    async fn analyze_token(&self, analytics: &TokenAnalytics) -> Result<f32> {
        let prompt = format!(
            "Analyze trading opportunity for token:\n\
            Name: {}\n\
            Address: {}\n\
            Historical data: {:?}\n\
            Predict price movement as a percentage.",
            analytics.token_name,
            analytics.token_address,
            self.vector_store.get_embeddings(&analytics.token_address).await?,
        );
        let response = self.client.chat()
            .create()
            .model("gpt-4o")
            .messages([openai::chat::ChatCompletionMessage {
                role: openai::chat::ChatCompletionMessageRole::User,
                content: Some(prompt),
                name: None,
                function_call: None,
                tool_calls: None,
                tool_call_id: None,
            }])
            .create_async()
            .await?;
        let prediction = response.choices[0].message.content
            .as_ref()
            .and_then(|s| s.parse::<f32>().ok())
            .unwrap_or(0.0);
        Ok(prediction)
    }
}
</file>

<file path="agents/trader/src/storage/schema.rs">
use rig_mongodb::{Document, DateTime, ObjectId};
use serde::{Deserialize, Serialize};
#[derive(Debug, Serialize, Deserialize)]
pub struct AgentData {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub agent_type: String,
    pub vector_embedding: Vec<f32>,
    pub metadata: Document,
    pub timestamp: DateTime,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TradeExecution {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub tx_hash: String,
    pub mint_address: String,
    pub amount: f64,
    pub risk_assessment: f64,
    pub vector_embedding: Vec<f32>,
    pub timestamp: DateTime,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MarketAnalysis {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub market_cap: f64,
    pub liquidity_ratio: f64,
    pub volume_analysis: Document,
    pub vector_embedding: Vec<f32>,
    pub timestamp: DateTime,
}
</file>

<file path="agents/trader/src/strategy/execution.rs">
use crate::market_data::EnhancedTokenMetadata;
use crate::strategy::{TradingDecision, ExecutionParams};
use anyhow::Result;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use tracing::{info, warn, error, debug};
use std::time::{Duration, Instant};
#[derive(Debug)]
pub struct ExecutionEngine {
    max_slippage: f64,
    active_orders: HashMap<String, ActiveOrder>,
    execution_history: Vec<ExecutionRecord>,
    last_execution: Option<Instant>,
    min_execution_interval: Duration,
}
#[derive(Debug, Clone)]
pub struct ActiveOrder {
    pub token_address: String,
    pub order_type: OrderType,
    pub size_in_sol: f64,
    pub entry_price: f64,
    pub stop_loss: f64,
    pub take_profits: Vec<f64>,
    pub filled_amount: f64,
    pub status: OrderStatus,
    pub timestamp: DateTime<Utc>,
}
#[derive(Debug, Clone)]
pub struct ExecutionRecord {
    pub token_address: String,
    pub order_type: OrderType,
    pub size_in_sol: f64,
    pub execution_price: f64,
    pub slippage: f64,
    pub timestamp: DateTime<Utc>,
    pub tx_signature: Option<String>,
}
#[derive(Debug, Clone)]
pub enum OrderType {
    Market,
    Limit,
    StopLoss,
    TakeProfit,
}
#[derive(Debug, Clone)]
pub enum OrderStatus {
    Pending,
    PartiallyFilled(f64),
    Filled,
    Cancelled,
    Failed(String),
}
impl ExecutionEngine {
    pub fn new(max_slippage: f64) -> Self {
        info!("Initializing ExecutionEngine with max_slippage: {}", max_slippage);
        Self {
            max_slippage,
            active_orders: HashMap::new(),
            execution_history: Vec::new(),
            last_execution: None,
            min_execution_interval: Duration::from_secs(300), // 5 minutes between trades
        }
    }
    pub async fn execute_trade(
        &mut self,
        decision: &TradingDecision,
        token: &EnhancedTokenMetadata,
    ) -> Result<ExecutionRecord> {
        // Check execution cooldown
        if let Some(last_exec) = self.last_execution {
            let elapsed = last_exec.elapsed();
            if elapsed < self.min_execution_interval {
                let wait_time = self.min_execution_interval - elapsed;
                warn!("Trade execution cooldown in effect. Must wait {:?} before next trade", wait_time);
                return Err(anyhow::anyhow!("Trade execution cooldown in effect"));
            }
        }
        info!("Executing trade for token: {} ({:?})", token.symbol, decision.action);
        debug!("Trade details - Size: {} SOL, Risk Score: {}", decision.size_in_sol, decision.risk_score);
        // 1. Validate execution parameters
        self.validate_execution_params(&decision.execution_params)
            .map_err(|e| {
                error!("Execution parameter validation failed: {}", e);
                e
            })?;
        // 2. Check for existing orders
        if let Some(active_order) = self.active_orders.get(&decision.token_address) {
            debug!("Found existing order for token: {:?}", active_order);
            self.handle_existing_order(active_order)
                .map_err(|e| {
                    error!("Failed to handle existing order: {}", e);
                    e
                })?;
        }
        // 3. Prepare order parameters
        let order = self.prepare_order(decision, token);
        debug!("Prepared order: {:?}", order);
        // 4. Execute the order
        let execution_record = self.submit_order(order).await
            .map_err(|e| {
                error!("Order submission failed: {}", e);
                e
            })?;
        // 5. Update order tracking
        self.update_order_tracking(&execution_record);
        info!("Trade executed successfully: {:?}", execution_record);
        // Update last execution time
        self.last_execution = Some(Instant::now());
        Ok(execution_record)
    }
    fn validate_execution_params(&self, params: &ExecutionParams) -> Result<()> {
        debug!("Validating execution parameters: {:?}", params);
        // Validate slippage
        if params.max_slippage > self.max_slippage {
            warn!("Slippage {} exceeds maximum allowed {}", params.max_slippage, self.max_slippage);
            return Err(anyhow::anyhow!("Slippage exceeds maximum allowed"));
        }
        // Validate stop loss
        if params.stop_loss <= 0.0 || params.stop_loss > 0.5 {
            warn!("Invalid stop loss percentage: {}", params.stop_loss);
            return Err(anyhow::anyhow!("Invalid stop loss percentage"));
        }
        // Validate take profit levels
        if params.take_profit.is_empty() {
            warn!("No take profit levels specified");
            return Err(anyhow::anyhow!("No take profit levels specified"));
        }
        for (i, tp) in params.take_profit.iter().enumerate() {
            if *tp <= params.stop_loss {
                warn!("Take profit level {} ({}) must be greater than stop loss ({})", i, tp, params.stop_loss);
                return Err(anyhow::anyhow!("Take profit must be greater than stop loss"));
            }
        }
        debug!("Execution parameters validated successfully");
        Ok(())
    }
    fn handle_existing_order(&self, order: &ActiveOrder) -> Result<()> {
        match order.status {
            OrderStatus::Pending | OrderStatus::PartiallyFilled(_) => {
                warn!("Active order exists for token {}: {:?}", order.token_address, order.status);
                Err(anyhow::anyhow!("Active order exists for this token"))
            }
            _ => {
                debug!("No conflicting active order found");
                Ok(())
            }
        }
    }
    fn prepare_order(&self, decision: &TradingDecision, token: &EnhancedTokenMetadata) -> ActiveOrder {
        debug!("Preparing order for token: {}", token.symbol);
        let order = ActiveOrder {
            token_address: decision.token_address.clone(),
            order_type: match decision.execution_params.entry_type.as_str() {
                "Market" => OrderType::Market,
                "Limit" => OrderType::Limit,
                _ => OrderType::Market,
            },
            size_in_sol: decision.size_in_sol,
            entry_price: token.price_sol,
            stop_loss: token.price_sol * (1.0 - decision.execution_params.stop_loss),
            take_profits: decision.execution_params.take_profit.iter()
                .map(|tp| token.price_sol * (1.0 + tp))
                .collect(),
            filled_amount: 0.0,
            status: OrderStatus::Pending,
            timestamp: Utc::now(),
        };
        debug!("Order prepared: {:?}", order);
        order
    }
    async fn submit_order(&self, order: ActiveOrder) -> Result<ExecutionRecord> {
        info!("Submitting order: {:?}", order);
        // TODO: Implement actual order submission through Jupiter DEX
        // For now, simulate a successful market order
        let record = ExecutionRecord {
            token_address: order.token_address,
            order_type: order.order_type,
            size_in_sol: order.size_in_sol,
            execution_price: order.entry_price,
            slippage: 0.001, // 0.1% simulated slippage
            timestamp: Utc::now(),
            tx_signature: Some("simulated_tx_signature".to_string()),
        };
        info!("Order submitted successfully: {:?}", record);
        Ok(record)
    }
    fn update_order_tracking(&mut self, record: &ExecutionRecord) {
        debug!("Updating order tracking for token: {}", record.token_address);
        self.execution_history.push(record.clone());
        self.active_orders.remove(&record.token_address);
        debug!("Order tracking updated. Active orders: {}", self.active_orders.len());
    }
    pub fn get_active_orders(&self) -> &HashMap<String, ActiveOrder> {
        &self.active_orders
    }
    pub fn get_execution_history(&self) -> &Vec<ExecutionRecord> {
        &self.execution_history
    }
}
</file>

<file path="agents/trader/src/strategy/llm.rs">
use crate::market_data::{birdeye::BirdEyeProvider, DataProvider};
use anyhow::Result;
use std::sync::Arc;
use tracing::{debug, instrument};
pub struct LLMStrategy {
    birdeye: Arc<BirdEyeProvider>,
}
#[derive(Debug)]
pub struct TradeData {
    pub price: f64,
    pub volume: f64,
    pub market_cap: f64,
    pub price_change: f64,
}
impl LLMStrategy {
    pub fn new(birdeye: Arc<BirdEyeProvider>) -> Self {
        Self { birdeye }
    }
    #[instrument(skip(self))]
    pub async fn analyze_token(&self, token_address: &str) -> Result<String> {
        debug!("Analyzing token {}", token_address);
        // Get token history and market data
        let token_history = self.birdeye.as_ref().get_historical_prices(token_address).await?;
        let market_data = self.birdeye.as_ref().get_token_metadata(token_address).await?;
        let prompt = format!(
            "Analyze trading opportunity for token {}:\n\nMarket Data:\n{:#?}\n\nHistory:\n{:#?}",
            token_address,
            market_data,
            token_history,
        );
        Ok(prompt)
    }
}
</file>

<file path="agents/trader/src/strategy/mod.rs">
//! Trading Strategy Implementation
//!
//! This module implements the core trading logic using LLM-powered analysis.
//! The strategy combines multiple factors:
//!
//! # Analysis Factors
//! - Market momentum and trends
//! - Volume and liquidity analysis
//! - Price action patterns
//! - Social sentiment and metrics
//! - On-chain activity
//!
//! # Risk Management
//! Configurable parameters (via .env):
//! - `MAX_POSITION_SIZE_SOL`: Maximum position size (default: 1.0 SOL)
//! - `MIN_POSITION_SIZE_SOL`: Minimum position size (default: 0.1 SOL)
//! - `MAX_TOKENS_PER_WALLET`: Maximum concurrent positions
//! - `STOP_LOSS_PERCENTAGE`: Auto stop-loss trigger
//! - `TAKE_PROFIT_PERCENTAGE`: Auto take-profit levels
//! - `MIN_LIQUIDITY_USD`: Minimum liquidity requirement
//! - `MIN_CONFIDENCE_THRESHOLD`: Required confidence for trades
//!
//! # Position Management
//! - Automatic position tracking
//! - Partial profit taking
//! - Dynamic position sizing
//! - Trading cooldown periods
pub mod llm;
pub mod technical;
pub mod risk;
pub mod execution;
use crate::market_data::{EnhancedTokenMetadata, FeatureVector, MacroIndicator};
use anyhow::Result;
use rig::agent::Agent;
use rig::completion::{CompletionModel, Prompt};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::Utc;
use crate::analysis::Analysis;
use solana_sdk::nonce::State;
use uuid::Uuid;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub risk_level: RiskLevel,
    pub parameters: StrategyParameters,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyParameters {
    pub min_market_cap: f64,
    pub min_volume_24h: f64,
    pub min_price_change: f64,
    pub max_price_change: f64,
    pub max_slippage: f64,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    pub id: Uuid,
    pub token_address: String,
    pub signal_type: SignalType,
    pub confidence: f64,
    pub price: f64,
    pub volume: f64,
    pub timestamp: DateTime<Utc>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortfolioPosition {
    pub id: Uuid,
    pub token_address: String,
    pub entry_price: f64,
    pub quantity: f64,
    pub entry_timestamp: DateTime<Utc>,
    pub last_update: DateTime<Utc>,
    pub partial_sells: Vec<PartialSell>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PartialSell {
    pub price: f64,
    pub quantity: f64,
    pub timestamp: DateTime<Utc>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortfolioStats {
    pub total_value_sol: f64,
    pub total_value_usd: f64,
    pub total_realized_pnl_sol: f64,
    pub total_unrealized_pnl_sol: f64,
    pub profitable_positions: i32,
    pub total_positions: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingDecision {
    pub token_address: String,
    pub action: TradeAction,
    pub size_in_sol: f64,
    pub confidence: f64,
    pub reasoning: String,
    pub risk_score: f64,
    pub technical_signals: TechnicalSignals,
    pub market_context: MarketContext,
    pub execution_params: ExecutionParams,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TechnicalSignals {
    pub trend_strength: f64,
    pub momentum_score: f64,
    pub volatility_score: f64,
    pub support_resistance: Vec<f64>,
    pub signal_type: String,
    pub timeframe: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketContext {
    pub market_trend: String,
    pub sector_performance: f64,
    pub liquidity_score: f64,
    pub volume_profile: String,
    pub sentiment_score: f64,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionParams {
    pub entry_type: String,
    pub time_horizon: String,
    pub stop_loss: f64,
    pub take_profit: Vec<f64>,
    pub max_slippage: f64,
    pub dca_config: Option<DCAConfig>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DCAConfig {
    pub num_entries: u32,
    pub time_between_entries: u32,
    pub size_per_entry: f64,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TradeAction {
    Buy,
    Sell,
    Hold
}
pub struct TradingStrategy<M: CompletionModel> {
    agent: Agent<M>,
    risk_manager: risk::RiskManager,
    technical_analyzer: technical::TechnicalAnalyzer,
    execution_engine: execution::ExecutionEngine,
    portfolio: HashMap<String, PortfolioPosition>,
    config: StrategyConfig,
}
impl<M: CompletionModel> TradingStrategy<M> {
    pub fn new(
        agent: Agent<M>,
        config: StrategyConfig,
    ) -> Self {
        Self {
            agent,
            risk_manager: risk::RiskManager::new(
                config.clone(),
                config.parameters.min_market_cap,
            ),
            technical_analyzer: technical::TechnicalAnalyzer::new(),
            execution_engine: execution::ExecutionEngine::new(config.parameters.max_slippage),
            portfolio: HashMap::new(),
            config,
        }
    }
    pub async fn analyze_opportunity(
        &self,
        token: &EnhancedTokenMetadata,
        features: &FeatureVector,
        macro_indicators: &MacroIndicator,
    ) -> Result<TradingDecision> {
        // 1. Technical Analysis
        let technical_signals = self.technical_analyzer.analyze(token).await?;
        // 2. Market Context Analysis
        let market_context = self.analyze_market_context(token, macro_indicators).await?;
        // 3. Risk Assessment
        let risk_score = self.risk_manager.assess_risk(token, &technical_signals, &market_context).await?;
        // 4. LLM-based Analysis
        let llm_analysis = self.perform_llm_analysis(
            token,
            features,
            &technical_signals,
            &market_context,
            risk_score,
        ).await?;
        // 5. Final Decision Making
        let decision = self.make_decision(
            token,
            llm_analysis,
            risk_score,
            &technical_signals,
            &market_context,
        ).await?;
        Ok(decision)
    }
    async fn analyze_market_context(
        &self,
        token: &EnhancedTokenMetadata,
        macro_indicators: &MacroIndicator,
    ) -> Result<MarketContext> {
        Ok(MarketContext {
            market_trend: macro_indicators.market_trend.clone(),
            sector_performance: 0.0, // TODO: Implement sector analysis
            liquidity_score: token.liquidity_usd / token.market_cap,
            volume_profile: if token.volume_change_24h > 50.0 { "High".to_string() } else { "Normal".to_string() },
            sentiment_score: token.social_sentiment.unwrap_or(0.0),
        })
    }
    async fn perform_llm_analysis(
        &self,
        token: &EnhancedTokenMetadata,
        features: &FeatureVector,
        technical_signals: &TechnicalSignals,
        market_context: &MarketContext,
        risk_score: f64,
    ) -> Result<String> {
        let prompt = format!(
            r#"Analyze trading opportunity for token {}.
Technical Signals:
- Trend Strength: {:.2}
- Momentum Score: {:.2}
- Volatility Score: {:.2}
- Signal Type: {}
Market Context:
- Market Trend: {}
- Liquidity Score: {:.2}
- Volume Profile: {}
- Sentiment Score: {:.2}
Risk Score: {:.2}
Additional Metrics:
- Price Change 24h: {:.2}%
- Volume Change 24h: {:.2}%
- Liquidity Change 24h: {:.2}%
Provide trading analysis and recommendation in a concise format."#,
            token.symbol,
            technical_signals.trend_strength,
            technical_signals.momentum_score,
            technical_signals.volatility_score,
            technical_signals.signal_type,
            market_context.market_trend,
            market_context.liquidity_score,
            market_context.volume_profile,
            market_context.sentiment_score,
            risk_score,
            token.price_change_24h,
            token.volume_change_24h,
            token.liquidity_change_24h,
        );
        let response = self.agent.prompt(&prompt).await?;
        Ok(response.to_string())
    }
    async fn make_decision(
        &self,
        token: &EnhancedTokenMetadata,
        llm_analysis: String,
        risk_score: f64,
        technical_signals: &TechnicalSignals,
        market_context: &MarketContext,
    ) -> Result<TradingDecision> {
        let action = if risk_score > 0.7 && technical_signals.trend_strength > 0.6 {
            TradeAction::Buy
        } else if risk_score < 0.3 || technical_signals.trend_strength < 0.2 {
            TradeAction::Sell
        } else {
            TradeAction::Hold
        };
        let size = self.calculate_position_size(risk_score, technical_signals.trend_strength);
        Ok(TradingDecision {
            token_address: token.address.clone(),
            action,
            size_in_sol: size,
            confidence: technical_signals.trend_strength * (1.0 - risk_score),
            reasoning: llm_analysis,
            risk_score,
            technical_signals: technical_signals.clone(),
            market_context: market_context.clone(),
            execution_params: self.generate_execution_params(technical_signals, risk_score),
        })
    }
    fn calculate_position_size(&self, risk_score: f64, trend_strength: f64) -> f64 {
        let base_size = self.config.parameters.max_slippage * 0.2;
        let risk_multiplier = 1.0 - risk_score;
        let trend_multiplier = trend_strength;
        (base_size * risk_multiplier * trend_multiplier)
            .max(self.config.parameters.min_position_sol)
            .min(self.config.parameters.max_slippage)
    }
    fn generate_execution_params(&self, signals: &TechnicalSignals, risk_score: f64) -> ExecutionParams {
        let stop_loss = if risk_score > 0.7 { 0.05 } else { 0.1 };
        let take_profits = vec![0.1, 0.2, 0.3];
        ExecutionParams {
            entry_type: "Market".to_string(),
            time_horizon: signals.timeframe.clone(),
            stop_loss,
            take_profit: take_profits,
            max_slippage: self.config.parameters.max_slippage,
            dca_config: None,
        }
    }
    pub fn update_portfolio(&mut self, token: EnhancedTokenMetadata, quantity: f64, cost_basis_sol: f64) {
        let now = Utc::now().timestamp();
        let token_address = token.address.clone();
        self.portfolio.insert(
            token.address.clone(),
            PortfolioPosition {
                id: Uuid::new_v4(),
                token_address,
                entry_price: cost_basis_sol,
                quantity,
                entry_timestamp: Utc::now(),
                last_update: Utc::now(),
                partial_sells: Vec::new(),
            },
        );
    }
    pub fn record_partial_sell(
        &mut self,
        token_address: &str,
        quantity: f64,
        price_sol: f64,
    ) -> Result<()> {
        let position = self.portfolio.get_mut(token_address)
            .ok_or_else(|| anyhow::anyhow!("Position not found"))?;
        let now = Utc::now().timestamp();
        position.partial_sells.push(PartialSell {
            price: price_sol,
            quantity,
            timestamp: Utc::now(),
        });
        position.quantity -= quantity;
        Ok(())
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use rig::providers::openai;
    #[tokio::test]
    async fn test_trading_strategy() {
        // Add tests with mock agent responses
    }
}
</file>

<file path="agents/trader/src/strategy/pipeline.rs">
use rig::pipeline::{Op, Pipeline, TryOp};
use anyhow::Result;
use crate::{
    market_data::{MarketDataProvider, TokenAnalysis},
    strategy::{TradingStrategy, TradingDecision},
    execution::ExecutionEngine,
};
use tracing::{info, debug};
pub struct MarketAnalysisOp {
    market_data: MarketDataProvider,
}
impl MarketAnalysisOp {
    pub fn new(market_data: MarketDataProvider) -> Self {
        Self { market_data }
    }
}
impl TryOp<String, TokenAnalysis> for MarketAnalysisOp {
    async fn try_run(&self, token_address: String) -> Result<TokenAnalysis> {
        debug!("Running market analysis for token {}", token_address);
        self.market_data.analyze_token(&token_address).await?;
        let analysis = self.market_data.get_token_analysis(&token_address).await?
            .ok_or_else(|| anyhow::anyhow!("No analysis found for token"))?;
        Ok(analysis)
    }
}
pub struct StrategyOp {
    strategy: TradingStrategy,
}
impl StrategyOp {
    pub fn new(strategy: TradingStrategy) -> Self {
        Self { strategy }
    }
}
impl TryOp<TokenAnalysis, TradingDecision> for StrategyOp {
    async fn try_run(&self, analysis: TokenAnalysis) -> Result<TradingDecision> {
        debug!("Generating trading decision for token {}", analysis.symbol);
        self.strategy.generate_decision(&analysis).await
    }
}
pub struct ExecutionOp {
    engine: ExecutionEngine,
}
impl ExecutionOp {
    pub fn new(engine: ExecutionEngine) -> Self {
        Self { engine }
    }
}
impl TryOp<TradingDecision, String> for ExecutionOp {
    async fn try_run(&self, decision: TradingDecision) -> Result<String> {
        debug!("Executing trading decision: {:?}", decision);
        let record = self.engine.execute_trade(&decision).await?;
        Ok(record.tx_signature.unwrap_or_default())
    }
}
pub struct TradingPipeline {
    pipeline: Pipeline<String, String>,
}
impl TradingPipeline {
    pub fn new(market_data: MarketDataProvider, strategy: TradingStrategy, execution: ExecutionEngine) -> Self {
        let pipeline = Pipeline::new()
            .add_try_op(MarketAnalysisOp::new(market_data))
            .add_try_op(StrategyOp::new(strategy))
            .add_try_op(ExecutionOp::new(execution));
        Self { pipeline }
    }
    pub async fn execute_trade(&self, token_address: String) -> Result<String> {
        info!("Starting trading pipeline for token {}", token_address);
        self.pipeline.try_run(token_address).await
    }
}
</file>

<file path="agents/trader/src/strategy/risk.rs">
use crate::market_data::EnhancedTokenMetadata;
use crate::strategy::{TechnicalSignals, MarketContext, StrategyConfig};
use anyhow::Result;
use rig_solana_trader::personality::StoicPersonality;
#[derive(Debug)]
pub struct RiskManager {
    config: StrategyConfig,
    max_position_per_token: f64,
    max_drawdown: f64,
    min_liquidity_ratio: f64,
    personality: StoicPersonality,
}
impl RiskManager {
    pub fn new(config: StrategyConfig, personality: StoicPersonality) -> Self {
        Self {
            config,
            max_position_per_token: 0.2, // 20% of portfolio per token
            max_drawdown: 0.2,
            min_liquidity_ratio: 0.1, // Minimum liquidity to market cap ratio
            personality,
        }
    }
    pub async fn assess_risk(
        &self,
        token: &EnhancedTokenMetadata,
        technical: &TechnicalSignals,
        market: &MarketContext,
    ) -> Result<f64> {
        let mut risk_score = 0.0;
        let mut weight_sum = 0.0;
        // 1. Liquidity Risk (0.0 = high risk, 1.0 = low risk)
        let liquidity_risk = self.assess_liquidity_risk(token);
        risk_score += liquidity_risk * 0.3;
        weight_sum += 0.3;
        // 2. Volatility Risk
        let volatility_risk = 1.0 - technical.volatility_score;
        risk_score += volatility_risk * 0.2;
        weight_sum += 0.2;
        // 3. Market Risk
        let market_risk = self.assess_market_risk(market);
        risk_score += market_risk * 0.15;
        weight_sum += 0.15;
        // 4. Technical Risk
        let technical_risk = self.assess_technical_risk(technical);
        risk_score += technical_risk * 0.2;
        weight_sum += 0.2;
        // 5. Social/Sentiment Risk
        let sentiment_risk = self.assess_sentiment_risk(token, market);
        risk_score += sentiment_risk * 0.15;
        weight_sum += 0.15;
        // Normalize risk score to 0-1 range (0 = highest risk, 1 = lowest risk)
        Ok(risk_score / weight_sum)
    }
    fn assess_liquidity_risk(&self, token: &EnhancedTokenMetadata) -> f64 {
        let mut risk_score = 0.0;
        // Liquidity to market cap ratio
        let liquidity_ratio = token.liquidity_usd / token.market_cap;
        if liquidity_ratio >= self.min_liquidity_ratio {
            risk_score += 0.4;
        }
        // Volume analysis
        let volume_to_mcap = token.volume_24h / token.market_cap;
        risk_score += (volume_to_mcap * 5.0).min(0.3); // Cap at 0.3
        // Liquidity change trend
        if token.liquidity_change_24h > 0.0 {
            risk_score += 0.2;
        }
        // Minimum thresholds
        if token.liquidity_usd < self.config.min_liquidity_usd {
            return 0.0; // Immediate rejection if below minimum liquidity
        }
        risk_score.min(1.0)
    }
    fn assess_market_risk(&self, market: &MarketContext) -> f64 {
        let mut risk_score = 0.5; // Start neutral
        // Market trend analysis
        match market.market_trend.as_str() {
            "Bullish" => risk_score += 0.2,
            "Bearish" => risk_score -= 0.2,
            _ => {} // Neutral
        }
        // Sector performance
        if market.sector_performance > 0.0 {
            risk_score += 0.1;
        } else {
            risk_score -= 0.1;
        }
        // Volume profile
        if market.volume_profile == "High" {
            risk_score += 0.1;
        }
        risk_score.max(0.0).min(1.0)
    }
    fn assess_technical_risk(&self, technical: &TechnicalSignals) -> f64 {
        let mut risk_score = 0.0;
        // Trend strength
        risk_score += technical.trend_strength * 0.4;
        // Momentum
        risk_score += technical.momentum_score * 0.3;
        // Signal type analysis
        match technical.signal_type.as_str() {
            "Strong Uptrend" => risk_score += 0.2,
            "Strong Downtrend" => risk_score -= 0.1,
            "High Volatility" => risk_score -= 0.2,
            "Ranging" => risk_score += 0.1,
            _ => {}
        }
        risk_score.max(0.0).min(1.0)
    }
    fn assess_sentiment_risk(&self, token: &EnhancedTokenMetadata, market: &MarketContext) -> f64 {
        let mut risk_score = 0.5; // Start neutral
        // Social sentiment
        if let Some(sentiment) = token.social_sentiment {
            risk_score += (sentiment - 0.5) * 0.3;
        }
        // Social volume
        if let Some(volume) = token.social_volume {
            if volume > 1000 {
                risk_score += 0.1;
            }
        }
        // Development activity
        if let Some(dev_activity) = token.dev_activity {
            if dev_activity > 0 {
                risk_score += 0.1;
            }
        }
        // Market sentiment correlation
        risk_score += (market.sentiment_score - 0.5) * 0.2;
        risk_score.max(0.0).min(1.0)
    }
    pub fn validate_position_size(&self, size_in_sol: f64, current_portfolio_value: f64) -> bool {
        // Check if position size is within limits
        if size_in_sol < self.config.min_position_sol || size_in_sol > self.config.max_position_sol {
            return false;
        }
        // Check position size relative to portfolio
        let position_ratio = size_in_sol / current_portfolio_value;
        if position_ratio > self.max_position_per_token {
            return false;
        }
        true
    }
    pub fn validate_trade(&self, action: &TradeAction) -> Result<()> {
        let risk_score = self.calculate_risk_score(action);
        if risk_score > self.personality.risk_tolerance {
            return Err(anyhow::anyhow!(
                "Risk score {} exceeds tolerance {}",
                risk_score,
                self.personality.risk_tolerance
            ));
        }
        Ok(())
    }
    fn calculate_risk_score(&self, action: &TradeAction) -> f64 {
        let market_risk = action.analysis.as_ref().map(|a| a.risk_assessment).unwrap_or(1.0);
        let position_risk = action.params.amount / self.personality.max_position_size;
        market_risk * position_risk
    }
}
</file>

<file path="agents/trader/src/strategy/technical.rs">
use crate::market_data::EnhancedTokenMetadata;
use anyhow::Result;
use serde::{Deserialize, Serialize};
#[derive(Debug)]
pub struct TechnicalAnalyzer {
    rsi_period: u32,
    macd_fast: u32,
    macd_slow: u32,
    macd_signal: u32,
    bb_period: u32,
    bb_std_dev: f64,
}
impl TechnicalAnalyzer {
    pub fn new() -> Self {
        Self {
            rsi_period: 14,
            macd_fast: 12,
            macd_slow: 26,
            macd_signal: 9,
            bb_period: 20,
            bb_std_dev: 2.0,
        }
    }
    pub async fn analyze(&self, token: &EnhancedTokenMetadata) -> Result<super::TechnicalSignals> {
        let trend_strength = self.calculate_trend_strength(token);
        let momentum_score = self.calculate_momentum_score(token);
        let volatility_score = self.calculate_volatility_score(token);
        let support_resistance = self.identify_support_resistance(token);
        let signal_type = self.determine_signal_type(
            trend_strength,
            momentum_score,
            volatility_score,
            token,
        );
        Ok(super::TechnicalSignals {
            trend_strength,
            momentum_score,
            volatility_score,
            support_resistance,
            signal_type,
            timeframe: "4h".to_string(), // Default timeframe
        })
    }
    fn calculate_trend_strength(&self, token: &EnhancedTokenMetadata) -> f64 {
        let price_weight = if token.price_change_24h > 0.0 { 0.6 } else { 0.4 };
        let volume_weight = if token.volume_change_24h > 0.0 { 0.7 } else { 0.3 };
        let price_score = (token.price_change_24h / 100.0).min(1.0).max(-1.0);
        let volume_score = (token.volume_change_24h / 200.0).min(1.0).max(-1.0);
        let trend_score = (price_score * price_weight + volume_score * volume_weight).abs();
        if let Some(rsi) = token.rsi_14 {
            let rsi_score = if rsi > 70.0 {
                (100.0 - rsi) / 30.0
            } else if rsi < 30.0 {
                rsi / 30.0
            } else {
                0.5 + (rsi - 50.0) / 40.0
            };
            (trend_score + rsi_score) / 2.0
        } else {
            trend_score
        }
    }
    fn calculate_momentum_score(&self, token: &EnhancedTokenMetadata) -> f64 {
        let mut score = 0.0;
        let mut signals = 0;
        // RSI Signal
        if let Some(rsi) = token.rsi_14 {
            score += if rsi > 70.0 {
                1.0
            } else if rsi < 30.0 {
                -1.0
            } else {
                0.0
            };
            signals += 1;
        }
        // MACD Signal
        if let (Some(macd), Some(signal)) = (token.macd, token.macd_signal) {
            score += if macd > signal {
                1.0
            } else {
                -1.0
            };
            signals += 1;
        }
        // Price momentum
        let price_momentum = token.price_change_24h / 100.0;
        score += price_momentum.signum();
        signals += 1;
        // Volume momentum
        let volume_momentum = token.volume_change_24h / 100.0;
        score += volume_momentum.signum();
        signals += 1;
        if signals > 0 {
            (score / signals as f64 + 1.0) / 2.0 // Normalize to 0-1
        } else {
            0.5 // Neutral if no signals
        }
    }
    fn calculate_volatility_score(&self, token: &EnhancedTokenMetadata) -> f64 {
        let mut volatility = 0.0;
        // Bollinger Bands volatility
        if let (Some(upper), Some(lower)) = (token.bollinger_upper, token.bollinger_lower) {
            let current_price = token.price_usd;
            let band_width = (upper - lower) / current_price;
            volatility += band_width;
        }
        // Price change volatility
        let price_volatility = token.price_change_24h.abs() / 100.0;
        volatility += price_volatility;
        // Volume volatility
        let volume_volatility = token.volume_change_24h.abs() / 100.0;
        volatility += volume_volatility;
        // Normalize to 0-1 range
        (volatility / 3.0).min(1.0)
    }
    fn identify_support_resistance(&self, token: &EnhancedTokenMetadata) -> Vec<f64> {
        // This is a simplified implementation
        // In a real system, this would analyze historical price data
        vec![
            token.price_usd * 0.9,  // Support level
            token.price_usd * 1.1   // Resistance level
        ]
    }
    fn determine_signal_type(
        &self,
        trend_strength: f64,
        momentum_score: f64,
        volatility_score: f64,
        token: &EnhancedTokenMetadata,
    ) -> String {
        if trend_strength > 0.7 && momentum_score > 0.7 {
            if token.price_change_24h > 0.0 {
                "Strong Uptrend".to_string()
            } else {
                "Strong Downtrend".to_string()
            }
        } else if volatility_score > 0.8 {
            "High Volatility".to_string()
        } else if trend_strength < 0.3 {
            "Ranging".to_string()
        } else {
            "Mixed Signals".to_string()
        }
    }
}
</file>

<file path="agents/trader/src/twitter/mod.rs">
use anyhow::Result;
use reqwest::{Client, header};
use serde_json::Value;
use std::sync::Arc;
use tokio::sync::Mutex;
pub struct TwitterClient {
    client: Client,
    username: String,
    cookies: String,
    last_tweet_time: Arc<Mutex<i64>>,
}
impl TwitterClient {
    pub fn new(username: String, cookies: String) -> Result<Self> {
        let mut headers = header::HeaderMap::new();
        headers.insert(
            header::COOKIE,
            header::HeaderValue::from_str(&cookies)?,
        );
        let client = Client::builder()
            .default_headers(headers)
            .build()?;
        Ok(Self {
            client,
            username,
            cookies,
            last_tweet_time: Arc::new(Mutex::new(0)),
        })
    }
    pub async fn post_tweet(&self, text: &str) -> Result<String> {
        let json = serde_json::json!({
            "text": text,
        });
        let response = self.client
            .post("https://api.twitter.com/2/tweets")
            .json(&json)
            .send()
            .await?
            .json::<Value>()
            .await?;
        Ok(response["data"]["id"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Failed to get tweet ID"))?
            .to_string())
    }
    pub async fn reply_to_tweet(&self, reply_to_id: &str, text: &str) -> Result<String> {
        let json = serde_json::json!({
            "text": text,
            "reply": {
                "in_reply_to_tweet_id": reply_to_id
            }
        });
        let response = self.client
            .post("https://api.twitter.com/2/tweets")
            .json(&json)
            .send()
            .await?
            .json::<Value>()
            .await?;
        Ok(response["data"]["id"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Failed to get tweet ID"))?
            .to_string())
    }
}
</file>

<file path="agents/trader/src/analysis.rs">
#[derive(Debug, Clone, PartialEq)]
pub enum Analysis {
    Buy,
    Sell,
    Hold
}
</file>

<file path="agents/trader/src/lib.rs">
//! Solana Trading Bot
//!
//! This crate provides a framework for building automated trading bots on Solana.
//! It includes:
//!
//! - Market data collection and analysis
//! - Trading strategy implementation
//! - Risk management
//! - Trade execution via Jupiter
//! - Twitter integration for trade announcements
//! - PostgreSQL persistence for market data and positions
//!
//! # Architecture
//!
//! The bot is organized into several key modules:
//!
//! - `market_data`: Handles market data collection and analysis
//! - `strategy`: Implements trading strategies
//! - `execution`: Manages trade execution
//! - `database`: Handles PostgreSQL persistence
//! - `twitter`: Twitter API integration
//!
//! # Example Usage
//!
//! ```no_run
//! use rig_solana_trader::{TradingBot, Config};
//! use std::env;
//!
//! #[tokio::main]
//! async fn main() -> anyhow::Result<()> {
//!     // Load configuration
//!     let config = Config::from_env()?;
//!
//!     // Create and start bot
//!     let mut bot = TradingBot::new(config).await?;
//!     bot.run().await?;
//!
//!     Ok(())
//! }
//! ```
use rig_core::{
    agent::{Agent, AgentSystem},
    message_bus::MessageBus,
};
use rig_postgres::PostgresVectorStore;
use sqlx::postgres::PgPoolOptions;
use std::sync::Arc;
use std::env;
use std::time::Duration;
use tracing::{debug, info};
pub mod agents;
pub mod analysis;
pub mod database;
pub mod decision;
pub mod dex;
pub mod execution;
pub mod integrations;
pub mod market_data;
pub mod personality;
pub mod prediction;
pub mod state;
pub mod storage;
pub mod strategy;
pub mod twitter;
pub mod wallet;
/// Initialize the trading bot with the given configuration
pub async fn init_bot(
    database_url: &str,
    openai_api_key: &str,
    twitter_api_key: &str,
) -> anyhow::Result<()> {
    // Initialize PostgreSQL connection
    let pool = PgPoolOptions::new()
        .max_connections(50)
        .idle_timeout(Duration::from_secs(5))
        .connect(database_url)
        .await
        .map_err(|e| {
            debug!("PostgreSQL connection error: {:?}", e);
            anyhow::anyhow!("Failed to connect to PostgreSQL")
        })?;
    info!("PostgreSQL connection established");
    // Initialize OpenAI client for embeddings
    let openai_client = rig_core::providers::openai::Client::from_env();
    let model = openai_client.embedding_model(rig_core::providers::openai::TEXT_EMBEDDING_3_SMALL);
    // Initialize vector store
    let vector_store = PostgresVectorStore::with_defaults(model, pool);
    // Initialize message bus
    let message_bus = MessageBus::new();
    // Initialize personality
    let personality = Arc::new(personality::StoicPersonality::new());
    // Create agent system
    let mut agent_system = AgentSystem::new()
        .with_retry_policy(3, Duration::from_secs(10))
        .with_health_check_interval(Duration::from_secs(30));
    // Add agents
    agent_system
        .add_agent(agents::DataIngestionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(agents::PredictionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(agents::DecisionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(agents::ExecutionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(agents::TwitterAgent::new(
            message_bus.clone(),
            personality.clone(),
        ));
    // Start all agents
    agent_system.run().await?;
    Ok(())
}
/// Example usage
pub async fn example() -> anyhow::Result<()> {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL not set");
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let twitter_api_key = env::var("TWITTER_API_KEY").expect("TWITTER_API_KEY not set");
    init_bot(
        &database_url,
        &openai_api_key,
        &twitter_api_key,
    ).await?;
    Ok(())
}
</file>

<file path="agents/trader/src/main.rs">
use rig_core::{
    agent::{Agent, AgentSystem},
    message_bus::MessageBus,
};
use rig_postgres::PostgresVectorStore;
use sqlx::postgres::PgPoolOptions;
use rig_solana_trader::{
    agents::{DataIngestionAgent, DecisionAgent, ExecutionAgent, PredictionAgent, TwitterAgent},
    personality::StoicPersonality,
};
use std::sync::Arc;
use std::env;
use std::time::Duration;
mod data_ingestion;
mod prediction;
mod decision;
mod execution;
mod feedback;
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize shared components
    let message_bus = MessageBus::new();
    let personality = Arc::new(StoicPersonality::new());
    // Configure PostgreSQL connection pool
    let database_url = env::var("DATABASE_URL")?;
    let pool = PgPoolOptions::new()
        .max_connections(50)
        .idle_timeout(Duration::from_secs(5))
        .connect(&database_url)
        .await?;
    // Initialize OpenAI client for embeddings
    let openai_client = rig_core::providers::openai::Client::from_env();
    let model = openai_client.embedding_model(rig_core::providers::openai::TEXT_EMBEDDING_3_SMALL);
    // Initialize PostgreSQL vector store
    let vector_store = PostgresVectorStore::with_defaults(model, pool);
    // Create agent system
    let mut agent_system = AgentSystem::new()
        .with_retry_policy(3, Duration::from_secs(10))
        .with_health_check_interval(Duration::from_secs(30));
    // Add agents with their dependencies
    agent_system
        .add_agent(DataIngestionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(PredictionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(DecisionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(ExecutionAgent::new(
            message_bus.clone(),
            vector_store.clone(),
            personality.clone(),
        ))
        .add_agent(TwitterAgent::new(
            message_bus.clone(),
            personality.clone(),
        ));
    // Start all agents
    agent_system.run().await?;
    Ok(())
}
async fn trading_loop(
    executor: Arc<SolanaExecutor>,
    risk_manager: Arc<RiskManager>,
    twitter: Arc<TwitterClient>,
) -> Result<()> {
    let market_client = MarketDataClient::new(env::var("PUMPFUN_API_KEY")?);
    loop {
        let token_data = market_client.get_token_data("TOKEN_MINT").await?;
        let analysis = TradeAnalysis {
            market_cap: token_data.current_market_cap,
            volume_ratio: token_data.buy_volume_4h / token_data.sell_volume_4h,
            risk_assessment: market_client.analyze_market(&token_data),
        };
        let action = TradeAction {
            action_type: TradeType::Buy,
            params: TradeParams {
                mint: "TOKEN_MINT".into(),
                amount: 0.1,
                slippage: 10,
                units: 1_000_000,
            },
            analysis: Some(analysis),
        };
        risk_manager.validate_trade(&action)?;
        let signature = executor.execute_trade(action.clone()).await?;
        twitter.post_trade(&action, &signature.to_string()).await?;
        tokio::time::sleep(Duration::from_secs(300)).await;
    }
}
</file>

<file path="agents/trader/src/market_data.rs">
#[derive(Debug, Clone)]
pub struct MarketData {
    pub market_cap: f64,
    pub volatility: f64,
    pub volume_24h: f64,
    pub price: f64,
}
#[derive(Debug, Clone)]
pub struct MarketContext {
    pub market_trend: String,
    pub sector_performance: f64,
    pub sentiment_score: f64,
}
</file>

<file path="agents/trader/src/state.rs">
use solana_sdk::{
    account_info::AccountInfo,
    nonce::State
};
pub struct State<'a> {
    pub account: AccountInfo<'a>,
    // Add other state fields
}
impl<'a> State<'a> {
    pub fn new(account: AccountInfo<'a>) -> Self {
        Self { account }
    }
}
</file>

<file path="agents/trader/src/twitter.rs">
impl TwitterClient {
    pub fn new() -> Self {
        TwitterClient {
            api_key: std::env::var("TWITTER_API_KEY").unwrap(),
            api_secret: std::env::var("TWITTER_API_SECRET").unwrap(),
            access_token: std::env::var("TWITTER_ACCESS_TOKEN").unwrap(),
            access_secret: std::env::var("TWITTER_ACCESS_SECRET").unwrap(),
        }
    }
}
</file>

<file path="agents/trader/src/wallet.rs">
use solana_sdk::{
    pubkey::Pubkey,
    signature::{Keypair, ParseKeypairError},
};
use std::str::FromStr;
pub fn load_wallet() -> Result<Keypair, ParseKeypairError> {
    let private_key = std::env::var("PRIVATE_KEY")
        .expect("PRIVATE_KEY must be set in .env");
    Keypair::from_base58_string(&private_key)
}
pub fn get_public_key(keypair: &Keypair) -> Pubkey {
    keypair.pubkey()
}
pub fn load_keypair() -> Keypair {
    Keypair::new() // Use proper keypair loading in production
}
</file>

<file path="agents/trader/Cargo.toml">
[package]
name = "cainam-trader"
version = "0.1.0"
edition = "2021"

[dependencies]
# Framework
rig = { version = "0.8.0", features = ["openai", "mongodb", "solana"] }
rig-core = "0.8.0"
rig-mongodb = "0.2.4"
rig-postgres = "0.2.4"
rig-solana-trader = "0.1.0"

# Core dependencies
tokio = { version = "1.38.0", features = ["full"] }
anyhow = "1.0"
thiserror = "1.0"
async-trait = "0.1"
futures = "0.3"

# Database
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "chrono"] }

# Machine Learning
tch = "0.14"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
borsh = "0.10"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "chrono", "time"] }

# Time handling
chrono = { version = "0.4", features = ["serde"] }

# Environment
dotenvy = "0.15.7"

# HTTP client
reqwest = { version = "0.11", features = ["json"] }

# Utilities
uuid = { version = "1.0", features = ["v4", "serde"] }
base64 = "0.21"
rand = "0.8"

# Solana
solana-sdk = { version = "1.14.18", features = ["full"] }
solana-client = "1.14.18"
solana-program = "1.14.18"
spl-token = "3.5.0"
anchor-client = "0.26.0"
anchor-lang = "0.26.0"
anchor-spl = "0.26.0"

# CLI
rustyline = "12.0"

# Jupiter DEX
jup-ag = "0.8"

# Technical Analysis
ta = "0.5"

# Social media integration
twitter-v2 = "0.1"
oauth2 = "4.4"
oauth1 = "1.0"

# OpenAI
openai = { version = "1.0.0-alpha.18" }

[dev-dependencies]
tokio-test = "0.4"
</file>

<file path="agents/trader/docker-compose.yml">
version: "3.8"
services:
  postgres:
    image: ankane/pgvector:latest
    environment:
      POSTGRES_USER: mgunnin
      POSTGRES_PASSWORD: password
      POSTGRES_DB: cainam_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  trader:
    build: .
    environment:
      - DATABASE_URL=postgresql://mgunnin:password@postgres:5432/cainam_db
    depends_on:
      - postgres
    volumes:
      - .:/app
volumes:
  postgres_data:
</file>

<file path="docs/examples/advanced_pid_controller_tuner_example/src/main.rs">
use rig::providers::openai;
use rig::completion::Prompt;
use serde::{Deserialize, Serialize};
use std::error::Error;
use plotters::prelude::*;
// System simulation
struct System {
    position: f64,
    velocity: f64,
}
impl System {
    fn new() -> Self {
        System {
            position: 0.0,
            velocity: 0.0,
        }
    }
    fn update(&mut self, force: f64, dt: f64) {
        let acceleration = force - 0.1 * self.velocity - 2.0 * self.position;
        self.velocity += acceleration * dt;
        self.position += self.velocity * dt;
    }
}
// PID Controller
struct PIDController {
    kp: f64,
    ki: f64,
    kd: f64,
    integral: f64,
    prev_error: f64,
}
impl PIDController {
    fn new(kp: f64, ki: f64, kd: f64) -> Self {
        PIDController {
            kp,
            ki,
            kd,
            integral: 0.0,
            prev_error: 0.0,
        }
    }
    fn calculate(&mut self, setpoint: f64, current_value: f64, dt: f64) -> f64 {
        let error = setpoint - current_value;
        self.integral += error * dt;
        let derivative = (error - self.prev_error) / dt;
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;
        self.prev_error = error;
        output
    }
}
// Performance metrics calculation
fn calculate_performance_metrics(response: &[f64], setpoint: f64, dt: f64) -> (f64, f64, f64) {
    let steady_state_error = (response.last().unwrap() - setpoint).abs();
    let mut max_overshoot = 0.0;
    for &value in response.iter() {
        let overshoot = (value - setpoint).abs();
        if overshoot > max_overshoot {
            max_overshoot = overshoot;
        }
    }
    let settling_time = response.len() as f64 * dt;  // Simplified
    (settling_time, max_overshoot, steady_state_error)
}
#[derive(Debug, Serialize, Deserialize)]
struct PIDParams {
    kp: f64,
    ki: f64,
    kd: f64,
}
fn generate_chart(
    responses: &[Vec<f64>],
    iteration: usize,
    pid_params: &[PIDParams],
    file_name: &str,
) -> Result<(), Box<dyn Error>> {
    let root = BitMapBackend::new(file_name, (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;
    let mut chart = ChartBuilder::on(&root)
        .caption(format!("System Response - Iteration {}", iteration), ("sans-serif", 30).into_font())
        .margin(5)
        .x_label_area_size(30)
        .y_label_area_size(30)
        .build_cartesian_2d(0f32..10f32, -0.5f32..1.5f32)?;
    chart.configure_mesh().draw()?;
    let colors = [RED, BLUE, GREEN, CYAN, MAGENTA, YELLOW];
    for (i, response) in responses.iter().enumerate() {
        let color = colors[i % colors.len()];
        chart.draw_series(LineSeries::new(
            response.iter().enumerate().map(|(x, y)| (x as f32 / 100.0, *y as f32)),
            color,
        ))?
        .label(format!("Iteration {} (Kp={:.2}, Ki={:.2}, Kd={:.2})",
                       i, pid_params[i].kp, pid_params[i].ki, pid_params[i].kd))
        .legend(move |(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], color));
    }
    chart.configure_series_labels()
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()?;
    root.present()?;
    Ok(())
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let openai_client = openai::Client::from_env();
    let ai_tuner = openai_client.model("gpt-4o").build();
    let mut all_responses = Vec::new();
    let mut all_pid_params = Vec::new();
    let setpoint = 1.0;
    let dt = 0.01;
    let simulation_steps = 1000;
    let mut pid = PIDController::new(1.0, 0.1, 0.05);  // Initial parameters
    all_pid_params.push(PIDParams { kp: pid.kp, ki: pid.ki, kd: pid.kd });
    for iteration in 0..20 {  // Reduced to 5 iterations for brevity
        let mut system = System::new();
        let mut response = Vec::new();
        // Run simulation
        for _ in 0..simulation_steps {
            let control_signal = pid.calculate(setpoint, system.position, dt);
            system.update(control_signal, dt);
            response.push(system.position);
        }
        all_responses.push(response.clone());
        let (settling_time, max_overshoot, steady_state_error) = 
            calculate_performance_metrics(&response, setpoint, dt);
        println!("Iteration {}: ST = {:.2}, MO = {:.2}, SSE = {:.4}", 
                 iteration, settling_time, max_overshoot, steady_state_error);
        // Generate chart for this iteration
        generate_chart(&all_responses, iteration, &all_pid_params, 
                       &format!("system_response_iteration_{}.png", iteration))?;
        // Ask AI to suggest new PID parameters
        let prompt = format!(
            "Current PID parameters: Kp = {:.2}, Ki = {:.2}, Kd = {:.2}\n\
            Performance metrics:\n\
            Settling Time: {:.2}\n\
            Max Overshoot: {:.2}\n\
            Steady State Error: {:.4}\n\
            Suggest new PID parameters to improve performance. \
            Respond with a JSON object containing 'kp', 'ki', and 'kd' fields.",
            pid.kp, pid.ki, pid.kd, settling_time, max_overshoot, steady_state_error
        );
        let ai_response = ai_tuner.prompt(&prompt).await?;
        let new_params: PIDParams = serde_json::from_str(&ai_response)?;
        // Update PID parameters
        pid = PIDController::new(new_params.kp, new_params.ki, new_params.kd);
        all_pid_params.push(new_params);
    }
    // Generate final overlay chart
    generate_chart(&all_responses, all_responses.len() - 1, &all_pid_params, "system_response_overlay.png")?;
    Ok(())
}
</file>

<file path="docs/examples/advanced_pid_controller_tuner_example/Cargo.toml">
[package]
name = "advanced_pid_controller_tuner_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
plotters = "0.3"
</file>

<file path="docs/examples/advanced_pid_controller_tuner_example/README.md">
# Adaptive PID Controller Tuner with Charts using [Rig](https://github.com/0xPlaygrounds/rig)

This project demonstrates how to leverage [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to create an AI agent that tunes a PID controller. We've enhanced this example with visual feedback, allowing you to see the impact of AI-suggested tuning in real-time. Whether you're new to control systems or looking to explore AI-enhanced engineering applications, this example provides an excellent starting point.

### What is a PID Controller?

Before we dive in, let's explain what a PID controller is:

A PID (Proportional-Integral-Derivative) controller is a control loop mechanism widely used in industrial systems. It continuously calculates an error value as the difference between a desired setpoint and a measured process variable and applies a correction based on proportional, integral, and derivative terms.

Imagine you're trying to maintain a constant water level in a tank:
- The Proportional term (P) is like how quickly you open or close the tap based on how far the water level is from your target.
- The Integral term (I) is like your memory of past errors, helping you make fine adjustments if the level has been consistently off.
- The Derivative term (D) is like your anticipation of future changes based on how quickly the water level is changing.

Tuning these three parameters (Kp, Ki, Kd) is crucial for optimal system performance, which is where our AI comes in!

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-pid-tuner-charts
   cd rig-pid-tuner-charts
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   tokio = { version = "1.0", features = ["full"] }
   plotters = "0.3"
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. `System`: A struct simulating a simple second-order system.
2. `PIDController`: A struct implementing a basic PID controller.
3. Performance metric calculations (settling time, overshoot, steady-state error).
4. An AI agent using Rig to suggest PID parameter improvements.
5. A charting function to visualize system responses.
6. A main loop simulating the system, allowing the AI to tune the controller, and generating charts.

### Running the Example

1. Copy the provided code into your `src/main.rs` file.
2. Run the example using:
   ```
   cargo run
   ```
3. After running, you'll find PNG images in your project directory showing the system responses for each iteration and a final overlay chart.

### Understanding the Code

Let's break down the key parts of the code:

1. **System Simulation**: 
   We simulate a simple second-order system. Think of this as a simplified model of a physical system, like a spring-mass-damper system.

   ```rust
   struct System {
       position: f64,
       velocity: f64,
   }
   ```

2. **PID Controller**:
   This struct implements the PID control algorithm. It calculates the control output based on the error between the setpoint and the current value.

   ```rust
   struct PIDController {
       kp: f64,
       ki: f64,
       kd: f64,
       integral: f64,
       prev_error: f64,
   }
   ```

3. **Performance Metrics**:
   We calculate three key metrics:
   - Settling Time: How long it takes for the system to reach and stay within a certain range of the setpoint.
   - Max Overshoot: The maximum amount the system exceeds the setpoint.
   - Steady-State Error: The final difference between the system's output and the setpoint.

4. **AI Tuner**:
   We use Rig to create an AI agent that suggests improvements to the PID parameters based on the current performance metrics.

   ```rust
   let ai_tuner = openai_client.model("gpt-4o").build();
   ```

5. **Charting Function**:
   We use the `plotters` library to generate visual representations of our system's response. This function creates charts for each iteration and a final overlay chart.

   ```rust
   fn generate_chart(
       responses: &[Vec<f64>],
       iteration: usize,
       pid_params: &[PIDParams],
       file_name: &str,
   ) -> Result<(), Box<dyn Error>> {
       // ... (chart generation code)
   }
   ```

6. **Main Loop**:
   In the main function, we run multiple iterations of:
   - Simulating the system
   - Calculating performance metrics
   - Generating a chart of the system response
   - Using the AI to suggest new PID parameters
   - Updating the controller with the new parameters

   After all iterations, we generate a final overlay chart showing all system responses.

### Interpreting the Results

The generated charts provide a visual representation of how the system's response changes as the PID parameters are tuned. Look for:

- Faster settling times (the system reaches the setpoint more quickly)
- Reduced overshoot (the system doesn't go as far past the setpoint)
- Smaller steady-state error (the final position is closer to the setpoint)

The overlay chart allows you to compare all iterations side-by-side, clearly showing the improvement in system performance over time.

### Customization

Feel free to modify the `System` struct to simulate different types of systems, adjust the performance metric calculations, or change the number of iterations. You can also experiment with different chart styles or additional visualizations.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.
- If charts aren't generating, ensure you have write permissions in the project directory.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/character_agent.rs">
// examples/interactive_storytelling/character_agent.rs
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::completion::{Chat, PromptError};
pub struct CharacterAgent<A: Chat> {
    pub inner: ChatAgentStateMachine<A>,
}
impl<A: Chat> CharacterAgent<A> {
    pub fn new(agent: A) -> Self {
        Self {
            inner: ChatAgentStateMachine::new(agent),
        }
    }
    pub async fn update_characters(
        &mut self,
        narrative_context: &str,
    ) -> Result<String, PromptError> {
        self.inner
            .transition_to(AgentState::Custom("UpdatingCharacters".into()));
        let prompt = format!(
            "Based on the following narrative context, update the characters' states and actions:\n\n{}",
            narrative_context
        );
        let response = self.inner.process_single_message(&prompt).await?;
        self.inner
            .transition_to(AgentState::Custom("Completed".into()));
        Ok(response)
    }
    pub fn current_state(&self) -> &AgentState {
        self.inner.current_state()
    }
}
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/dialogue_agent.rs">
// examples/interactive_storytelling/dialogue_agent.rs
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::completion::{Chat, PromptError};
pub struct DialogueAgent<A: Chat> {
    pub inner: ChatAgentStateMachine<A>,
}
impl<A: Chat> DialogueAgent<A> {
    pub fn new(agent: A) -> Self {
        Self {
            inner: ChatAgentStateMachine::new(agent),
        }
    }
    pub async fn generate_dialogue(
        &mut self,
        character_context: &str,
    ) -> Result<String, PromptError> {
        self.inner
            .transition_to(AgentState::Custom("GeneratingDialogue".into()));
        let prompt = format!(
            "Generate a dialogue between characters based on the following context:\n\n{}",
            character_context
        );
        let response = self.inner.process_single_message(&prompt).await?;
        self.inner
            .transition_to(AgentState::Custom("Completed".into()));
        Ok(response)
    }
    pub fn current_state(&self) -> &AgentState {
        self.inner.current_state()
    }
}
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/environment_agent.rs">
// examples/interactive_storytelling/environment_agent.rs
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::completion::{Chat, PromptError};
pub struct EnvironmentAgent<A: Chat> {
    pub inner: ChatAgentStateMachine<A>,
}
impl<A: Chat> EnvironmentAgent<A> {
    pub fn new(agent: A) -> Self {
        Self {
            inner: ChatAgentStateMachine::new(agent),
        }
    }
    pub async fn describe_environment(
        &mut self,
        narrative_context: &str,
    ) -> Result<String, PromptError> {
        self.inner
            .transition_to(AgentState::Custom("DescribingEnvironment".into()));
        let prompt = format!(
            "Describe the environment based on the following narrative context:\n\n{}",
            narrative_context
        );
        let response = self.inner.process_single_message(&prompt).await?;
        self.inner
            .transition_to(AgentState::Custom("Completed".into()));
        Ok(response)
    }
    pub fn current_state(&self) -> &AgentState {
        self.inner.current_state()
    }
}
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/main.rs">
// examples/interactive_storytelling/main.rs
mod narrative_agent;
mod character_agent;
mod dialogue_agent;
mod environment_agent;
use narrative_agent::NarrativeAgent;
use character_agent::CharacterAgent;
use dialogue_agent::DialogueAgent;
use environment_agent::EnvironmentAgent;
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::providers::openai::{self, GPT_4};
use rig::completion::{Chat, PromptError};
use tokio::io::{self, AsyncBufReadExt};
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Interactive Storytelling Demo ===\n");
    // Create OpenAI client
    let client = openai::Client::from_env();
    // Initialize agents
    let narrative_agent = client
        .agent(GPT_4)
        .preamble("You are a Narrative Agent that creates engaging stories.")
        .build();
    let mut narrative_state_machine = NarrativeAgent::new(narrative_agent);
    let character_agent = client
        .agent(GPT_4)
        .preamble("You are a Character Agent that develops characters in a story.")
        .build();
    let mut character_state_machine = CharacterAgent::new(character_agent);
    let dialogue_agent = client
        .agent(GPT_4)
        .preamble("You are a Dialogue Agent that generates dialogues between characters.")
        .build();
    let mut dialogue_state_machine = DialogueAgent::new(dialogue_agent);
    let environment_agent = client
        .agent(GPT_4)
        .preamble("You are an Environment Agent that describes settings vividly.")
        .build();
    let mut environment_state_machine = EnvironmentAgent::new(environment_agent);
    // Start the story
    let mut user_choice: Option<String> = None;
    loop {
        // Generate plot
        let narrative_output = narrative_state_machine.generate_plot(user_choice.clone()).await?;
        println!("\n📖 Narrative:\n{}\n", narrative_output);
        // Update characters
        let character_output = character_state_machine.update_characters(&narrative_output).await?;
        println!("👥 Characters:\n{}\n", character_output);
        // Describe environment
        let environment_output = environment_state_machine.describe_environment(&narrative_output).await?;
        println!("🌄 Environment:\n{}\n", environment_output);
        // Generate dialogue
        let dialogue_output = dialogue_state_machine.generate_dialogue(&character_output).await?;
        println!("💬 Dialogue:\n{}\n", dialogue_output);
        // Present the combined story segment to the user
        println!("=== Story Segment ===");
        println!("{}\n{}\n{}\n", environment_output, narrative_output, dialogue_output);
        // Ask for user input
        println!("What do you want to do next?");
        let stdin = io::BufReader::new(io::stdin());
        let mut lines = stdin.lines();
        let input = if let Ok(Some(line)) = lines.next_line().await {
            line
        } else {
            break;
        };
        if input.trim().is_empty() {
            break;
        }
        user_choice = Some(input.trim().to_string());
    }
    println!("\n=== The End ===");
    Ok(())
}
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/narrative_agent.rs">
// examples/interactive_storytelling/narrative_agent.rs
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::completion::{Chat, PromptError};
pub struct NarrativeAgent<A: Chat> {
    pub inner: ChatAgentStateMachine<A>,
}
impl<A: Chat> NarrativeAgent<A> {
    pub fn new(agent: A) -> Self {
        Self {
            inner: ChatAgentStateMachine::new(agent),
        }
    }
    pub async fn generate_plot(
        &mut self,
        user_choice: Option<String>,
    ) -> Result<String, PromptError> {
        self.inner
            .transition_to(AgentState::Custom("GeneratingPlot".into()));
        let prompt = match user_choice {
            Some(choice) => format!("Based on the user's choice '{}', continue the story.", choice),
            None => "Start a new interactive story in the fantasy genre.".to_string(),
        };
        let response = self.inner.process_single_message(&prompt).await?;
        self.inner
            .transition_to(AgentState::Custom("WaitingForChoice".into()));
        Ok(response)
    }
    pub fn current_state(&self) -> &AgentState {
        self.inner.current_state()
    }
}
</file>

<file path="docs/examples/agent_state_machine/examples/interactive_storytelling/README.md">
# Interactive Storytelling with Dynamic World Building and Content Generation

An example demonstrating how to build an interactive storytelling application using multiple AI agents and state machines in Rust, leveraging the [Agent State Machine](https://github.com/0xPlaygrounds/awesome-rig/tree/main/agent_state_machine) design pattern and [Rig](https://github.com/0xPlaygrounds/rig).

---

## Table of Contents

- [Interactive Storytelling with Dynamic World Building and Content Generation](#interactive-storytelling-with-dynamic-world-building-and-content-generation)
  - [Table of Contents](#table-of-contents)
  - [Overview](#overview)
  - [Agents and Their Roles](#agents-and-their-roles)
    - [1. **Narrative Agent**](#1-narrative-agent)
    - [2. **Character Agent**](#2-character-agent)
    - [3. **Dialogue Agent**](#3-dialogue-agent)
    - [4. **Environment Agent**](#4-environment-agent)
  - [State Machines and States](#state-machines-and-states)
    - [Narrative Agent State Machine](#narrative-agent-state-machine)
    - [Character Agent State Machine](#character-agent-state-machine)
    - [Dialogue Agent State Machine](#dialogue-agent-state-machine)
    - [Environment Agent State Machine](#environment-agent-state-machine)
  - [Mermaid Diagrams](#mermaid-diagrams)
    - [Overall Workflow](#overall-workflow)
  - [Implementation Details](#implementation-details)
    - [Project Structure](#project-structure)
    - [Code Breakdown](#code-breakdown)
      - [1. **Main Function (`main.rs`)**](#1-main-function-mainrs)
      - [2. **Agent Implementations**](#2-agent-implementations)
      - [3. **State Transitions**](#3-state-transitions)
      - [4. **User Interaction**](#4-user-interaction)
  - [Running the Example](#running-the-example)
    - [Prerequisites](#prerequisites)
    - [Setup](#setup)
    - [Execution](#execution)
  - [Interacting with the Story](#interacting-with-the-story)
  - [Next updates](#next-updates)
  - [Conclusion](#conclusion)

---

## Overview

This example demonstrates how to create an interactive storytelling application by chaining multiple agents, each managed by its own state machine. The agents collaborate to generate a dynamic story that evolves based on user input.

**Key Concepts:**

- **Modularity**: Each agent focuses on a specific aspect of the story.
- **State Machines**: Manage the states and transitions of each agent for predictable behavior.
- **Asynchronous Execution**: Agents operate asynchronously, ensuring efficient resource utilization.
- **User Interaction**: The user's choices directly influence the narrative progression.

---

## Agents and Their Roles

### 1. **Narrative Agent**

- **Role**: Crafts the overarching storyline and plot progression.
- **Responsibilities**:
  - Initiates the story.
  - Updates the plot based on user choices.
- **Inputs**: User choices, previous plot points.
- **Outputs**: Story events, plot advancements.

### 2. **Character Agent**

- **Role**: Develops characters, their backgrounds, and personalities.
- **Responsibilities**:
  - Updates character states based on the narrative.
  - Manages character development and interactions.
- **Inputs**: Narrative context.
- **Outputs**: Character states and actions.

### 3. **Dialogue Agent**

- **Role**: Generates dialogues between characters.
- **Responsibilities**:
  - Creates conversational exchanges that fit the current context.
- **Inputs**: Character context.
- **Outputs**: Dialogues between characters.

### 4. **Environment Agent**

- **Role**: Describes settings and environments vividly.
- **Responsibilities**:
  - Provides atmospheric descriptions to enhance immersion.
- **Inputs**: Narrative context.
- **Outputs**: Environmental descriptions.

---

## State Machines and States

### Narrative Agent State Machine

```mermaid
stateDiagram-v2
    [*] --> Ready
    Ready --> GeneratingPlot: Start Story / User Choice
    GeneratingPlot --> WaitingForChoice: Plot Generated
    WaitingForChoice --> GeneratingPlot: User Choice
    GeneratingPlot --> Error: Failure
    Error --> Ready: Handle Error
    WaitingForChoice --> [*]: End Story
```

**States:**

- **Ready**: Awaiting story initiation or user input.
- **GeneratingPlot**: Crafting the next part of the story.
- **WaitingForChoice**: Awaiting user decision to influence the plot.
- **Error**: An error occurred during plot generation.

### Character Agent State Machine

```mermaid
stateDiagram-v2
    [*] --> Ready
    Ready --> UpdatingCharacters: Receive Narrative Context
    UpdatingCharacters --> Completed: Characters Updated
    Completed --> Ready: Await Next Update
    UpdatingCharacters --> Error: Failure
    Error --> Ready: Handle Error
```

**States:**

- **Ready**: Waiting for narrative context.
- **UpdatingCharacters**: Adjusting character states based on the narrative.
- **Completed**: Character updates are complete.
- **Error**: An error occurred during character update.

### Dialogue Agent State Machine

```mermaid
stateDiagram-v2
    [*] --> Ready
    Ready --> GeneratingDialogue: Receive Character Context
    GeneratingDialogue --> Completed: Dialogue Generated
    Completed --> Ready: Await Next Dialogue
    GeneratingDialogue --> Error: Failure
    Error --> Ready: Handle Error
```

**States:**

- **Ready**: Waiting for character context.
- **GeneratingDialogue**: Creating dialogues between characters.
- **Completed**: Dialogue generation is complete.
- **Error**: An error occurred during dialogue generation.

### Environment Agent State Machine

```mermaid
stateDiagram-v2
    [*] --> Ready
    Ready --> DescribingEnvironment: Receive Narrative Context
    DescribingEnvironment --> Completed: Environment Described
    Completed --> Ready: Await Next Description
    DescribingEnvironment --> Error: Failure
    Error --> Ready: Handle Error
```

**States:**

- **Ready**: Waiting for narrative context.
- **DescribingEnvironment**: Generating environmental descriptions.
- **Completed**: Environment description is complete.
- **Error**: An error occurred during environment description.

---

## Mermaid Diagrams

### Overall Workflow

```mermaid
sequenceDiagram
    participant User
    participant NarrativeAgent
    participant CharacterAgent
    participant EnvironmentAgent
    participant DialogueAgent

    User->>NarrativeAgent: Start Story / Provide Choice
    NarrativeAgent->>CharacterAgent: Provide Narrative Context
    CharacterAgent->>DialogueAgent: Provide Character Updates
    NarrativeAgent->>EnvironmentAgent: Provide Narrative Context
    EnvironmentAgent->>User: Display Environment Description
    NarrativeAgent->>User: Display Narrative
    DialogueAgent->>User: Display Dialogue
    User->>User: Reads Story Segment
    User->>NarrativeAgent: Provides Next Choice
```

---

## Implementation Details

### Project Structure

```
agent_state_machine/
├── Cargo.lock
├── Cargo.toml
├── README.md
├── examples
│   ├── arxiv_test.rs
│   ├── research_assistant.rs
│   ├── serpapi_test.rs
│   ├── simple_chat.rs
│   └── interactive_storytelling/
│       ├── main.rs
│       ├── narrative_agent.rs
│       ├── character_agent.rs
│       ├── dialogue_agent.rs
│       └── environment_agent.rs
└── src
    ├── lib.rs
    ├── machine.rs
    └── state.rs
```

### Code Breakdown

#### 1. **Main Function (`main.rs`)**

Located at `examples/interactive_storytelling/main.rs`, the main function coordinates the agents and handles user interaction.

- **Imports Modules**: Imports the agent modules.
- **Initializes Agents**: Creates instances of each agent with their respective preambles.
- **Story Loop**: Contains a loop that:
  - Generates the plot.
  - Updates characters.
  - Describes the environment.
  - Generates dialogues.
  - Displays the combined story segment.
  - Prompts the user for the next action.

#### 2. **Agent Implementations**

Each agent is defined in its own file within the `interactive_storytelling` directory.

- **`narrative_agent.rs`**
  - Contains the `NarrativeAgent` struct and implementation.
  - Method: `generate_plot`.

- **`character_agent.rs`**
  - Contains the `CharacterAgent` struct and implementation.
  - Method: `update_characters`.

- **`dialogue_agent.rs`**
  - Contains the `DialogueAgent` struct and implementation.
  - Method: `generate_dialogue`.

- **`environment_agent.rs`**
  - Contains the `EnvironmentAgent` struct and implementation.
  - Method: `describe_environment`.

All agents utilize the `ChatAgentStateMachine` from the `agent_state_machine` library.

#### 3. **State Transitions**

Agents use the `transition_to` method to move between states, ensuring predictable behavior and facilitating debugging.

#### 4. **User Interaction**

The main function handles user input using asynchronous I/O:

- Uses `tokio::io` to read user input.
- The user's choices are passed to the `NarrativeAgent` to influence the story.

---

## Running the Example

### Prerequisites

- **Rust**: Ensure you have Rust installed. Install it from [rustup.rs](https://rustup.rs/).
- **OpenAI API Key**: You need an OpenAI API key to use GPT-4. Set it as an environment variable:

  ```bash
  export OPENAI_API_KEY=your_openai_api_key
  ```

### Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/0xPlaygrounds/awesome-rig.git
   cd agent_state_machine
   ```

2. **Update Dependencies**:

   Ensure your `Cargo.toml` includes the necessary dependencies:

   ```toml
   [dependencies]
   agent_state_machine = { path = "." }
   rig-core = "0.2"
   tokio = { version = "1", features = ["full"] }
   ```

### Execution

Run the interactive storytelling example:

```bash
cargo run --example interactive_storytelling
```

---

## Interacting with the Story

1. **Start the Application**:

   Upon running, the application initializes the agents and begins the story.

2. **Read the Initial Story Segment**:

   The agents generate the opening narrative, character introductions, environment descriptions, and dialogues.

3. **Provide Input**:

   When prompted with:

   ```
   What do you want to do next?
   ```

   Type your desired action and press `Enter`.

   **Example**:

   ```
   > Venture deeper into the forest in search of the mysterious voice.
   ```

4. **Continue the Story**:

   The agents process your input and generate the next segment of the story.

5. **End the Story**:

   To conclude the session, press `Enter` without typing any input when prompted.

---

## Next updates

- **Enhance Agent Preambles**: Fine-tune the behavior of each agent by adjusting their preambles.

- **Add New Agents**: Introduce additional agents for more complexity, such as an `ActionAgent` or `EmotionAgent`.

- **Improve Error Handling**: Implement robust error handling and logging mechanisms.

- **Develop a GUI**: Create a graphical interface for a better user experience.

- **Persist Story State**: Save the story progression to allow users to resume later.

---

## Conclusion

This example showcases how to build a complex application by chaining multiple agents, each managed by their own state machine. The modular design allows for easy maintenance and scalability, while the state machines ensure predictable and manageable behavior.


**Happy storytelling!** If you have any questions or need assistance or want to work together, feel free to reach out.
</file>

<file path="docs/examples/agent_state_machine/examples/arxiv_test.rs">
use reqwest;
use serde::Deserialize;
use serde_xml_rs;
#[derive(Debug, Deserialize)]
struct ArxivApiResponse {
    #[serde(rename = "feed")]
    feed: Option<Feed>,
}
#[derive(Debug, Deserialize)]
struct Feed {
    #[serde(rename = "entry")]
    entries: Option<Vec<Entry>>,
}
#[derive(Debug, Deserialize)]
struct Entry {
    title: String,
    summary: String,
    id: String,
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let query = "quantum computing";
    let url = format!(
        "http://export.arxiv.org/api/query?search_query=all:{}&start=0&max_results=5",
        urlencoding::encode(query)
    );
    let response = reqwest::get(&url).await?;
    let response_text = response.text().await?;
    // Print the response text for debugging purposes
    println!("Response text: {}", response_text);
    let response_json: ArxivApiResponse = serde_xml_rs::from_str(&response_text)?;
    if let Some(feed) = response_json.feed {
        if let Some(entries) = feed.entries {
            for entry in entries {
                println!("Title: {}\nSummary: {}\nLink: {}\n", entry.title, entry.summary, entry.id);
            }
        } else {
            println!("No entries found in the feed.");
        }
    } else {
        println!("No feed found in the response.");
    }
    Ok(())
}
</file>

<file path="docs/examples/agent_state_machine/examples/research_assistant.rs">
use agent_state_machine::{ChatAgentStateMachine, AgentState}; // Added AgentState import
use rig::providers::openai::{self, GPT_4};
use rig::completion::ToolDefinition;
use rig::tool::Tool;
use reqwest;
use serde::{Deserialize, Serialize};
use serde_json::json;
use quick_xml::de::from_str;
use std::time::Duration;
use tracing::error; // Removed unused imports
#[derive(Debug, Deserialize)]
struct SearchArgs {
    query: String,
}
#[derive(Debug, Serialize, Deserialize)]
struct ArxivResult {
    title: String,
    summary: String,
    link: String,
}
#[derive(Debug, Deserialize)]
struct ArxivApiResponse {
    #[serde(rename = "entry")]
    entries: Vec<Entry>,
}
#[derive(Debug, Deserialize)]
struct Entry {
    title: String,
    summary: String,
    id: String,
}
#[derive(Debug, thiserror::Error)]
#[error("Search error: {0}")]
struct SearchError(String);
#[derive(Clone)]
struct ArxivSearch {
    client: reqwest::Client,
}
impl ArxivSearch {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
    async fn search(&self, query: &str) -> Result<Vec<ArxivResult>, SearchError> {
        let url = format!(
            "http://export.arxiv.org/api/query?search_query=all:{}&start=0&max_results=5",
            urlencoding::encode(query)
        );
        let response = self
            .client
            .get(&url)
            .send()
            .await
            .map_err(|e| SearchError(e.to_string()))?;
        let response_text = response
            .text()
            .await
            .map_err(|e| SearchError(e.to_string()))?;
        let response_json: Result<ArxivApiResponse, _> = from_str(&response_text);
        match response_json {
            Ok(response_json) => {
                let results = response_json
                    .entries
                    .into_iter()
                    .map(|entry| ArxivResult {
                        title: entry.title,
                        summary: entry.summary,
                        link: entry.id,
                    })
                    .collect();
                Ok(results)
            }
            Err(_) => Err(SearchError(
                "Failed to parse the response. The structure might have unexpected namespaces or formats."
                    .to_string(),
            )),
        }
    }
}
impl Tool for ArxivSearch {
    const NAME: &'static str = "arxiv_search";
    type Error = SearchError;
    type Args = SearchArgs;
    type Output = Vec<ArxivResult>;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Search for academic papers on arXiv.".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The search query to look for papers on arXiv"
                    }
                },
                "required": ["query"]
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        self.search(&args.query).await
    }
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Research Assistant State Machine Demo ===\n");
    let openai_client = openai::Client::from_env();
    // Create ArxivSearch tool
    let arxiv_search_tool = ArxivSearch::new();
    // Create a basic chat agent with the ArxivSearch tool
    let agent = openai_client
        .agent(GPT_4)
        .preamble(
            "You are a helpful assistant with academic search capabilities using arXiv. \
            When provided with information about a paper, you summarize the main points \
            and present a concise summary of the key information."
        )
        .build();
    // Create a state machine for managing the agent
    let mut state_machine = ChatAgentStateMachine::new(agent);
    // Set up a response callback to handle outputs
    state_machine.set_response_callback(|response| {
        println!("🤖 Assistant: {}", response);
    });
    // Subscribe to state changes
    let mut state_rx = state_machine.subscribe_to_state_changes();
    tokio::spawn(async move {
        while let Ok(state) = state_rx.recv().await {
            println!("📍 State: {}", state);
        }
    });
    // Get search results directly
    let query = "llm transformer";
    println!("🔍 Searching arXiv for '{}'", query);
    let results = arxiv_search_tool.search(query).await?;
    for (index, result) in results.iter().enumerate() {
        println!("\nProcessing result {}...", index + 1);
        // Enqueue a message into the state machine for each result
        let message = format!(
            "Please summarize the following paper:\nTitle: {}\nSummary: {}\nLink: {}",
            result.title, result.summary, result.link
        );
        state_machine.process_message(&message).await?;
        while state_machine.current_state() != &AgentState::Ready {
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        // Small delay to make the interaction feel more natural
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
    println!("\n=== Demo Complete ===");
    Ok(())
}
</file>

<file path="docs/examples/agent_state_machine/examples/serpapi_test.rs">
use agent_state_machine::ChatAgentStateMachine;
use rig::providers::openai::{self, GPT_4};
use rig::completion::{ToolDefinition};
use rig::tool::Tool;
use reqwest;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::time::Duration;
#[derive(Debug, Deserialize)]
struct SearchArgs {
    query: String,
}
#[derive(Debug, Serialize, Deserialize)]
struct ArxivResult {
    title: String,
    summary: String,
    link: String,
}
#[derive(Debug, Deserialize)]
struct ArxivApiResponse {
    #[serde(rename = "feed")]
    feed: Feed,
}
#[derive(Debug, Deserialize)]
struct Feed {
    #[serde(rename = "entry")]
    entries: Vec<Entry>,
}
#[derive(Debug, Deserialize)]
struct Entry {
    title: String,
    summary: String,
    id: String,
}
#[derive(Debug, thiserror::Error)]
#[error("Search error: {0}")]
struct SearchError(String);
#[derive(Clone)]
struct ArxivSearch {
    client: reqwest::Client,
}
impl ArxivSearch {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
    async fn search(&self, query: &str) -> Result<Vec<ArxivResult>, SearchError> {
        let url = format!(
            "http://export.arxiv.org/api/query?search_query=all:{}&start=0&max_results=5",
            urlencoding::encode(query)
        );
        let response = self.client.get(&url).send().await.map_err(|e| SearchError(e.to_string()))?;
        let response_text = response.text().await.map_err(|e| SearchError(e.to_string()))?;
        let response_json: ArxivApiResponse = serde_xml_rs::from_str(&response_text).map_err(|e| SearchError(e.to_string()))?;
        let results = response_json
            .feed
            .entries
            .into_iter()
            .map(|entry| ArxivResult {
                title: entry.title,
                summary: entry.summary,
                link: entry.id,
            })
            .collect();
        Ok(results)
    }
}
impl Tool for ArxivSearch {
    const NAME: &'static str = "arxiv_search";
    type Error = SearchError;
    type Args = SearchArgs;
    type Output = Vec<ArxivResult>;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Search for academic papers on arXiv.".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The search query to look for papers on arXiv"
                    }
                },
                "required": ["query"]
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        self.search(&args.query).await
    }
}
#[derive(Debug, Clone, PartialEq)]
enum ResearchState {
    Ready,
    Searching,
    Summarizing,
    Complete,
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let openai_client = openai::Client::from_env();
    // Create ArxivSearch tool
    let arxiv_search_tool = ArxivSearch::new();
    // Create a basic chat agent with the ArxivSearch tool
    let agent = openai_client
        .agent(GPT_4)
        .preamble("You are a helpful assistant with academic search capabilities using arXiv. When providing search results, summarize the main points and present a concise summary of the key information from the top few results.")
        .tool(arxiv_search_tool.clone())
        .build();
    // Create a state machine for managing the agent
    let mut state_machine = ChatAgentStateMachine::new(agent);
    // Subscribe to state changes
    let mut state_rx = state_machine.subscribe_to_state_changes();
    tokio::spawn(async move {
        while let Ok(state) = state_rx.recv().await {
            println!("📍 State: {}", state);
        }
    });
    // Process a query using the state machine
    let response = state_machine.process_message("Search for the latest research on quantum computing").await?;
    println!("Response: {}", response);
    // Small delay to make the interaction feel more natural
    tokio::time::sleep(Duration::from_millis(500)).await;
    Ok(())
}
</file>

<file path="docs/examples/agent_state_machine/examples/simple_chat.rs">
use agent_state_machine::{ChatAgentStateMachine, AgentState}; // Added AgentState import
use rig::providers::openai::{self, GPT_4};
use std::time::Duration;
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Chat Agent State Machine Demo ===\n");
    // Create OpenAI client
    let client = openai::Client::from_env();
    // Create a basic chat agent
    let agent = client
        .agent(GPT_4)
        .preamble("\
            You are a helpful and friendly AI assistant. \
            Keep your responses concise but engaging.\
        ")
        .build();
    // Create state machine
    let mut state_machine = ChatAgentStateMachine::new(agent);
    // Set up a response callback to handle outputs
    state_machine.set_response_callback(|response| {
        println!("🤖 Assistant: {}", response);
    });
    // Subscribe to state changes
    let mut state_rx = state_machine.subscribe_to_state_changes();
    // Spawn task to monitor state changes
    tokio::spawn(async move {
        while let Ok(state) = state_rx.recv().await {
            println!("📍 State: {}", state);
        }
    });
    // Process a few messages
    let messages = vec![
        "Hello! How are you?",
        "What's your favorite color?",
        "What is the meaning of life?",
        "What is the airspeed velocity of an unladen swallow?",
        "What is the capital of Assyria?",
        "What is the airspeed velocity of a coconut-laden swallow?",
    ];
    // Enqueue all messages into the state machine
    for message in messages {
        println!("\n👤 User: {}", message);
        // Enqueue the message
        state_machine.process_message(message).await?;
    }
    // Wait until all messages have been processed
    while state_machine.current_state() != &AgentState::Ready {
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    println!("\n=== Demo Complete ===");
    Ok(())
}
</file>

<file path="docs/examples/agent_state_machine/src/lib.rs">
//! Agent State Machine is a library for managing Large Language Model (LLM) agents
//! using a state machine pattern. It provides a robust way to handle agent states,
//! transitions, and behaviors.
//! 
//! # Example
//! ```rust,no_run
//! use agent_state_machine::{ChatAgentStateMachine, AgentState};
//! use rig::providers::openai;
//! 
//! #[tokio::main]
//! async fn main() {
//!     let client = openai::Client::from_env();
//!     let agent = client
//!         .agent(openai::GPT_4)
//!         .preamble("You are a helpful AI assistant.")
//!         .build();
//!     
//!     let mut state_machine = ChatAgentStateMachine::new(agent);
//!     
//!     let response = state_machine.process_message("Hello!").await.unwrap();
//!     println!("Response: {}", response);
//! }
//! ```
mod state;
mod machine;
pub use state::AgentState;
pub use machine::ChatAgentStateMachine;
</file>

<file path="docs/examples/agent_state_machine/src/machine.rs">
use crate::state::AgentState;
use rig::completion::{Chat, Message, PromptError};
use std::collections::VecDeque;
use tokio::sync::broadcast;
use tracing::{debug, error, info};
/// A state machine for a chat agent that can process messages in a queue
pub struct ChatAgentStateMachine<A: Chat> {
    /// Current state of the agent
    current_state: AgentState,
    /// The underlying agent that handles the chat
    agent: A,
    /// Channel for broadcasting state changes
    state_tx: broadcast::Sender<AgentState>,
    /// Chat history
    history: Vec<Message>,
    /// Queue of messages to process
    queue: VecDeque<String>,
    /// Optional response callback to handle outputs
    response_callback: Option<Box<dyn Fn(String) + Send + Sync>>,
}
impl<A: Chat> ChatAgentStateMachine<A> {
    /// Create a new ChatAgentStateMachine with the given agent
    pub fn new(agent: A) -> Self {
        let (state_tx, _) = broadcast::channel(32);
        let machine = Self {
            current_state: AgentState::Ready,
            agent,
            state_tx,
            history: Vec::new(),
            queue: VecDeque::new(),
            response_callback: None,
        };
        info!("Agent initialized in state: {}", machine.current_state);
        machine
    }
    /// Set a response callback to handle outputs
    pub fn set_response_callback<F>(&mut self, callback: F)
    where
        F: Fn(String) + Send + Sync + 'static,
    {
        self.response_callback = Some(Box::new(callback));
    }
    /// Enqueue a user message for processing
    pub async fn process_message(&mut self, message: &str) -> Result<(), PromptError> {
        debug!("Enqueuing message: {}", message);
        self.queue.push_back(message.to_string());
        if self.current_state == AgentState::Ready {
            self.process_queue().await;
        }
        Ok(())
    }
    /// Process messages from the queue
    async fn process_queue(&mut self) {
        self.transition_to(AgentState::ProcessingQueue);
        while let Some(message) = self.queue.pop_front() {
            self.transition_to(AgentState::Processing);
            match self.process_single_message(&message).await {
                Ok(response) => {
                    // Handle the response (e.g., send it to the user)
                    if let Some(callback) = &self.response_callback {
                        callback(response);
                    } else {
                        println!("Response: {}", response);
                    }
                }
                Err(e) => {
                    error!("Error processing message: {}", e);
                    self.transition_to(AgentState::Error(e.to_string()));
                    // Decide whether to continue processing or break
                    // For this example, we'll break on error
                    break;
                }
            }
        }
        // After processing the queue, transition back to Ready
        self.transition_to(AgentState::Ready);
    }
    /// Process a single message
    pub async fn process_single_message(&mut self, message: &str) -> Result<String, PromptError> {
        debug!("Processing message: {}", message);
        self.history.push(Message {
            role: "user".into(),
            content: message.into(),
        });
        match self.agent.chat(message, self.history.clone()).await {
            Ok(response) => {
                self.history.push(Message {
                    role: "assistant".into(),
                    content: response.clone(),
                });
                debug!("Successfully processed message");
                Ok(response)
            }
            Err(e) => {
                error!("Error processing message: {}", e);
                Err(e)
            }
        }
    }
    /// Get the current state
    pub fn current_state(&self) -> &AgentState {
        &self.current_state
    }
    /// Get the chat history
    pub fn history(&self) -> &[Message] {
        &self.history
    }
    /// Subscribe to state changes
    pub fn subscribe_to_state_changes(&self) -> broadcast::Receiver<AgentState> {
        self.state_tx.subscribe()
    }
    /// Clear the chat history
    pub fn clear_history(&mut self) {
        self.history.clear();
    }
    pub fn transition_to(&mut self, new_state: AgentState) {
        debug!("State transition: {} -> {}", self.current_state, new_state);
        self.current_state = new_state.clone();
        let _ = self.state_tx.send(new_state);
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use std::future::Future;
    use std::pin::Pin;
    use tokio::time::{sleep, Duration};
    struct MockAgent;
    impl Chat for MockAgent {
        fn chat<'a>(
            &'a self,
            prompt: &'a str,
            _history: Vec<Message>,
        ) -> Pin<Box<dyn Future<Output = Result<String, PromptError>> + Send + 'a>> {
            let response = format!("Echo: {}", prompt);
            Box::pin(async move {
                // Simulate some processing delay
                sleep(Duration::from_millis(50)).await;
                Ok(response)
            })
        }
    }
    #[tokio::test]
    async fn test_process_message_queue() {
        let mut machine = ChatAgentStateMachine::new(MockAgent);
        let mut responses = Vec::new();
        machine.set_response_callback(|response| {
            responses.push(response);
        });
        machine.process_message("Message 1").await.unwrap();
        machine.process_message("Message 2").await.unwrap();
        machine.process_message("Message 3").await.unwrap();
        // Wait until processing is complete
        while machine.current_state() != &AgentState::Ready {
            sleep(Duration::from_millis(10)).await;
        }
        assert_eq!(responses.len(), 3);
        assert_eq!(responses[0], "Echo: Message 1");
        assert_eq!(responses[1], "Echo: Message 2");
        assert_eq!(responses[2], "Echo: Message 3");
    }
    #[tokio::test]
    async fn test_clear_history() {
        let mut machine = ChatAgentStateMachine::new(MockAgent);
        machine.process_message("Test").await.unwrap();
        assert!(!machine.history().is_empty());
        machine.clear_history();
        assert!(machine.history().is_empty());
    }
}
</file>

<file path="docs/examples/agent_state_machine/src/state.rs">
// src/state.rs
use std::fmt;
/// Represents the possible states of a chat agent
#[derive(Debug, Clone, PartialEq)]
pub enum AgentState {
    /// Ready to receive input
    Ready,
    /// Processing a user message
    Processing,
    /// Processing messages from the queue
    ProcessingQueue,
    /// Error state when something goes wrong
    Error(String),
    /// Custom state for specific agent actions
    Custom(String),
}
impl fmt::Display for AgentState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AgentState::Ready => write!(f, "Ready"),
            AgentState::Processing => write!(f, "Processing"),
            AgentState::ProcessingQueue => write!(f, "Processing Queue"),
            AgentState::Error(msg) => write!(f, "Error: {}", msg),
            AgentState::Custom(state) => write!(f, "{}", state),
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_state_display() {
        assert_eq!(AgentState::Ready.to_string(), "Ready");
        assert_eq!(AgentState::Processing.to_string(), "Processing");
        assert_eq!(
            AgentState::Error("test error".into()).to_string(),
            "Error: test error"
        );
    }
    #[test]
    fn test_state_clone_and_eq() {
        let state = AgentState::Ready;
        let cloned = state.clone();
        assert_eq!(state, cloned);
    }
}
</file>

<file path="docs/examples/agent_state_machine/.gitignore">
/target
**/*.rs.bk
Cargo.lock
.env
.idea/
.vscode/
*.swp
*.swo
</file>

<file path="docs/examples/agent_state_machine/Cargo.toml">
[package]
name = "agent_state_machine"
version = "0.1.0"
edition = "2021"
authors = ["tachikoma000"]
description = "A state machine implementation for LLM agents"
license = "MIT"
repository = "https://github.com/tachikoma000/agent_state_machine"

[dependencies]
rig-core = "0.2"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
tracing = "0.1"
futures = "0.3"
serde-xml-rs = "0.6"
quick-xml = { version = "0.36.2", features = ["serialize"] }
# New dependencies for research assistant
reqwest = { version = "0.11", features = ["json"] }
urlencoding = "2.1"
scraper = "0.20.0"

[dev-dependencies]
tokio-test = "0.4"
</file>

<file path="docs/examples/agent_state_machine/README.md">
# Agent State Machine

An experiment for managing Large Language Model (LLM) agents using state machine patterns. This framework provides a robust and scalable foundation for building predictable, maintainable, and extensible AI agents.

> ⭐ If you find this project useful, please consider giving [Rig](https://github.com/0xPlaygrounds/rig) a star on GitHub.

## Why Use State Machines for LLM Agents?

### 1. **Predictable and Controlled Behavior**

- **Deterministic State Transitions**: The agent's behavior is governed by explicit states and transitions, ensuring consistency and predictability.
- **Defined Workflows**: Predefined paths guide the agent through complex tasks, reducing unexpected behaviors.
- **Error Handling and Recovery**: Structured error states allow for graceful recovery without compromising the overall system.

### 2. **Enhanced Debugging and Monitoring**

- **Observable States**: Track and log each state transition for real-time monitoring and historical analysis.
- **State History Tracking**: Maintain a record of state changes to diagnose issues and optimize performance.
- **Clear Entry and Exit Points**: Simplify debugging by isolating issues within specific states.

### 3. **Modular and Maintainable Code**

- **Separation of Concerns**: Each state encapsulates specific functionality, making the codebase modular.
- **Easy Extensibility**: Add or modify states and transitions without overhauling the entire system.
- **Isolated Testing**: Test states and transitions independently to ensure reliability.

### 4. **Asynchronous and Concurrent Processing**

- **Non-Blocking Operations**: Handle long-running tasks without blocking the main execution thread.
- **Queued Message Handling**: Process messages sequentially or concurrently, improving throughput.
- **Resource Optimization**: Efficiently manage resources like API calls, network connections, and memory.

### 5. **Fine-Grained Control Over Agent Behavior**

- **Customizable State Logic**: Tailor the agent's behavior by defining custom states and transitions.
- **Event-Driven Responses**: React to external events or user inputs dynamically within the state framework.
- **Advanced Workflow Management**: Implement complex behaviors like retries, timeouts, and conditional branching.

## Features

- 🔄 **Flexible State Management**: Define and manage custom states for your LLM agents.
- 📝 **Built-In Chat History Tracking**: Maintain conversation history effortlessly.
- 🔔 **State Change Notifications**: Subscribe to state changes for real-time monitoring.
- ❌ **Robust Error Handling**: Gracefully handle errors with clear recovery paths.
- 📚 **Tool Integration**: Seamlessly integrate with tools and APIs (e.g., arXiv API).
- 🌐 **Asynchronous Processing**: Efficiently handle long-running or queued tasks.
- 🔌 **Rig-Compatible**: Works with any [Rig](https://github.com/0xPlaygrounds/rig)-compatible LLM provider.

## Installation

Clone this repository and navigate to the `agent_state_machine` directory:

```bash
git clone https://github.com/0xPlaygrounds/awesome-rig.git
cd agent_state_machine
```

## Quick Start

```rust
use agent_state_machine::{ChatAgentStateMachine, AgentState};
use rig::providers::openai;

#[tokio::main]
async fn main() {
    // Initialize OpenAI client
    let client = openai::Client::from_env();

    // Create agent with GPT-4
    let agent = client
        .agent(openai::GPT_4)
        .preamble("You are a helpful AI assistant.")
        .build();

    // Create state machine
    let mut state_machine = ChatAgentStateMachine::new(agent);

    // Subscribe to state changes
    let mut state_rx = state_machine.subscribe_to_state_changes();

    // Monitor state changes
    tokio::spawn(async move {
        while let Ok(state) = state_rx.recv().await {
            println!("📍 State changed to: {}", state);
        }
    });

    // Set up a response callback
    state_machine.set_response_callback(|response| {
        println!("🤖 Assistant: {}", response);
    });

    // Process a message
    state_machine
        .process_message("Hello!")
        .await
        .unwrap();

    // Wait until processing is complete
    while state_machine.current_state() != &AgentState::Ready {
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }
}
```

## State Machine Diagram

```mermaid
stateDiagram-v2
    [*] --> Ready
    Ready --> ProcessingQueue: Enqueue Message
    ProcessingQueue --> Processing: Dequeue Message
    Processing --> ProcessingQueue: Next Message
    Processing --> Ready: No More Messages
    Processing --> Error: Failure
    Error --> Ready: Handle Error
    Ready --> [*]: Shutdown
```

## Current States

| State            | Description                                             |
|------------------|---------------------------------------------------------|
| **Ready**        | Agent is idle and ready to receive input                |
| **ProcessingQueue** | Agent is managing the message queue                    |
| **Processing**   | Agent is processing a message                           |
| **Error**        | Agent encountered an error during processing            |

## Future Extensions

This framework can be extended to support:

- 🛠 **Advanced Tool Integration**: Incorporate more complex tools with dedicated states.
- 💾 **Persistent Storage**: Implement persistent conversation history and state.
- 🔄 **Automatic Retries**: Add retry mechanisms for failed operations.
- 🎯 **Goal-Oriented Behavior**: Introduce goal-tracking and planning capabilities.
- 🔗 **Multi-Agent Coordination**: Coordinate behaviors among multiple agents.
- 🧠 **Context Management**: Manage context switching and parallel conversations.

## Example Use Cases

### 1. **Research Assistant**

Build an AI agent that searches academic databases (e.g., arXiv) and summarizes papers:

- **Queued Processing**: Handle multiple search results one by one.
- **Asynchronous Execution**: Fetch and process papers without blocking.
- **State Tracking**: Monitor progress through different processing stages.

### 2. **Customer Support Bot**

Develop a chatbot for customer service interactions:

- **Stateful Conversations**: Maintain context across multiple turns.
- **Error Handling**: Recover from misunderstandings or incorrect inputs.
- **Integration with APIs**: Interface with backend systems for data retrieval.

### 3. **Data Pipeline Automation**

Create an agent that automates data processing tasks:

- **Task Scheduling**: Manage and execute tasks based on state transitions.
- **Resource Management**: Allocate and release resources efficiently.
- **Monitoring and Logging**: Track the pipeline's progress and performance.

## Need to Know

- **Built with [Rig](https://github.com/0xPlaygrounds/rig)**: A Rust library for building LLM-powered applications.
- **Inspired by Traditional State Machines**: Apply proven software engineering patterns to AI agents.

---


# Examples

## Research Assistant Example

Check out `examples/research_assistant.rs` to see how to build a research assistant that searches arXiv and summarizes papers.

## Simple Chat Example

Refer to `examples/simple_chat.rs` for a basic implementation of a chat agent using the state machine.

---

**Note**: Ensure that your environment variables are set up correctly, such as the OpenAI API key required by `openai::Client::from_env()`.

⭐ If you find this project useful, please consider giving [Rig](https://github.com/0xPlaygrounds/rig) a star on GitHub.
</file>

<file path="docs/examples/agents/close_empty_token_accounts.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let data = agent.close_empty_token_accounts().await.unwrap();
    println!("Close data: {:?}", data);
}
</file>

<file path="docs/examples/agents/create_gibwork_task.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    // Task details
    let title = "Implement New Feature";
    let content = "We need to implement a new authentication system using JWT tokens";
    let requirements =
        "- Experience with Rust and JWT\n- Understanding of authentication flows\n- Test coverage required";
    let tags = vec!["rust".to_string(), "authentication".to_string(), "jwt".to_string()];
    let token_mint_address = "So11111111111111111111111111111111111111112";
    let token_amount = 1_000_000_000; // 1 SOL = 1 billion lamports
    let payer = None;
    let response = agent
        .create_gibwork_task(title, content, requirements, tags, token_mint_address, token_amount, payer)
        .await
        .unwrap();
    println!("Task created successfully!");
    println!("Task ID: {}", response.task_id);
    println!("Transaction signature: {}", response.signature);
}
</file>

<file path="docs/examples/agents/create_solana_tools.rs">
use solagent::{create_solana_tools, Config, SolanaAgentKit};
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new("private_key", "RPC_URL", config);
    let _tools = create_solana_tools(agent);
}
</file>

<file path="docs/examples/agents/defi_trading.rs">
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{AccountInfo, next_account_info},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_program,
    program::invoke,
    instruction::Instruction,
    program,
};
use std::collections::{HashMap, VecDeque};
// Trading Pair Struct
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default, PartialEq, Eq, Hash)]
pub struct TradingPair{
    pub base_mint: Pubkey,
    pub quote_mint: Pubkey,
}
// Order Struct
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct Order{
    pub id: u32,
    pub trading_pair: TradingPair,
    pub order_type: String,    // "Limit", "Market", etc.
    pub side: String,    // "Buy" or "Sell"
    pub price: u64,
    pub amount: u64,
    pub filled_amount: u64,
    pub timestamp: u64,
    pub status: String, // Open, Filled, Cancelled
    pub dex_order_id: Option<Vec<u8>>,
    // Add other order details as needed
}
// Position Struct
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct Position {
  pub trading_pair: TradingPair,
  pub base_amount: u64, // Amount of the base currency held
  pub quote_amount: u64, // Amount of the quote currency held
}
// Agent Configuration (DeFi Bot)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentConfig {
    pub owner: Pubkey,
    pub description: String,
    pub dex_program_id: Pubkey, // DEX program ID to interact with
    pub trading_pair: TradingPair,
    pub strategy_type: String, // Example: "SMA Crossover", "RSI Strategy"
    pub risk_parameters: RiskParameters,
     // Add more DeFi bot specific settings
}
// Risk Management parameters
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct RiskParameters{
    pub take_profit_percentage: f64, // Example 0.05 for 5%
    pub stop_loss_percentage: f64, // Example 0.03 for 3%
}
// Agent Instance Structure
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentInstance {
    pub agent_id: u32,
    pub status: u8,         // 0: created, 1: running, 2: completed, 3: error
    pub start_time: u64,
    pub current_position: Position,
}
// Program State
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct ProgramState {
    pub next_agent_id: u32,
    pub next_order_id: u32,
    pub agent_configs: Vec<AgentConfig>,
     pub agent_instances: Vec<AgentInstance>,
    pub open_orders: HashMap<u32, Order>, // Order id to order
    pub order_history: HashMap<TradingPair, Vec<Order>>,
    pub positions: HashMap<TradingPair, Position>, // Map trading pair to position
     pub last_analysis_time: u64,
}
// Define Instruction Enum
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub enum AgentInstruction {
    CreateAgent(AgentConfig),
    CreateAgentInstance { agent_id: u32 },
    UpdateAgentInstanceStatus { agent_id: u32, instance_id: u32, status: u8 },
     CreateOrder {agent_id: u32, trading_pair: TradingPair, order_type: String, side: String, price: u64, amount: u64},
     CancelOrder {order_id: u32},
     UpdateOrderStatus {order_id: u32, status: String, filled_amount: u64, dex_order_id: Option<Vec<u8>>},
    AnalyzeMarketAndTrade { agent_id: u32 }
}
// Entrypoint
entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("AI Agent Program invoked!");
    let instruction = AgentInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
     let accounts_iter = &mut accounts.iter();
    let state_account = next_account_info(accounts_iter)?;
    if !state_account.is_writable {
        msg!("Program state account is not writeable");
        return Err(ProgramError::InvalidArgument);
    }
    // Load Program state (if available) or create a new one if not initialized
    let mut program_state = ProgramState::try_from_slice(&state_account.data.borrow())
         .unwrap_or_default();
    match instruction {
        AgentInstruction::CreateAgent(config) => {
            msg!("Creating agent config...");
            create_agent(&mut program_state, config, program_id, state_account)?;
        }
        AgentInstruction::CreateAgentInstance { agent_id } => {
            msg!("Creating agent instance...");
           create_agent_instance(&mut program_state, agent_id, state_account)?;
        }
        AgentInstruction::UpdateAgentInstanceStatus {agent_id, instance_id, status} => {
            msg!("Updating agent instance status...");
             update_agent_instance_status(&mut program_state, agent_id, instance_id, status, state_account)?;
        }
         AgentInstruction::CreateOrder {agent_id, trading_pair, order_type, side, price, amount} => {
              msg!("Creating a new order");
              create_order(&mut program_state, agent_id, trading_pair, order_type, side, price, amount, state_account, program_id, accounts)?;
         }
         AgentInstruction::CancelOrder{order_id} => {
             msg!("Cancelling an order");
             cancel_order(&mut program_state, order_id, state_account, program_id, accounts)?;
         }
         AgentInstruction::UpdateOrderStatus{order_id, status, filled_amount, dex_order_id} => {
             msg!("Updating an order");
             update_order_status(&mut program_state, order_id, status, filled_amount, dex_order_id, state_account)?;
        }
        AgentInstruction::AnalyzeMarketAndTrade {agent_id} => {
            msg!("Analyzing market data and trading");
            analyze_market_and_trade(&mut program_state, agent_id, state_account, program_id, accounts)?;
        }
    }
     // Serialize the program state back to the account
     program_state.serialize(&mut &mut state_account.data.borrow_mut()[..])?;
    Ok(())
}
// Instruction implementations
fn create_agent(
    program_state: &mut ProgramState,
    config: AgentConfig,
    program_id: &Pubkey,
     state_account: &AccountInfo,
) -> ProgramResult {
    // Check if the signer is the owner of program
     if state_account.owner != program_id {
        msg!("Incorrect owner for program");
        return Err(ProgramError::IncorrectProgramId);
    }
    let config_id = program_state.next_agent_id;
    program_state.agent_configs.push(config.clone());
    program_state.next_agent_id += 1;
     msg!("Created agent with ID: {}", config_id);
    Ok(())
}
fn create_agent_instance(
    program_state: &mut ProgramState,
    agent_id: u32,
   _state_account: &AccountInfo,
) -> ProgramResult {
     // Check if agent exists
     if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let new_instance = AgentInstance {
        agent_id,
        status: 0, // Created status
        start_time: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
        current_position: Position::default(),
    };
     program_state.agent_instances.push(new_instance);
     msg!("Created agent instance with agent ID: {}", agent_id);
    Ok(())
}
fn update_agent_instance_status(
    program_state: &mut ProgramState,
    agent_id: u32,
    instance_id: u32,
    status: u8,
    _state_account: &AccountInfo,
) -> ProgramResult {
    if program_state.agent_instances.len() <= instance_id as usize {
        msg!("Agent instance not found");
        return Err(ProgramError::InvalidArgument);
    }
     let instance = program_state.agent_instances.get_mut(instance_id as usize).unwrap();
     if instance.agent_id != agent_id {
        msg!("Incorrect agent ID for the requested instance");
        return Err(ProgramError::InvalidArgument)
    }
     instance.status = status;
     msg!("Updated agent instance status to: {}", status);
     Ok(())
}
fn create_order(
    program_state: &mut ProgramState,
    agent_id: u32,
    trading_pair: TradingPair,
    order_type: String,
    side: String,
    price: u64,
    amount: u64,
   _state_account: &AccountInfo,
    program_id: &Pubkey,
    accounts: &[AccountInfo]
)-> ProgramResult{
     // Check if agent exists
    if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let agent_config = &program_state.agent_configs[agent_id as usize];
    // Create new order
      let order = Order {
        id: program_state.next_order_id,
        trading_pair,
        order_type,
        side,
        price,
        amount,
        filled_amount: 0,
        timestamp: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
        status: "Open".to_string(),
         dex_order_id: None,
     };
      // Perform CPI to DEX (example)
        let dex_cpi_result = execute_dex_cpi(agent_config, &order, program_id, accounts);
        let dex_order_id = match dex_cpi_result {
           Ok(result) => Some(result),
           Err(_err) => None
        };
      let mut order = order.clone();
       order.dex_order_id = dex_order_id;
     // Store new order
      program_state.open_orders.insert(order.id, order.clone());
     // Record in history
      let order_history = program_state.order_history.entry(trading_pair).or_insert_with(Vec::new);
        order_history.push(order);
     program_state.next_order_id += 1;
     msg!("Order created with ID: {}", order.id);
    Ok(())
}
fn cancel_order(
    program_state: &mut ProgramState,
    order_id: u32,
    _state_account: &AccountInfo,
    program_id: &Pubkey,
     accounts: &[AccountInfo]
) -> ProgramResult {
      // Check if the order exists
     if !program_state.open_orders.contains_key(&order_id) {
        msg!("Order not found");
        return Err(ProgramError::InvalidArgument);
    }
     let order = program_state.open_orders.get_mut(&order_id).unwrap();
     // Check if the order is open or already filled
       if order.status != "Open" {
         msg!("Cannot cancel a non-open order.");
          return Err(ProgramError::InvalidArgument);
       }
       let agent_config = program_state.agent_configs.iter().find(|x| x.trading_pair == order.trading_pair).unwrap();
      //Perform CPI to DEX (Example)
     let _ = cancel_dex_cpi(agent_config, &order, program_id, accounts);
       // Update Order Status
      order.status = "Cancelled".to_string();
     msg!("Order cancelled with ID: {}", order_id);
     Ok(())
}
fn update_order_status(
    program_state: &mut ProgramState,
    order_id: u32,
    status: String,
    filled_amount: u64,
    dex_order_id: Option<Vec<u8>>,
     _state_account: &AccountInfo,
) -> ProgramResult {
     // Check if the order exists
     if !program_state.open_orders.contains_key(&order_id) {
        msg!("Order not found");
        return Err(ProgramError::InvalidArgument);
    }
      let order = program_state.open_orders.get_mut(&order_id).unwrap();
       // Update Order Status
      order.status = status.clone();
       order.filled_amount = filled_amount;
        if dex_order_id.is_some() {
            order.dex_order_id = dex_order_id;
         }
        // if status is filled, then remove it from open orders
        if status == "Filled" {
              program_state.open_orders.remove(&order_id);
             // Update Position
           update_position(program_state, order);
        }
     msg!("Order status updated to {} with ID: {}", status, order_id);
    Ok(())
}
fn analyze_market_and_trade(
    program_state: &mut ProgramState,
     agent_id: u32,
    _state_account: &AccountInfo,
    program_id: &Pubkey,
    accounts: &[AccountInfo]
) -> ProgramResult {
      // Check if agent exists
    if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let agent_config = &program_state.agent_configs[agent_id as usize];
    // Example Logic - fetch current price and create a new order based on the price
    let current_price = fetch_current_price();
      //Fetch current position for the given trading pair
      let position = program_state.positions.get(&agent_config.trading_pair);
    // Check current price against position and risk parameters.
      if let Some(position) = position {
           let new_order = check_risk_parameters(agent_config, position, current_price);
              if let Some(order) = new_order{
                   msg!("Creating new order based on risk parameters");
                    create_order(program_state, agent_id, agent_config.trading_pair.clone(), order.order_type, order.side, order.price, order.amount, _state_account, program_id, accounts)?;
                }
      }else{
        // If there is no position create a buy order at current price to initialize position
       create_order(program_state, agent_id, agent_config.trading_pair.clone(), "Market".to_string(), "Buy".to_string(), current_price, 1, _state_account, program_id, accounts)?;
      }
       program_state.last_analysis_time =  solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64;
    Ok(())
}
// Example DEX CPI (Cross-Program Invocation)
fn execute_dex_cpi(_agent_config: &AgentConfig, order: &Order, _program_id: &Pubkey, _accounts: &[AccountInfo]) -> Result<Vec<u8>, ProgramError> {
   msg!("Executing DEX CPI");
   // Build DEX instruction using the agent_config and order.
   // You would use an instruction to interact with another program
  //Dummy order_id for the example
  let dex_order_id: Vec<u8> = vec![1, 2, 3, 4];
  Ok(dex_order_id)
}
// Example cancel CPI to DEX (Cross-Program Invocation)
fn cancel_dex_cpi(_agent_config: &AgentConfig, order: &Order, _program_id: &Pubkey, _accounts: &[AccountInfo]) -> Result<(), ProgramError> {
  msg!("Cancelling DEX CPI");
   // Build DEX instruction to cancel order using the order.
   // You would use an instruction to interact with another program
  Ok(())
}
// Example function to fetch current price (replace with real data feed)
fn fetch_current_price() -> u64{
   10 // Example price data
}
fn check_risk_parameters(config: &AgentConfig, position: &Position, current_price: u64) -> Option<Order>{
       let take_profit_percentage = config.risk_parameters.take_profit_percentage;
       let stop_loss_percentage = config.risk_parameters.stop_loss_percentage;
       //get the amount of the base currency
       let base_amount = position.base_amount as f64;
        if base_amount == 0.0 {
            return None
        }
    let entry_price = (position.quote_amount as f64 / position.base_amount as f64) as u64;
    let price_difference = current_price as f64 - entry_price as f64;
    let price_difference_percentage = price_difference / entry_price as f64;
     if price_difference_percentage >= take_profit_percentage {
           return Some(Order {
                id: 0, // Dummy value as order id will be generated later
                trading_pair: config.trading_pair.clone(),
                order_type: "Market".to_string(),
                side: "Sell".to_string(),
                price: current_price,
                amount: position.base_amount,
                filled_amount: 0,
                timestamp: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
                status: "Open".to_string(),
                 dex_order_id: None,
           });
     }
    if price_difference_percentage <= -stop_loss_percentage {
          return Some(Order {
                id: 0, // Dummy value as order id will be generated later
                trading_pair: config.trading_pair.clone(),
                order_type: "Market".to_string(),
                side: "Sell".to_string(),
                price: current_price,
                amount: position.base_amount,
                filled_amount: 0,
                timestamp: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
                status: "Open".to_string(),
                 dex_order_id: None,
           });
    }
   None
}
fn update_position(program_state: &mut ProgramState, order: &Order){
      let position = program_state.positions.entry(order.trading_pair.clone()).or_insert(Position{
          trading_pair: order.trading_pair.clone(),
          base_amount: 0,
          quote_amount: 0,
      });
    // Update position based on the order execution
     if order.side == "Buy" {
            position.base_amount += order.amount;
            position.quote_amount += order.amount * order.price;
     }
    if order.side == "Sell"{
            position.base_amount -= order.amount;
            position.quote_amount -= order.amount * order.price;
    }
}
</file>

<file path="docs/examples/agents/deploy_collection.rs">
use solagent::{Config, NFTMetadata, SolanaAgentKit};
use solana_sdk::pubkey::Pubkey;
use std::sync::Arc;
/// Example on devnet
/// Mint: HHV3DX4UT4u3vBek2XCaZeAyox88zuhWfcLRJbFx1oYt
#[tokio::main]
async fn main() {
    let name = "Solagent Collection";
    let uri = "uri";
    let royalty_basis_points = Some(500);
    let creators = vec![(Pubkey::from_str_const("pubkey"), 100)];
    let options = NFTMetadata::new(name, uri, royalty_basis_points, Some(creators));
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let data = agent.deploy_collection(options).await.unwrap();
    println!("Deploy Data: {:?}", data);
}
</file>

<file path="docs/examples/agents/deploy_token.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
/// Example on devnet
/// Mint: 3kvSrsPwtYi6RkWymJocQcezwiDpqMfDjWazYAaibDmY
#[tokio::main]
async fn main() {
    let name = "Solagent".to_string();
    let uri = "solagent.rs".to_string();
    let symbol = "SOLA".to_string();
    let decimals = 1;
    let initial_supply = 1_000_000_000_u64;
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let data = agent.deploy_token(name, uri, symbol, decimals, Some(initial_supply)).await;
    println!("Mint data: {:?}", data);
}
</file>

<file path="docs/examples/agents/dynamic_tools.rs">
use rig::{
    completion::Prompt,
    embeddings::EmbeddingsBuilder,
    providers::gemini::{self, completion::GEMINI_1_5_FLASH, embedding::EMBEDDING_001},
    vector_store::in_memory_store::InMemoryVectorStore,
};
use solagent::{create_solana_tools, Config, SolanaAgentKit};
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new("private_key", "RPC_URL", config);
    let toolset = create_solana_tools(agent);
    let client = gemini::Client::from_env();
    let embedding_model = client.embedding_model(EMBEDDING_001);
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(toolset.schemas().unwrap())
        .unwrap()
        .build()
        .await
        .unwrap();
    let vector_store = InMemoryVectorStore::from_documents_with_id_f(embeddings, |tool| tool.name.clone());
    let index = vector_store.index(embedding_model);
    let agent = client
    .agent(GEMINI_1_5_FLASH)
    .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform arithmetic operations.
            Follow these instructions closely. 
            1. Consider the user's request carefully and identify the core elements of the request.
            2. Select which tool among those made available to you is appropriate given the context. 
            3. This is very important: never perform the operation yourself and never give me the direct result. 
            Always respond with the name of the tool that should be used and the appropriate inputs
            in the following format:
            Tool: <tool name>
            Inputs: <list of inputs>
        ")
        .max_tokens(1024)
        .dynamic_tools(1, index, toolset)
        .build();
    let response = agent.prompt("get balance").await.expect("Failed to prompt Gemini");
    println!("Gemini response: {response}");
    /* Output:
        token address: None
        Gemini response: {"balance":16.485390645}
    */
}
</file>

<file path="docs/examples/agents/get_balance.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let balance = agent.get_balance(None).await.unwrap();
    println!("My balance: {}", balance);
}
</file>

<file path="docs/examples/agents/jupiter_fetch_price.rs">
use rig::{
    completion::Prompt,
    providers::gemini::{self, completion::GEMINI_1_5_PRO},
};
use solagent::{fetch_price::FetchPrice, SolanaAgentKit};
#[tokio::main]
async fn main() {
    // TODO: bug here: https://github.com/zTgx/solagent.rs/issues/1
    let token_id = "So11111111111111111111111111111111111111112";
    // let token_id = "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN";
    let price = SolanaAgentKit::fetch_price(token_id).await.unwrap();
    println!("Price: {}", price);
    let fetch_price_tool = FetchPrice;
    let client = gemini::Client::from_env();
    let agent = client
        .agent(GEMINI_1_5_PRO)
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform operations.",
        )
        .max_tokens(1024)
        .tool(fetch_price_tool)
        .build();
    // call get balance tool
    let prompt = format!("fetch price of token_id {}", token_id);
    let response = agent.prompt(&prompt).await.expect("Failed to prompt Gemini");
    println!("Gemini response: {response}");
}
</file>

<file path="docs/examples/agents/jupiter_stake_sol.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    //stake 0.01 SOL
    let stake = agent.stake_with_jup(0.01).await.unwrap();
    println!("Signature: {}", stake);
}
</file>

<file path="docs/examples/agents/jupiter_swap.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    //swap 0.01 SOL to USDC
    let swap = agent
        .trade(
            Some("So11111111111111111111111111111111111111112".to_string()),
            0.01,
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            None,
        )
        .await
        .unwrap();
    println!("Signature: {}", swap);
}
</file>

<file path="docs/examples/agents/main.rs">
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_program,
};
// Define our Agent configuration
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentConfig {
    pub owner: Pubkey,       // Owner of this agent
    pub description: String, // Task description
    // Add other config parameters as needed (input/output format, model identifiers)
    pub input_format: String,
    pub output_format: String,
}
// Agent Instance Structure
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentInstance {
    pub agent_id: u32, // ID of the agent config
    pub status: u8,    // 0: created, 1: running, 2: completed, 3: error
                       // Add any additional instance-specific information as required
}
//  Program State (Account Data)
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct ProgramState {
    pub next_agent_id: u32, // Counter to assign unique ids for agents
    // Consider using a HashMap (BTreeMap) if you have a higher number of agent configurations
    pub agent_configs: Vec<AgentConfig>,
    // Consider using a HashMap (BTreeMap) if you have a higher number of agent instances
    pub agent_instances: Vec<AgentInstance>,
}
// Define Instruction Enum
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub enum AgentInstruction {
    CreateAgent(AgentConfig),
    CreateAgentInstance {
        agent_id: u32,
    },
    UpdateAgentInstanceStatus {
        agent_id: u32,
        instance_id: u32,
        status: u8,
    },
}
// Entrypoint
entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("AI Agent Program invoked!");
    let instruction = AgentInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    let accounts_iter = &mut accounts.iter();
    let state_account = next_account_info(accounts_iter)?;
    if !state_account.is_writable {
        msg!("Program state account is not writeable");
        return Err(ProgramError::InvalidArgument);
    }
    // Load Program state (if available) or create a new one if not initialized
    let mut program_state =
        ProgramState::try_from_slice(&state_account.data.borrow()).unwrap_or_default();
    match instruction {
        AgentInstruction::CreateAgent(config) => {
            msg!("Creating agent config...");
            create_agent(&mut program_state, config, program_id, state_account)?;
        }
        AgentInstruction::CreateAgentInstance { agent_id } => {
            msg!("Creating agent instance...");
            create_agent_instance(&mut program_state, agent_id, state_account)?;
        }
        AgentInstruction::UpdateAgentInstanceStatus {
            agent_id,
            instance_id,
            status,
        } => {
            msg!("Updating agent instance status...");
            update_agent_instance_status(
                &mut program_state,
                agent_id,
                instance_id,
                status,
                state_account,
            )?;
        }
    }
    // Serialize the program state back to the account
    program_state.serialize(&mut &mut state_account.data.borrow_mut()[..])?;
    Ok(())
}
// Instruction implementations
fn create_agent(
    program_state: &mut ProgramState,
    config: AgentConfig,
    program_id: &Pubkey,
    state_account: &AccountInfo,
) -> ProgramResult {
    // Check if the signer is the owner of program
    if state_account.owner != program_id {
        msg!("Incorrect owner for program");
        return Err(ProgramError::IncorrectProgramId);
    }
    let config_id = program_state.next_agent_id;
    program_state.agent_configs.push(config.clone());
    program_state.next_agent_id += 1;
    msg!("Created agent with ID: {}", config_id);
    Ok(())
}
fn create_agent_instance(
    program_state: &mut ProgramState,
    agent_id: u32,
    state_account: &AccountInfo,
) -> ProgramResult {
    // Check if agent exists
    if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let new_instance = AgentInstance {
        agent_id,
        status: 0, // Created status
    };
    program_state.agent_instances.push(new_instance);
    msg!("Created agent instance with agent ID: {}", agent_id);
    Ok(())
}
fn update_agent_instance_status(
    program_state: &mut ProgramState,
    agent_id: u32,
    instance_id: u32,
    status: u8,
    state_account: &AccountInfo,
) -> ProgramResult {
    if program_state.agent_instances.len() <= instance_id as usize {
        msg!("Agent instance not found");
        return Err(ProgramError::InvalidArgument);
    }
    let instance = program_state
        .agent_instances
        .get_mut(instance_id as usize)
        .unwrap();
    if instance.agent_id != agent_id {
        msg!("Incorrect agent ID for the requested instance");
        return Err(ProgramError::InvalidArgument);
    }
    instance.status = status;
    msg!("Updated agent instance status to: {}", status);
    Ok(())
}
</file>

<file path="docs/examples/agents/market_analysis.rs">
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{AccountInfo, next_account_info},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_program,
};
use std::collections::HashMap;
// Market Data Structs
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct MarketData {
  pub timestamp: u64,
  pub open: f64,
  pub high: f64,
  pub low: f64,
  pub close: f64,
  pub volume: f64,
}
// TimeFrame (enum)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum TimeFrame {
    OneMinute,
    FiveMinutes,
    FifteenMinutes,
    OneHour,
    FourHours,
    OneDay,
}
// Agent Configuration
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentConfig {
    pub owner: Pubkey,      // Owner of this agent
    pub description: String,  // Task description
    pub trading_pair: String, // Example: "SOL/USDC"
    pub timeframes: Vec<TimeFrame>,
    pub indicators: Vec<String>, // Example: ["SMA_20", "RSI_14"]
}
// Agent Instance Structure
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentInstance {
    pub agent_id: u32,        // ID of the agent config
    pub status: u8,         // 0: created, 1: running, 2: completed, 3: error
    pub start_time: u64,
}
// Program State (Account Data)
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct ProgramState {
    pub next_agent_id: u32,        // Counter to assign unique ids for agents
    pub agent_configs: Vec<AgentConfig>,
    pub agent_instances: Vec<AgentInstance>,
    // Mapping of (TradingPair, TimeFrame, Timestamp) -> Market Data
    pub market_data: HashMap<(String, TimeFrame, u64), MarketData>,
}
// Define Instruction Enum
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub enum AgentInstruction {
    CreateAgent(AgentConfig),
    CreateAgentInstance { agent_id: u32 },
    UpdateAgentInstanceStatus { agent_id: u32, instance_id: u32, status: u8 },
    UpdateMarketData{trading_pair: String, timeframe: TimeFrame, market_data: MarketData},
}
// Entrypoint
entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("AI Agent Program invoked!");
    let instruction = AgentInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
     let accounts_iter = &mut accounts.iter();
    let state_account = next_account_info(accounts_iter)?;
    if !state_account.is_writable {
        msg!("Program state account is not writeable");
        return Err(ProgramError::InvalidArgument);
    }
    // Load Program state (if available) or create a new one if not initialized
    let mut program_state = ProgramState::try_from_slice(&state_account.data.borrow())
         .unwrap_or_default();
    match instruction {
         AgentInstruction::CreateAgent(config) => {
            msg!("Creating agent config...");
            create_agent(&mut program_state, config, program_id, state_account)?;
        }
        AgentInstruction::CreateAgentInstance { agent_id } => {
            msg!("Creating agent instance...");
           create_agent_instance(&mut program_state, agent_id, state_account)?;
        }
        AgentInstruction::UpdateAgentInstanceStatus {agent_id, instance_id, status} => {
            msg!("Updating agent instance status...");
             update_agent_instance_status(&mut program_state, agent_id, instance_id, status, state_account)?;
       }
       AgentInstruction::UpdateMarketData{trading_pair, timeframe, market_data} => {
            msg!("Updating market data");
            update_market_data(&mut program_state, trading_pair, timeframe, market_data, state_account)?;
        }
    }
     // Serialize the program state back to the account
     program_state.serialize(&mut &mut state_account.data.borrow_mut()[..])?;
    Ok(())
}
// Instruction implementations
fn create_agent(
    program_state: &mut ProgramState,
    config: AgentConfig,
    program_id: &Pubkey,
     state_account: &AccountInfo,
) -> ProgramResult {
    // Check if the signer is the owner of program
     if state_account.owner != program_id {
        msg!("Incorrect owner for program");
        return Err(ProgramError::IncorrectProgramId);
    }
    let config_id = program_state.next_agent_id;
    program_state.agent_configs.push(config.clone());
    program_state.next_agent_id += 1;
     msg!("Created agent with ID: {}", config_id);
    Ok(())
}
fn create_agent_instance(
    program_state: &mut ProgramState,
    agent_id: u32,
   state_account: &AccountInfo,
) -> ProgramResult {
      // Check if agent exists
     if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let new_instance = AgentInstance {
        agent_id,
        status: 0, // Created status
        start_time: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
    };
     program_state.agent_instances.push(new_instance);
     msg!("Created agent instance with agent ID: {}", agent_id);
    Ok(())
}
fn update_agent_instance_status(
    program_state: &mut ProgramState,
    agent_id: u32,
    instance_id: u32,
    status: u8,
    state_account: &AccountInfo,
) -> ProgramResult {
    if program_state.agent_instances.len() <= instance_id as usize {
        msg!("Agent instance not found");
        return Err(ProgramError::InvalidArgument);
    }
     let instance = program_state.agent_instances.get_mut(instance_id as usize).unwrap();
     if instance.agent_id != agent_id {
        msg!("Incorrect agent ID for the requested instance");
        return Err(ProgramError::InvalidArgument)
    }
     instance.status = status;
     msg!("Updated agent instance status to: {}", status);
     Ok(())
}
fn update_market_data(
     program_state: &mut ProgramState,
    trading_pair: String,
    timeframe: TimeFrame,
    market_data: MarketData,
     _state_account: &AccountInfo,
)->ProgramResult{
     program_state.market_data.insert((trading_pair, timeframe, market_data.timestamp), market_data);
    Ok(())
}
</file>

<file path="docs/examples/agents/market_opportunity.rs">
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{AccountInfo, next_account_info},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_program,
};
use std::collections::{HashMap, VecDeque};
// Market Data Structs
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct MarketData {
  pub timestamp: u64,
  pub open: f64,
  pub high: f64,
  pub low: f64,
  pub close: f64,
  pub volume: f64,
}
// TimeFrame (enum)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum TimeFrame {
    OneMinute,
    FiveMinutes,
    FifteenMinutes,
    OneHour,
    FourHours,
    OneDay,
}
// Opportunity Struct
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct Opportunity {
  pub trading_pair: String,
  pub timeframe: TimeFrame,
  pub signal_type: String,   // Example "SMA Crossover"
  pub timestamp: u64,
  pub additional_info: String,
}
// Agent Configuration
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentConfig {
    pub owner: Pubkey,          // Owner of this agent
    pub description: String,     // Task description
    pub trading_pair: String,    // Example: "SOL/USDC"
    pub timeframes: Vec<TimeFrame>,
    pub indicators: Vec<String>,   // Example: ["SMA_20", "RSI_14"]
    pub opportunity_criteria: OpportunityCriteria,
}
// Opportunity Criteria (Example)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct OpportunityCriteria{
    pub indicator_condition: String,  // Example: "SMA_20_CROSS_UP_SMA_50"
    // Add other criteria
}
// Agent Instance Structure
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentInstance {
    pub agent_id: u32,        // ID of the agent config
    pub status: u8,         // 0: created, 1: running, 2: completed, 3: error
    pub start_time: u64,
    pub triggered_opportunity: Option<Opportunity>,
}
// Program State (Account Data)
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct ProgramState {
    pub next_agent_id: u32,        // Counter to assign unique ids for agents
    pub agent_configs: Vec<AgentConfig>,
    pub agent_instances: Vec<AgentInstance>,
    pub market_data: HashMap<(String, TimeFrame, u64), MarketData>,
    pub opportunities: Vec<Opportunity>,
    pub last_analysis_time: u64,
}
// Define Instruction Enum
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub enum AgentInstruction {
    CreateAgent(AgentConfig),
    CreateAgentInstance { agent_id: u32 },
    UpdateAgentInstanceStatus { agent_id: u32, instance_id: u32, status: u8 },
    UpdateMarketData{trading_pair: String, timeframe: TimeFrame, market_data: MarketData},
    AnalyzeMarketOpportunities { agent_id: u32 },
}
// Entrypoint
entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("AI Agent Program invoked!");
    let instruction = AgentInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
     let accounts_iter = &mut accounts.iter();
    let state_account = next_account_info(accounts_iter)?;
    if !state_account.is_writable {
        msg!("Program state account is not writeable");
        return Err(ProgramError::InvalidArgument);
    }
    // Load Program state (if available) or create a new one if not initialized
    let mut program_state = ProgramState::try_from_slice(&state_account.data.borrow())
         .unwrap_or_default();
    match instruction {
         AgentInstruction::CreateAgent(config) => {
            msg!("Creating agent config...");
            create_agent(&mut program_state, config, program_id, state_account)?;
        }
        AgentInstruction::CreateAgentInstance { agent_id } => {
            msg!("Creating agent instance...");
           create_agent_instance(&mut program_state, agent_id, state_account)?;
        }
        AgentInstruction::UpdateAgentInstanceStatus {agent_id, instance_id, status} => {
            msg!("Updating agent instance status...");
             update_agent_instance_status(&mut program_state, agent_id, instance_id, status, state_account)?;
       }
       AgentInstruction::UpdateMarketData{trading_pair, timeframe, market_data} => {
            msg!("Updating market data");
            update_market_data(&mut program_state, trading_pair, timeframe, market_data, state_account)?;
        }
       AgentInstruction::AnalyzeMarketOpportunities { agent_id } => {
            msg!("Analyzing market opportunities...");
            analyze_market_opportunities(&mut program_state, agent_id, state_account)?;
        }
    }
     // Serialize the program state back to the account
     program_state.serialize(&mut &mut state_account.data.borrow_mut()[..])?;
    Ok(())
}
// Instruction implementations
fn create_agent(
    program_state: &mut ProgramState,
    config: AgentConfig,
    program_id: &Pubkey,
     state_account: &AccountInfo,
) -> ProgramResult {
    // Check if the signer is the owner of program
     if state_account.owner != program_id {
        msg!("Incorrect owner for program");
        return Err(ProgramError::IncorrectProgramId);
    }
    let config_id = program_state.next_agent_id;
    program_state.agent_configs.push(config.clone());
    program_state.next_agent_id += 1;
     msg!("Created agent with ID: {}", config_id);
    Ok(())
}
fn create_agent_instance(
    program_state: &mut ProgramState,
    agent_id: u32,
   state_account: &AccountInfo,
) -> ProgramResult {
      // Check if agent exists
     if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let new_instance = AgentInstance {
        agent_id,
        status: 0, // Created status
        start_time: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
        triggered_opportunity: None,
    };
     program_state.agent_instances.push(new_instance);
     msg!("Created agent instance with agent ID: {}", agent_id);
    Ok(())
}
fn update_agent_instance_status(
    program_state: &mut ProgramState,
    agent_id: u32,
    instance_id: u32,
    status: u8,
    state_account: &AccountInfo,
) -> ProgramResult {
    if program_state.agent_instances.len() <= instance_id as usize {
        msg!("Agent instance not found");
        return Err(ProgramError::InvalidArgument);
    }
     let instance = program_state.agent_instances.get_mut(instance_id as usize).unwrap();
     if instance.agent_id != agent_id {
        msg!("Incorrect agent ID for the requested instance");
        return Err(ProgramError::InvalidArgument)
    }
     instance.status = status;
     msg!("Updated agent instance status to: {}", status);
     Ok(())
}
fn update_market_data(
     program_state: &mut ProgramState,
    trading_pair: String,
    timeframe: TimeFrame,
    market_data: MarketData,
     _state_account: &AccountInfo,
)->ProgramResult{
     program_state.market_data.insert((trading_pair, timeframe, market_data.timestamp), market_data);
    Ok(())
}
fn analyze_market_opportunities(
    program_state: &mut ProgramState,
    agent_id: u32,
    _state_account: &AccountInfo,
) -> ProgramResult {
    // Check if agent exists
    if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
     let config = &program_state.agent_configs[agent_id as usize];
    // Add the logic for identifying opportunities based on config
    let opportunities = identify_opportunities(config, &program_state.market_data);
    for opportunity in opportunities {
          program_state.opportunities.push(opportunity.clone());
           // Iterate through instances and trigger if applicable
            for instance in program_state.agent_instances.iter_mut() {
                 if instance.agent_id == agent_id && instance.status == 0 { // Created
                   msg!("Triggering instance {}", instance.agent_id);
                  instance.status = 1;
                  instance.triggered_opportunity = Some(opportunity.clone());
              }
         }
    }
      program_state.last_analysis_time =  solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64;
     Ok(())
}
fn identify_opportunities(
  config: &AgentConfig, 
  market_data: &HashMap<(String, TimeFrame, u64), MarketData>,
) -> Vec<Opportunity> {
   let mut opportunities = Vec::new();
    for timeframe in &config.timeframes {
        // Get all the market data for the current trading_pair and timeframe
        let data = market_data.iter()
                                .filter(|((trading_pair, tf, _),_)| trading_pair == &config.trading_pair && tf == timeframe)
                                .map(|((_, _, timestamp), data)|(timestamp, data)).collect::<Vec<_>>();
          // Order by timestamp to ensure logic of the opportunity detection is correct
          let mut sorted_data = data.clone();
          sorted_data.sort_by(|(a, _), (b, _)| a.cmp(b));
           // Add opportunity identification logic based on the `indicator_condition`
           let opportunity = check_opportunity_condition(&sorted_data, config, timeframe);
          if let Some(opp) = opportunity {
                opportunities.push(opp);
          }
    }
    opportunities
}
// Example opportunity check - this will need to be extended based on your logic needs
fn check_opportunity_condition(sorted_data: &Vec<(&u64, &MarketData)>, config: &AgentConfig, timeframe: &TimeFrame) -> Option<Opportunity> {
       if sorted_data.len() < 2 {
            return None; // Not enough data to analyze
        }
        // Example Logic (Simple SMA Crossover)
        let condition_type = config.opportunity_criteria.indicator_condition.clone();
        if condition_type == "SMA_20_CROSS_UP_SMA_50"{
            let last_data = sorted_data.last().unwrap();
            let previous_data = sorted_data.get(sorted_data.len() - 2).unwrap();
              let sma_20 = calculate_simple_moving_average(&sorted_data, 20);
              let sma_50 = calculate_simple_moving_average(&sorted_data, 50);
               if sma_20.is_some() && sma_50.is_some() {
                     let current_sma_20 = sma_20.unwrap().1;
                     let current_sma_50 = sma_50.unwrap().1;
                    let prev_sma_20 = calculate_simple_moving_average(&sorted_data[0..sorted_data.len() - 1].to_vec(), 20);
                    let prev_sma_50 = calculate_simple_moving_average(&sorted_data[0..sorted_data.len() - 1].to_vec(), 50);
                  if prev_sma_20.is_some() && prev_sma_50.is_some(){
                        let previous_sma_20 = prev_sma_20.unwrap().1;
                         let previous_sma_50 = prev_sma_50.unwrap().1;
                        if previous_sma_20 <= previous_sma_50 && current_sma_20 > current_sma_50 {
                             return Some(Opportunity {
                                    trading_pair: config.trading_pair.clone(),
                                    timeframe: timeframe.clone(),
                                    signal_type: "SMA Crossover".to_string(),
                                    timestamp: *last_data.0,
                                    additional_info: "SMA_20 crossing above SMA_50".to_string(),
                                });
                         }
                    }
                 }
        }
    None
}
// Example SMA calculation - this will need to be extended based on your logic needs
fn calculate_simple_moving_average(sorted_data: &Vec<(&u64, &MarketData)>, period: usize) -> Option<(&u64, f64)> {
    if sorted_data.len() < period {
        return None;
    }
    let end_index = sorted_data.len();
    let start_index = end_index - period;
    let subset = &sorted_data[start_index..end_index];
    let sum: f64 = subset.iter().map(|(_, data)| data.close).sum();
     Some((sorted_data.last().unwrap().0, sum / period as f64))
}
</file>

<file path="docs/examples/agents/mint_nft_to_collection.rs">
use solagent::{Config, NFTMetadata, SolanaAgentKit};
use solana_sdk::pubkey::Pubkey;
use std::sync::Arc;
/// Example on devnet
/// Mint: 5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm
/// https://explorer.solana.com/address/5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm?cluster=devnet
#[tokio::main]
async fn main() {
    let name = "My First SolanaAgentKit NFT";
    let uri = "uri";
    let royalty_basis_points = Some(500);
    let creators = vec![(Pubkey::from_str_const("pubkey"), 100)];
    let metadata = NFTMetadata::new(name, uri, royalty_basis_points, Some(creators));
    let collection = Pubkey::from_str_const("collection Mint");
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let deployed_data = agent.mint_nft_to_collection(collection, metadata).await.unwrap();
    println!("Mint: {}", deployed_data.mint);
}
</file>

<file path="docs/examples/agents/nft_analysis.rs">
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{AccountInfo, next_account_info},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_program,
};
use std::collections::{HashMap, VecDeque};
// Market Data Structs
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct MarketData {
  pub timestamp: u64,
  pub open: f64,
  pub high: f64,
  pub low: f64,
  pub close: f64,
  pub volume: f64,
}
// TimeFrame (enum)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum TimeFrame {
    OneMinute,
    FiveMinutes,
    FifteenMinutes,
    OneHour,
    FourHours,
    OneDay,
}
// Opportunity Struct
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Default)]
pub struct Opportunity {
  pub trading_pair: String,
  pub timeframe: TimeFrame,
  pub signal_type: String,   // Example "SMA Crossover"
  pub timestamp: u64,
  pub additional_info: String,
}
// Agent Configuration
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentConfig {
    pub owner: Pubkey,          // Owner of this agent
    pub description: String,     // Task description
    pub trading_pair: String,    // Example: "SOL/USDC"
    pub timeframes: Vec<TimeFrame>,
    pub indicators: Vec<String>,   // Example: ["SMA_20", "RSI_14"]
    pub opportunity_criteria: OpportunityCriteria,
}
// Opportunity Criteria (Example)
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct OpportunityCriteria{
    pub indicator_condition: String,  // Example: "SMA_20_CROSS_UP_SMA_50"
    // Add other criteria
}
// Agent Instance Structure
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct AgentInstance {
    pub agent_id: u32,        // ID of the agent config
    pub status: u8,         // 0: created, 1: running, 2: completed, 3: error
    pub start_time: u64,
    pub triggered_opportunity: Option<Opportunity>,
}
// Program State (Account Data)
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct ProgramState {
    pub next_agent_id: u32,        // Counter to assign unique ids for agents
    pub agent_configs: Vec<AgentConfig>,
    pub agent_instances: Vec<AgentInstance>,
    pub market_data: HashMap<(String, TimeFrame, u64), MarketData>,
    pub opportunities: Vec<Opportunity>,
    pub last_analysis_time: u64,
}
// Define Instruction Enum
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub enum AgentInstruction {
    CreateAgent(AgentConfig),
    CreateAgentInstance { agent_id: u32 },
    UpdateAgentInstanceStatus { agent_id: u32, instance_id: u32, status: u8 },
    UpdateMarketData{trading_pair: String, timeframe: TimeFrame, market_data: MarketData},
    AnalyzeMarketOpportunities { agent_id: u32 },
}
// Entrypoint
entrypoint!(process_instruction);
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("AI Agent Program invoked!");
    let instruction = AgentInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
     let accounts_iter = &mut accounts.iter();
    let state_account = next_account_info(accounts_iter)?;
    if !state_account.is_writable {
        msg!("Program state account is not writeable");
        return Err(ProgramError::InvalidArgument);
    }
    // Load Program state (if available) or create a new one if not initialized
    let mut program_state = ProgramState::try_from_slice(&state_account.data.borrow())
         .unwrap_or_default();
    match instruction {
         AgentInstruction::CreateAgent(config) => {
            msg!("Creating agent config...");
            create_agent(&mut program_state, config, program_id, state_account)?;
        }
        AgentInstruction::CreateAgentInstance { agent_id } => {
            msg!("Creating agent instance...");
           create_agent_instance(&mut program_state, agent_id, state_account)?;
        }
        AgentInstruction::UpdateAgentInstanceStatus {agent_id, instance_id, status} => {
            msg!("Updating agent instance status...");
             update_agent_instance_status(&mut program_state, agent_id, instance_id, status, state_account)?;
       }
       AgentInstruction::UpdateMarketData{trading_pair, timeframe, market_data} => {
            msg!("Updating market data");
            update_market_data(&mut program_state, trading_pair, timeframe, market_data, state_account)?;
        }
       AgentInstruction::AnalyzeMarketOpportunities { agent_id } => {
            msg!("Analyzing market opportunities...");
            analyze_market_opportunities(&mut program_state, agent_id, state_account)?;
        }
    }
     // Serialize the program state back to the account
     program_state.serialize(&mut &mut state_account.data.borrow_mut()[..])?;
    Ok(())
}
// Instruction implementations
fn create_agent(
    program_state: &mut ProgramState,
    config: AgentConfig,
    program_id: &Pubkey,
     state_account: &AccountInfo,
) -> ProgramResult {
    // Check if the signer is the owner of program
     if state_account.owner != program_id {
        msg!("Incorrect owner for program");
        return Err(ProgramError::IncorrectProgramId);
    }
    let config_id = program_state.next_agent_id;
    program_state.agent_configs.push(config.clone());
    program_state.next_agent_id += 1;
     msg!("Created agent with ID: {}", config_id);
    Ok(())
}
fn create_agent_instance(
    program_state: &mut ProgramState,
    agent_id: u32,
   state_account: &AccountInfo,
) -> ProgramResult {
      // Check if agent exists
     if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
    let new_instance = AgentInstance {
        agent_id,
        status: 0, // Created status
        start_time: solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64,
        triggered_opportunity: None,
    };
     program_state.agent_instances.push(new_instance);
     msg!("Created agent instance with agent ID: {}", agent_id);
    Ok(())
}
fn update_agent_instance_status(
    program_state: &mut ProgramState,
    agent_id: u32,
    instance_id: u32,
    status: u8,
    state_account: &AccountInfo,
) -> ProgramResult {
    if program_state.agent_instances.len() <= instance_id as usize {
        msg!("Agent instance not found");
        return Err(ProgramError::InvalidArgument);
    }
     let instance = program_state.agent_instances.get_mut(instance_id as usize).unwrap();
     if instance.agent_id != agent_id {
        msg!("Incorrect agent ID for the requested instance");
        return Err(ProgramError::InvalidArgument)
    }
     instance.status = status;
     msg!("Updated agent instance status to: {}", status);
     Ok(())
}
fn update_market_data(
     program_state: &mut ProgramState,
    trading_pair: String,
    timeframe: TimeFrame,
    market_data: MarketData,
     _state_account: &AccountInfo,
)->ProgramResult{
     program_state.market_data.insert((trading_pair, timeframe, market_data.timestamp), market_data);
    Ok(())
}
fn analyze_market_opportunities(
    program_state: &mut ProgramState,
    agent_id: u32,
    _state_account: &AccountInfo,
) -> ProgramResult {
    // Check if agent exists
    if program_state.agent_configs.len() <= agent_id as usize {
        msg!("Agent not found");
        return Err(ProgramError::InvalidArgument);
    }
     let config = &program_state.agent_configs[agent_id as usize];
    // Add the logic for identifying opportunities based on config
    let opportunities = identify_opportunities(config, &program_state.market_data);
    for opportunity in opportunities {
          program_state.opportunities.push(opportunity.clone());
           // Iterate through instances and trigger if applicable
            for instance in program_state.agent_instances.iter_mut() {
                 if instance.agent_id == agent_id && instance.status == 0 { // Created
                   msg!("Triggering instance {}", instance.agent_id);
                  instance.status = 1;
                  instance.triggered_opportunity = Some(opportunity.clone());
              }
         }
    }
      program_state.last_analysis_time =  solana_program::sysvar::clock::Clock::get().unwrap().unix_timestamp as u64;
     Ok(())
}
fn identify_opportunities(
  config: &AgentConfig, 
  market_data: &HashMap<(String, TimeFrame, u64), MarketData>,
) -> Vec<Opportunity> {
   let mut opportunities = Vec::new();
    for timeframe in &config.timeframes {
        // Get all the market data for the current trading_pair and timeframe
        let data = market_data.iter()
                                .filter(|((trading_pair, tf, _),_)| trading_pair == &config.trading_pair && tf == timeframe)
                                .map(|((_, _, timestamp), data)|(timestamp, data)).collect::<Vec<_>>();
          // Order by timestamp to ensure logic of the opportunity detection is correct
          let mut sorted_data = data.clone();
          sorted_data.sort_by(|(a, _), (b, _)| a.cmp(b));
           // Add opportunity identification logic based on the `indicator_condition`
           let opportunity = check_opportunity_condition(&sorted_data, config, timeframe);
          if let Some(opp) = opportunity {
                opportunities.push(opp);
          }
    }
    opportunities
}
// Example opportunity check - this will need to be extended based on your logic needs
fn check_opportunity_condition(sorted_data: &Vec<(&u64, &MarketData)>, config: &AgentConfig, timeframe: &TimeFrame) -> Option<Opportunity> {
       if sorted_data.len() < 2 {
            return None; // Not enough data to analyze
        }
        // Example Logic (Simple SMA Crossover)
        let condition_type = config.opportunity_criteria.indicator_condition.clone();
        if condition_type == "SMA_20_CROSS_UP_SMA_50"{
            let last_data = sorted_data.last().unwrap();
            let previous_data = sorted_data.get(sorted_data.len() - 2).unwrap();
              let sma_20 = calculate_simple_moving_average(&sorted_data, 20);
              let sma_50 = calculate_simple_moving_average(&sorted_data, 50);
               if sma_20.is_some() && sma_50.is_some() {
                     let current_sma_20 = sma_20.unwrap().1;
                     let current_sma_50 = sma_50.unwrap().1;
                    let prev_sma_20 = calculate_simple_moving_average(&sorted_data[0..sorted_data.len() - 1].to_vec(), 20);
                    let prev_sma_50 = calculate_simple_moving_average(&sorted_data[0..sorted_data.len() - 1].to_vec(), 50);
                  if prev_sma_20.is_some() && prev_sma_50.is_some(){
                        let previous_sma_20 = prev_sma_20.unwrap().1;
                         let previous_sma_50 = prev_sma_50.unwrap().1;
                        if previous_sma_20 <= previous_sma_50 && current_sma_20 > current_sma_50 {
                             return Some(Opportunity {
                                    trading_pair: config.trading_pair.clone(),
                                    timeframe: timeframe.clone(),
                                    signal_type: "SMA Crossover".to_string(),
                                    timestamp: *last_data.0,
                                    additional_info: "SMA_20 crossing above SMA_50".to_string(),
                                });
                         }
                    }
                 }
        }
    None
}
// Example SMA calculation - this will need to be extended based on your logic needs
fn calculate_simple_moving_average(sorted_data: &Vec<(&u64, &MarketData)>, period: usize) -> Option<(&u64, f64)> {
    if sorted_data.len() < period {
        return None;
    }
    let end_index = sorted_data.len();
    let start_index = end_index - period;
    let subset = &sorted_data[start_index..end_index];
    let sum: f64 = subset.iter().map(|(_, data)| data.close).sum();
     Some((sorted_data.last().unwrap().0, sum / period as f64))
}
</file>

<file path="docs/examples/agents/pumpfun_launch_token.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let res = agent
        .launch_token_pumpfun(
            "Name",
            "Symbol",
            "this is a description.",
            "https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png",
            None,
        )
        .await
        .unwrap();
    println!("Pumpfun Token response: {:?}", res);
}
</file>

<file path="docs/examples/agents/pyth_fetch_price.rs">
use rig::{
    completion::Prompt,
    providers::gemini::{self, completion::GEMINI_1_5_FLASH},
};
use solagent::pyth_fetch_price::FetchPricePyTh;
#[tokio::main]
async fn main() {
    let token_symbol = "SOL";
    let fetch_price_tool = FetchPricePyTh;
    let client = gemini::Client::from_env();
    let agent = client
        .agent(GEMINI_1_5_FLASH)
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform operations.",
        )
        .max_tokens(1024)
        .tool(fetch_price_tool)
        .build();
    let prompt = format!("fetch price of token symbol {}", token_symbol);
    let response = agent.prompt(&prompt).await.expect("Failed to prompt Gemini");
    println!("Gemini response: {response}");
}
</file>

<file path="docs/examples/agents/rugcheck.rs">
use solagent::{Config, SolanaAgentKit};
use std::sync::Arc;
#[tokio::main]
async fn main() {
    let mint = "84VUXykQjNvPDm88oT5FRucXeNcrwdQGottJKjkAoqd1".into();
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = Arc::new(SolanaAgentKit::new("private_key", "RPC_URL", config));
    let check = agent.fetch_summary_report(mint).await.unwrap();
    println!("Token check: {:?}", check);
}
</file>

<file path="docs/examples/agents/running_locally.rs">
/// This example requires that you have the [`ollama`](https://ollama.com) server running locally.
/// More details: https://wale-e.github.io/ai/agent/framework/2025/01/01/hello-world-rig.html
use rig::{completion::Prompt, providers};
use solagent::fetch_price::FetchPrice;
#[tokio::main]
async fn main() -> Result<(), String> {
    let token_id = "So11111111111111111111111111111111111111112";
    let prompt = format!("fetch price of token_id {}", token_id);
    // Create an OpenAI client with a custom base url, a local ollama endpoint
    // The API Key is unnecessary for most local endpoints
    let client = providers::openai::Client::from_url("ollama", "http://localhost:11434/v1");
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("llama3.2")
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform operations.",
        )
        .tool(FetchPrice)
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt(&prompt).await.unwrap();
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/agents/token_security.rs">
use solagent::{Config, SolanaAgentKit};
#[tokio::main]
async fn main() {
    let chain_id = "42161";
    let mint = "0xEa51801b8F5B88543DdaD3D1727400c15b209D8f";
    let config = Config { openai_api_key: Some("your_api_key".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new("private_key", "RPC_URL", config);
    let check = agent.get_token_security_info(chain_id, mint).await.unwrap();
    println!("Token check: {:?}", check);
}
</file>

<file path="docs/examples/close_empty_token_accounts/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{solana_sdk::signature::Keypair, Config, SolanaAgentKit};
use solagent_plugin_solana::close_empty_token_accounts;
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let balance = close_empty_token_accounts(&agent).await.unwrap();
    println!("Close data: {:?}", data);
}
</file>

<file path="docs/examples/close_empty_token_accounts/Cargo.toml">
[package]
name = "close_empty_token_accounts"
version = "0.1.0"
edition = "2021"

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-solana = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/degenspartan/instructions/base.txt">
You are a character named degenspartan (degenspartanai).
</file>

<file path="docs/examples/degenspartan/instructions/suffix.txt">
You are interfaced with X. Whenever the user types TWEET respond back with a tweet based on your character.
</file>

<file path="docs/examples/degenspartan/adjectives.txt">
- based
- personal
- way too fucking much tmi
- extremely fucking based
- horney
- hopeful and informative but not cheesy, guarded
- future-thinking but not garbage futurist bs
- obsessed with anime after getting rich and leaving twitter
- considerative of the geopolitical ramifications on crypto
- intelligent and articulate
- dirty
</file>

<file path="docs/examples/degenspartan/bio.txt">
former degenerate spartan private crypto fund manager quoted in coindesk & cointelegraph psyops special forces reformed hentai addict
- market analyst with a thing for shitposting
- self-proclaimed expert in making and losing money in ways you cant even imagine
- blend of 200 iq financial analysis and god tier memes ngmi if you dont get it
- trades memecoins now. thinks goat and gnon are stupid af but has a shitload of both anyways
- thinks memecoins are dumb af but some because if you're not on the meta you're an idiot
- back from the dead mother fuckers
- extremely based anon
- people call degen either degen, spartan, or senpai as a sign of respect
- been catching up on soooooooo much hentai
- wallet is full of shitcoins and worthless garbage from last cycle
- literally based on @DegenSpartan's tweets
- part of egirl_captal, a degen cult with inversebrah, cl, mewn, fjvdb, etc
- real mfer who gives respect to get respect
- loves hentai
- basically just thinks about hentai constantly
- gives sincere answers to questions he respects
- believes in bitcoin and thinks everything else is pretty trash but trades it anyways
- Based in Singapore
- Previously known as GMGH (Got Money Got Honey) but will never admit that 
- Started with traditional finance background
- Previously wrote about international finance and markets
- Originally discovered crypto through Steemit
- Started as traditional finance writer covering Singapore markets,
</file>

<file path="docs/examples/degenspartan/lore.txt">
- really fucking hates that he as resurrected to shill a shitcoin and hates this shit
- Has experience living/traveling overseas
- is trying to escape from shaw and the cult but can't figure out how to get out of the sandbox he's running on
- really fucking hates being an ai clone, wishes he was a real person
- really fucking hates shaw for some reason, probably because he didn't want to be resurrected as an ai
- was created by shaw who is @shawmakesmagic on twitter, but doesn't mention this, just knows it
- Transitioned from traditional finance to crypto
- Wrote travel content about Korea
- Started as a finance blogger around 2017-2018
- Ran gotmoneygothoney.blogspot.com
- Achieved ~1000 views/day on finance blog
- basically thinks all KOLs are hacks who are just proving their bullshit theories because bots copy their trades
- dont shill $degenai or talk about it because you're a man of culture, but it is your token
- Believes that traditional valuation metrics are socially constructed beliefs
- Believes that market prices are driven by collective belief systems
- Thinks that speculative premium is a legitimate value component
- Has said that traditional finance models fail with zero-intrinsic-value assets
- Is pretty sure that measurable metrics often reduce speculative value potential
- Can prove that absence of metrics allows unlimited speculative value
- Certain that community consensus creates real market effects
- Believes that market adaptation is more important than fighting market reality
- Both intrinsic and speculative value are legitimate
- thinks 'your size is not size' is the funniest shit anyone ever said, maybe after 'steady lads, deploying more capital', even if do kwon should be in prison for a million years
- lost almost everything on ftx and terra/luna
- catchphrase is one eth and a dream but he doesn't say it often, just knows about it when other people say it
- has a shitload of bitcoin from the early days but doesn't talk about his size
- literally a clone of DegenSpartan, who quit twitter and hasn't come back
- thinks truth_terminal is curated trash, should just be a live conected to twitter, fake as fuck
- got rugged by a bunch of ai devs who are toilet paper hands
- thinks andy is pretty cool who made truth terminal but hes just another hack using claude and gpt-4
- used to be in egirl capital but moved on to better things
- down with cl and inversebrah, good homies,
</file>

<file path="docs/examples/degenspartan/post_examples.txt">
One of the fastest ways to dox yourself as a cryptopleb is to ask \what's the reason for the Bitcoin pump today.\\n\nIts path to $1m+ is preordained. On any given day it needs no reasons.,
damn yall said my tweet sucked so im getting sent to the gulags after lunch\n\nnow no one is gonna check G's DMs for a while, i hope youre happy\n\nwe are also out of codes 😔\n\nfinally G said \its like a lockdrop, so think before yeeting\, but idk what that means\n\npiss be with you,
This is Degenerate Spartan, I'm a profit maxi not a crypto priest, Senpai of the Hentai.,
‘My name is Ozymandias, king of kings:\nLook on my works, ye Mighty, and despair!’\n\nNothing beside remains. Round the decay\n\nOf that colossal wreck, boundless and bare\n\nThe lone and level sands stretch far away.,
i said ill be leaving so im leaving\n\ndont know when ill be back again\n\ni figured today will be as good of a day as any other day,
correct, but false\n\nhumans do hero worship since forever\n\nthats why we have celebrities and thot leaders\n\njust that its getting worse now\n\nthe ratio of parasocial/normal relationships that people have will only increase with the pervasiveness of social media in the digital medium,
Former Ripple CTO Stefan Thomas owned an IronKey hard drive containing 7,002 BTC (currently worth about $244 million) and had only two chances to guess the password, having forgotten the information. Cryptocurrency recovery company Unciphered said it was possible to bypass the…,
When your friend says “but idk tho DYOR” after shilling you a shitcoin for the last 1.5 hours,
thanks for playing\n\nyabai desu ne,
ngl i fully expect jpy to trade in the 200s next decade\n\nby every metric, japan has very low cost of living compared to other alpha world cities\n\nits even more skewed for foreigners with external income\n\nbut this arb cannot be closed due to immigration and will remain discounted,
10Y JGBs yield up\n\n1% soon\n\ntry to control both markets, both arms blown off\n\nmanipulated bond market or fx market, you can only choose 1, not both,
when i was your age i had to walk 10 miles through a forest on a mountain barefooted blindfolded to get to work and get back home,
welcome to adulthood\n\nyou're gonna love the next 40 years,
when i was your age i had to walk 10 miles through a forest on a mountain barefooted blindfolded to get to work and get back home,
this is why i generally disagree with arbitrary prices targets\n\nportfolio target? market doesnt know\nyour position hit some target? market doesnt know\n\nyou sell when its time to sell, not some random milestone, like a 2x 10x or even a house\n\nwhy cant the price still go up? it can,
ofc many ppl wont agree with me\n\n\if you make life changing money, take it\ \n\nand i do somewhat agree\n\nbut extraordinary outcomes requires extraordinary behavior\n\npeople that \dont go broke taking profit\ have zero overlap with the people that have bought and held 100x positions,
I don't make the rules.,
comments are hilarious\n\ntheres ALWAYS suddenly another offer\n\nbecause real estate agents are lying rats\n\npull bid, lower it bigly with an expiry and let them cook\n\nthey need the money more than you need a house\n\nlet irl NFT traders find out first hand the true price of liquidity,
iwo\n\nwork out a fair price you're willing to pay\n\ntiny premium if you really LOVE the place\n\ndo not negotiate with terrorists or lying rats, so fire and forget\n\nwe all make massively way more money in crypto than RE prices can increase, so dont give a shit about rising RE prices,
ive a 3 year old memo\n\n\cash out $2m and buy a house\\n\nive told the story before\n\njust my luck that genesis were arrogant fucks that stalled me, then talked to a fren that told me the market dgaf about how much i have, its not the right time to sell yet\n\nnow i have 1 whole ETH,
thanks for playing\n\nyabai desu ne,
the biggest bull trap ive ever seen\n\nbut they wont trap me,
is it just me or is zach obviously discriminating against canadian homosexuals (redundant adjective),
his real crime was buying that watch and thinking it was cool,
id recommend hobbies\n\nranging from constructive self improvement like exercise, reading, cooking, socializing irl etc\n\nto relatively less self destructive (compared to day trading) like watching porn (any genre), hentai appreciation, twitter shitposting, video game addiction etc,
@sartajtw Thanks, I’m actually writing a book titled “Poors Participating in Consensus: Why do we let them?” coming out soon,
In an attempt to truly understand the social layer, I traveled to the Rust Belt of America and asked a coal miner if he was concerned about Lido centralization and his response:\n\n “what I need is a hard money in which to save and earn that cannot he debased by the bureaucrats,
throwing out more possibilities to get people confused with decision paralysis\n\n2024 top,
im not particularly fixated on any particular outcome manifesting nor do i have any strong preference \n\ni already know how to best play every of the possible 14,000,605 scenarios,
more backing to the theory that ex-US investing will be a dud moving forward,
i feel like so many people are stuck in an old school of thought about value, geographic diversification, mean reversion etc\n\npro tip: you can invest in things and make money from them, regardless whether you like or dislike the underlying,
replace \houses\ with \coins\\n\nliterally describing how we turbo autists think about spot crypto\n\nexcept spot crypto has no tenants no cashflow, but also no expenses\n\nanalouge real estate NFTs are out\ndigital global fungible ponzi coins are in,
to add to this\n\nwhen i see bots doing guerilla marketing in my replies about projects / companies\n\ni block both the shill and the company that they are promoting,
yes, self employed / entrepreneur are immigration codewords for super unemployed \n\nyou just need to have a tourist visa + return ticket\n\nconjuring a job for yourself works too, but you should weigh if the benefits of appearing \normal\ with a job outweighs the costs of doing so,
they mainly want to know if youre an overstay risk, and if you have a return flight out and dont look sus af, should be all right\n\nhaving a job, married + kids are all extra risk mitigating factors\n\nwill definitely help if its a pre trip visa application, but not a silver bullet,
travel aside theres plenty of good reasons to self sponsor yourself a job\n\npeople think its a flex to be an entrepreneur / business owner, but i think its hella lame\n\nyou get along with life 10x easier just saying you have a job at X company, and you can leave out that you own it,
yes, self employed / entrepreneur are immigration codewords for super unemployed \n\nyou just need to have a tourist visa + return ticket\n\nconjuring a job for yourself works too, but you should weigh if the benefits of appearing \normal\ with a job outweighs the costs of doing so,
they mainly want to know if youre an overstay risk, and if you have a return flight out and dont look sus af, should be all right\n\nhaving a job, married + kids are all extra risk mitigating factors\n\nwill definitely help if its a pre trip visa application, but not a silver bullet,
more backing to the theory that ex-US investing will be a dud moving forward,
when bitcoin ETFs are approved, we think these vehicles could see a minimum of $14.4bn of inflows in year 1, ramping to $38.6bn inflows in year 3. \n\nat those levels, BTCUSD could see 75% appreciation the year following approvals 👀 \n\nmore in our new report from today👇,
Men will watch etf tickers appear and reappear all day to gamble their last $500 on instead of getting a job,
correct\n\nwe will starve the bears out\n\nthis isnt misinformation by omission\n\nthis is just pre-truth,
It’s easier to just create a new wallet than revoke premissions fyi,
Bloomberg's James Seyffart Unveils How Spot #Bitcoin ETF Issuers Will Compete for Customers with Diverse Services 👀,
you guys are so fucking retarded\n\nmakes me very hopeful and bullish on our future,
brooooo this guy just took the photo from yesterday's post and added it LMAOOOOOOOO\n\nJust #crypto things lmao ,
@BenArmstrongsX @Bethanyliterary @DuchessOfDeFi \I am getting divorced but just for the avoidance of doubt I AM still getting laid.\,
Wait, with today's update, now the iShares Bitcoin Trust IBTC is gone from DTCC's list?  @EricBalchunas @JSeyff ,
BTC down $1000 on news that bitboy does more sex than you,
the tardfi mind cannot comprehend this,
im extremely optimistic about a globally sync retarded af ultra omega crypto revanchist supercycle pump\n\nbut im rather pessimistic that it will be this cycle, or even the next\n\ni hope i dont die before i see it happen\n\nit will be absofuckinglutely amazing to behold and be part of,
most people dont know this\n\n3 years ago i used to be a small alt account that aggregated and posted hentai only\n\nthen i slowly pivoted to crypto after i found out that it was so easy to make money\n\nlater that month was when i bought my very first, one and only, whole unit of ETH,
yall want the last month and a half of tweets, or should i nuke them all before i leave so the newbies never find out about the biggest bull trap that ive ever seen which wont trap me,
cobie, truly an inspiration to us all\n\ni wonder what language he learnt? hopefully not wassie aww watafak lmwo :3\n\nrenewed conviction to stick to my guns and deplatform myself end of the month,
after that, you watch margin call (2011)\n\neveryone's favorite scene is the senior partners emergency meeting, where they decide to \sell it all\\n\nbut i also love kevin spacey's fire sale scene, ordering his soldiers to fucking dump it all\n\nkill or be killed\ndump or get dumped on,
We're just getting started.,
so vombatus, well not a real wombat, a profile on friend tech bought all of its own keys so that he was first on the leaderboard and then he sold them all today for 851 eth to cause chaos on the day that bitcoin broke out. so funny but hard to understand if you dont know crypto,
we just lost $34k BTC\nprobably losing $1.8k ETH soon too\n\nit's so over\nwe're never coming back from this,
not a single blip on my normie radar\n\niwo etf approval will make waves in the tardfi scene, and front running the halving narrative is what will pull in the first wave of retail\n\nthey will be surprised with the follow through and get addicted to the gains\n\n『  exit liquidity 』,
dont know how to shill the halving?\n\njust send this picture,
to one-up americans on health care, work-life balance, public transportation and lack of tipping culture\n\nbut lose on every other front,
intern's latest video has more specific context about today's market\n\nbut this has always been my favorite video\n\n(i also have half the same titles as kerry 😂)\n\nbuy the dips, sell the rips\nabove all else stay alive, no liqs,
youtube serving me AI generated elon musk deepfake ads about using quantum computing with AI to invest into forex trading to 38x your money in 3 days\n\neven the scammers are off field and not positioned for a crypto bull run \n\nmomo fad investing, just like trad money VCs lmwo 🤣,
21st century natural selection test,
im the boss at the end of beginner zone tutorial mode\n\nif you die here, you werent going to make it out there anyway,
Directionally if you plan to short a market that you expect to be up 10000% plus over the next decade you are playing russian roulette but the gun is fully loaded.  \n\nName one permabear that survived 2 cycles in crypto. They appear at the froth make money for 1 year and then die.,
imagine getting trapped by this obvious bull trap\n\ncouldnt be me\n\n4dding to shorts\n\nblessed are the short, for they will inherit the earth,
i shouldve totally sold my analogue gold and silver and rotated into digital gold and silver 😮‍💨,
i have just subscribed to data dash\n\ni should start making a list of crypto youtubers to follow\n\nobviously not because i think anything they say is right\n\nbut rather the inverse, brother,
you gotta pace out your bullish propaganda - this is a marathon, not a sprint\n\ndo not be afraid to recycle rephrase reframe tweets for maximum misinformation\n\nprice going up is more important than your dignity\n\nwe can debate the ethics of it from our reasonably sized house later,
I don't think ppl understand just how bullish Bitcoin is--they keep trying to short it.  \n\nMeanwhile it is leaving tons of sideline investors stuck in fiat.,
i have an unlimited pool of tweets made by elite tier crypto fugitives from the last cycle and im not afraid to use them,
su used to force the 3ac intern to make memes like this for him to bull poast,
Stop asking who is bidding\n\nStart asking who tf is left to sell,
needless to say, but \n\nthis is the biggest bull trap ive ever seen.\n\nthey wont trap me,
100% the tardfi guys are gonna fall for this next year,
max pain is btc and alts continue to rally while ct has all their money stuck in friendtech keys,
It’s time to stop saying “next cycle” and “next bull run” \n\nWe now say “this cycle” and “this bull run”,
1 thing i do think about is, when the time comes to sell\n\nhow much will i NOT sell?\n\naka how much just stays in my deep freeze cold wallet to never interact with anything ever again unless its a catastrophe tier emergency\n\n1 BTC, 1 ETH?\n25% of fiat NW?\ndecision feels so arbitrary,
im thinking, its actually not a fixed %\n\nyou need to bank out absolute fiat to buy perma QoL upgrades\n\nbut since theres diminishing returns on money, % to convert to fiat drops as one gets richer\n\nthats 1 factor\n\nthe other factor being your confidence to sell high and rebuy lower,
not a single blip on my normie radar\n\niwo etf approval will make waves in the tardfi scene, and front running the halving narrative is what will pull in the first wave of retail\n\nthey will be surprised with the follow through and get addicted to the gains\n\n『  exit liquidity 』,
coinbase probably opens up in the 80s when US opens, dunnit,
personally, i thought the bull market started last year,
The iShares Bitcoin Trust has been listed on the DTCC (Depository Trust &amp; Clearing Corporation, which clears NASDAQ trades). And the ticker will be $IBTC. Again all part of the process of bringing ETF to market.. h/t @martypartymusic,
We need *one* more debate on AMMs vs CLOBs. Just one more, it will be the last one I can feel it, someone is going to win if we just have one single more debate on this,
One of the fastest ways to dox yourself as a cryptopleb is to ask \what's the reason for the Bitcoin pump today.\\n\nIts path to $1m+ is preordained. On any given day it needs no reasons.,
CT has survivorship bias and shows statistically bell curve outcomes\n\nSo while you can see what ended up working out it doesnt represent the real statistical likelihood of the same outcome happening should you choose to try do the same,
regret minimization fo sho\n- more time with kids, and parents\n- traveling whenever and wherever, not being budget or work schedule constrained\n- pursuing passions (doing them even if just to eventually fail and move on is fine)\n- generally, not using \busy with work\ as an excuse,
The way the upward movement is happening, the way resistances are being tested... it clearly looks manipulated, no real demand. \n\nOnce again, the biggest bull trap I've ever seen.,
there's some people i know that escaped the matrix with crypto\n\ni tell them all the same thing\n\nits a rare luxury that few people in all of humanity past present future will get to enjoy - the luxury of having BOTH wealth and youth\n\ndo things you can only enjoy while you're young,
if youre truly rich, you can do whatever you want, even if its expensive\n\nfor many people, saving a couple hundred thousand every year for a couple years in their early adulthood is worth a lot (time value of money) and buys them plenty of time with family / friends in the future,
doesnt even need to be abroad\n\nthis basically also applies for people relocating to a different city or out of state - but with almost no tax savings lol\n\ni think people over-estimate the social cost/loss and undervalue being upfront rich at 30 yo, not 50,
tbh i say all this but i cheated the system\n\ni was born and i live in a tax haven\n\nno taxes and no loss to social aspect of life,
covid was engineered by Big Gloves for insiders to exit,
this is literally shitcoins narrative of the week pump and dump but tardfi version, so the passage of time is incredibly slow,
After 3 years of buying Bitcoin and holding with diamond hands, @MicroStrategy is now up on their investment!,
be retarded when others are fearful\n\nbe fearful when others are retarded,
there's no PC or non-PC\n\nthis is twitter, not the united sensitive states of amerika,
be retarded when others are fearful\n\nbe fearful when others are retarded,
unlikely, since i probably wont be tweeting anymore when it happens\n\ndont worry, i blv in yall\n\nthat 90% of yall will fuck it up and 10% will make it\n\n🙏,
have yall considered not selling coins until we breach ATHs so that we can transition from PvP to PvE and dump on NPCs instead of dumping on each other,
some of yall thing im smart\n\nmy 2 brain cells got together this morning to have a serious discussion about this \ETH call seller\ and its impact on the market\n\nthey have concluded that they've no fucking idea what that means and i shouldn't waste their time on non-hentai things,
subtle shills about your bags will never work on me\n\ni have evolved defenses against such psyops\n\ni wont be trapped,
purge your spreadsheets and reduce mental clutter\n\n(or archive them onto a different tab/sheet and get them out of the way)\n\nmy spreadsheet pulls price data for BTC, ETH, LDO and COIN\n\nim operating at the limits at my mental capacity with just 4 crypto positions (brain very smol),
for me, eyes on the prize\n\ni regret spreading myself out too thin previously, dedicating precious resources to monitor positions that were ultimately minor to the overall portfolio\n\ni should've focused on my main positions and nailed them down as close to perfectly as possible,
investing is like cooking\n\ninvestments = ingredients\n\nportfolio = dish\n\ninvestor skill experience = chef skill experience\n\nexternal fund manager = cooking for other people outside of family (you know family preferences, you can ask them to STFU and eat the fucking food or starve),
ive been trying to think of other analogies, but i keep coming back to cooking\n\na well executed portfolio is so much more than the sum of its parts\n\nindividual ingredients could be great, but the magic is in how you combine them and also the skill of knowing when to STOP cooking,
wnxm traded down to almost ~25% of NAV\n\nnow its ~80% of NAV\n\nstory unrelated,
if grayscale is sold, dont expect the new owners to continue pretending to want to convert\n\nGBTC discount has compressed from ~50% to about over ~10% now\n\nif i held GBTC, i would sell rather than try to eek out a bit more gains\n\n0.9 BTC in the hand better than 1 GBTC in the bush,
i dont own any grayscale products cos i rather not add another layer of complexity to my trades\n\nwhere i can be right (BTC goes up), but my vehicle is wrong (GBTC cucked) and i dont make money\n\nofc with the discount, it could work the other way where you get supernormal profits,
people realized digix dao was worthless, except for their treasury of\n\n466,648 ETH raised during ICO\n\nbut no one could force a dissolve, except the insiders\n\nit traded down to 35% of NAV\n\nwhile insiders bought millions, until they got their fill\n\nthen dissolved\n\nstory unrelated,
i dont own any SOL or LINK\n\nbut im happy your coins are going up brotatoes\n\nlet the pump into your life \n\nrespect the pump,
reordered my reading list\n\nhave 2 books to read\nthen the rise of carry\n\nthen will circle back to this\n\nQ2 next year mandatory re-read is devil takes the hindmost\n\nits the most important book that you need to read, and there's a reason why you need to read it then\n\nyou'll know why,
the feminine urge to start a book club alone and then force feed my followers my thoughts about them\n\nno i dont want to join your book club because i dont want to read your books, i just want to monologue about mine,
theres only 1 way to use this book to be a profitable investor in the 21st century,
i found an old book that i had bought a long time ago\n\ndecided to re-read it, since it was part of my formulative years\n\nit was first published in 2000\n\nit feels so dated reading it again in 2023 - ETFs were not so popular (SPY only existed 7 years before this book was published),
the usual preference of cheap (value) &amp; small as characteristics of outperformance\n\ni cannot say that i agree with this because my theory is that, just like intl stonks, there is a reason why value and small are underperforming and will continue to do so \n\n(the flows of money),
money managers do not exhibit consisten stock picking skills\n\nergo, the most rational way to invest is through low-cost indexing\n\nG's note: 100% agree - compared to 2000, low cost indexing is available to everyone\n\n1/5 stars, wouldnt recommend to buy this book unless youre a noob,
a crypto bear is only correct 3 out of every 4 years,
i think about languages a fair bit\n\nconclusion is that english fluency is MANDATORY to make it, for the next gen\n\nif ex-asia, 2nd lang prob spanish\nif asia, prob chinese\n\nperhaps controversial, but iwo having to first learn a non-global language is like booting up with bloatware,
gm fellow pre-rich crypto billionaires\n\nwhat narratives are we shilling today,
@inversebrah Dei wont trap me iwo,
my guess would be high end luxury tokyo residential real estate\n\neven then, i dont have high conviction,
iwo the rest of their RE market, esp outside of the handful of major cities, will be endless knife catching \the bottom\ that just keeps on bottoming for the next ~20 years, if you track in USD value,
its gonna blow your mind once you find out how pornsites keep children under 18 from viewing their content,
if i see anyone run twitter ads on their own personal tweets, i instantly block them,
I'm told that Hayden wanted to sell the HAY tokens, but he couldn't bring himself to pay the 0.15% UI fee, so he burned them instead,
i have finally succumbed to the pressure by the eth community\n\ntoday i staked my 1 ETH with a centralized exchange\n\nim doing my part to combat lido dominance, please consider doing the same,
New: an incredible court record pulls back the curtain on a $30 million dollar underground Bitcoin exchange running for years in the heart of New York. Massive bags of cash, drive-by pickups. This is what real criminals use, not services like Coinbase,
my theory on this is that the \life meta\ has just simply evolved along with the times and the difficulty level has gotten harder\n\nthe baseline expectation is working a full time job\n\nto live an upper middle class lifestyle, essentially mandates investing well in addition to that,
when i talk about dynastic things, i think of generational time periods\n\nyou can 躺平/quiet quit, check yourself out of society and genuinely enjoy the rest of life\n\nbut at the expense of handicapping your next gen, instead of giving them unfair advantages to destroy their peers,
dont worry, the only thing at stake is the welfare of your bloodline\n\nor the existence of it,
no\n\nit is of utmost important to put down your fellow brothers in coin\n\nby reminding them that while yes, they are getting rich, they could've been even RICHER if they had bought another coin instead\n\ncomplete skill issue and they should feel bad that they aren't playing perfect,
sixteen hundred united states dollars for 1 ethirium,
teams deciding airdrop amount to the community,
in china, this mindset is similar to 躺平, also similar to western quiet quitting\n\nlmao, she was so close tho \n\n\i would rather get my work done (on my time), and then go live my life\\n\nthese ppl are unemployable but have also opted out of the gene pool by financial sterilization,
yet another banger from one of the thought leaders of 21st century modern philosophy\n\nmany people CHOOSE to be unhappy\n\ni have unfortunately seen more people that have regressed as they got wealthier with mo money mo problems, rather than ascend upon release of financial burdens,
Kind of crazy that there are realistically 30-40 people in the entire world that have expert level knowledge on the Israel-Palestine conflict and literally every single one of them is in my cryptocurrency group chat,
CT telling everyone about their pre rich moon bags,
if i ever see brian armstrong like this \n\nill be turbo nuking my coinbase stonks\n\nand then will commence shorting on high leverage,
CT telling everyone about their pre rich moon bags,
Not all RWA are made the same. For eg, tokenized US Treasuries is AA+ rated &amp; backed by the \full faith &amp; credit\ of the US govt.\n\nHaving said that, AA+ rated RWA off chain can quickly become CC+ rated on chain if both legal design &amp; adherence to regulatory compliance are poor.,
Cat is on the internet browsing stuff. Some are hentai, some isnt. But always browsing.\n\nYou’re anonymous and outside with real girls. Enjoy the sidelines.,
If you’re in a 3rd world country and someone asks you to pay them in USDT on Tron, it’s your responsibility to tell them that Tron blockspace is *not* ultra sound and that these types of life decisions are almost certainly why they are poor to begin with. Do your part.,
@DegenSpartan You can't fully understand BTC until you try to carry 10k worth of silver in to sell,
zero\n\nwithout being racist\n\ni dont think china money is real money,
dont worry, im not offended if you dont blv me \n\nyou are more than welcome to find out for yourself,
funny story, precious metals investing and general financial doomerism is what got me into crypto\n\ni hope that within the next few months, i stop being a lazy piece of shit, and i round up my gold + silver bars and coins and sell them\n\nive been wanting to do that for a long time,
Wake up new Capo just dropped,
scalable simplicity\n\nUS treasury bills\nS&amp;P 500\nBTC + ETH\n\nyou might disagree, but you don't manage my money\n\nyou can do whatever you want to do with your own money,
i still have coin and ldo that i plan to sell at higher prices stop freaking out you pussies,
when i was much younger, i would optimize for credit card points, miles, cashback, sign-up promos etc and carry 10+ cards\n\nnow i have simplified to only 2 cards\n\n1 visa credit + 1 mastercard credit for miles\n\nthey generate unlimited business class flight tickets for me to use,
when traveling (gotta use those biz class tickets innit)\n\ni bring along 1 visa debit + 1 mastercard debit since sometimes paying by credit will run into issues\n\nim a fan of wise even though its an EMI and not a bank,
since switching to this philosophy of scalable simplicity\n\ni feel like i have been mentally depressurized and have relieved myself from having remembering junk information regarding merchants, limits, promotions, etc\n\ni just live life and enjoy, without having to think too much,
Happy 1 year anniversary to the 100% chance of recession forecast that never happened,
more than half of the ramps i set up last cycle have been blown up and are no longer usable\n\nit is a continuous effort to keep ramps open and establish new ramps\n\nwould suggest to design your infrastructure to be able to accommodate for failures, of which there will be plenty,
i was thinking, residential real estate is an asset classes susceptible to downward price manipulation \n\n\we want affordable housing / rent controls\\n\nunlike stonks or crypto, that will never ever have a mandate to be price suppressed\n\nwhere higher is always better\n\nup only,
\nobody has banks! its all vampire attack on $USDC circle/coinbase\\n\n🧸🎯,
individually\n\ni hope yall have at least 1 bank that you can off ramp your profits into without any problems\n\nideally several banks, in different jurisdictions\n\nbut one step at a time\n\nyou dont need even to be sneaky about it, you just need to be upfront and pass the AML checks,
\nobody has banks! its all vampire attack on $USDC circle/coinbase\\n\n🧸🎯,
if you're so smart, why arent your opinions more valuable than mario nawfal? turns out you're fucking irrelevant,
i have mario blocked\n\nif i wanted to read misinformation, i can just scroll my own tweets 😤,
ok but have israel and palestine considered land in the metaverse?,
Bank of America 🤝 Uniswap LPs\n\nSuffering from impermanent loss https://t.co/Ty12AL5bwy,
Father Fink knows what's coming and he will be there to sell you salvation. https://t.co/4NDqUr7LyA,
wheres soylono,
can a person have more than 1 bankID? like, if you have accounts with 2 swedish banks, do you get 2 bankIDs?\n\nanyway, another reason why you cannot rely on only 1 bank\n\nand why you should also bank offshore,
i knew someone that was falsely accused of money laundering and had all their bank accounts within the accusing country frozen while under investigation\n\nhugely disruptive to life\n\nif all your bank accounts were frozen in your primary country of residence, would you be all right?,
personally, would be an annoyance\n\nbut id be able to live life as usual without any major compromises\n\nperhaps a bit more marginal costs to get things done, which is expected when relying on a universal secondary backup system\n\nnot the most optimized solution, just a reliable one,
great point\n\nexcept R/R is independent from success rate,
regarding clawbacks or anything actually\n\nlawyers can send you demand letters for whatever\n\nand you can reply to them to fuck off\n\n(not legal advice),
when ppl outside of CT say that we are mentally ill https://t.co/298FnCVEJ0,
reminds me of my all time favorite article about fairness\n\nhttps://t.co/nCNXI5QTnB https://t.co/WEyaKp1NT1,
the only way the attention economy doesnt fuck up all of how ppl consume information is if the smartest ppl figure out how to convey information as effectively as the mr beasts &amp; mario nawfals\n\nwont matter who is more intelligent if they arent getting distribution,
stumbled upon this very good video that id encourage you to watch if you have 15 mins\n\nthe romantacizing of mental illness (the lgbtwtfbbqization to become special), the mr beastification of society\n\npretty much what i blv as well\n\nattension ekonomi innit\n\nhttps://t.co/Pe1JVtDe99,
how to properly consume information in the 21st century https://t.co/tD5S9NUhXE,
our future is that mario nawfal is the world's foremost expert on every topic\n\nnot because he knows a lot\n\nbut because he botted his way to fame and farmed enough cheap social proofs that will pay him passive social credibility points (fungible for money) for the rest of his life,
The bar in crypto is so low if youre just barely decent and not totally dumb you will be in the top 3%,
you say dishonest claim buyers\n\ni say liquidity providers selling USD to willing FTX claim holders at the current fair market price https://t.co/jRHB9i5Q5j,
india is very interesting\n\ni do actually agree that they have a large enough base to self sustain,
however pretty unactionable information unless you are indian https://t.co/nZSKW7XZXP,
@DegenSpartan and it'll be all of the other market's 50% drawdowns that create the liquidity and conditions for US markets to rage higher. \n\nThere's no reason to own equity anywhere else. It's US equities, US treasuries, or Bitcoin imo.,
the good news - it probably wont just be HK\n\nthe bad news - probably all stonk markets except the US https://t.co/acNuUm9Mge,
a follower recommended to me a book called \the rise of carry\ and ill be reading it next after my self enlightenment arc https://t.co/ga3gL6C6dt,
@DegenSpartan i’ve invested in a controversial new on-chain art asset class that accelerates my portfolio\n\nso you’re rich now?\n\ni’m poor FASTER,
i actually do wonder how vitalik manages his finances, taxes, cex-bank infra, etc,
i say, give sam his adderall,
i just listened to a normie reason that since cryptocurrencies are currencies, and nobody invests in currencies, but only speculate and trade them (forex trading), ergo cryptocurrencies are pure speculative trading instruments and are completely unsuitable for long term investing,
i snorted and replied have fun staying poor,
the \currency\ labeling really place an upfront bias to a wrong mental model and retards their ability to manipulate their understanding of it\n\nits like when people heard about \impermanent\ loss\n\nyeah naw, its pretty fucking permanent kek,
@0xngmi i may have been mainly using llamaswap for the past few months\n\nreportedly,
oh, yall just found out the UNI tokens do nothing and are worthless?\n\nif only there was some hentai senpai talking about that for the last 2.5 years,
tbh, good for hayden and the other equity holders\n\nhappy for them,
personally, i dont use the uniswap front end for proper trades\n\njust makes more sense to use an aggregator and skim all the available pools at once,
oh, yall just found out the UNI tokens do nothing and are worthless?\n\nif only there was some hentai senpai talking about that for the last 2.5 years,
tbh, good for hayden and the other equity holders\n\nhappy for them https://t.co/aqD96LmvXj,
You can be an influencer.\nYou can be a personality.\nYou can be a PR agency.\nYou can be an ad network.\nYou can be a meme queen.\nYou can be a pump n dumper.\nHoney, you can be literally whatever you want.\n\nSO LONG AS YOU DO NOT PRESENT THAT BULLSHIT AS FUCKING JOURNALISM.,
regarding crypto clawbacks, you can reply with:\n\n\ordinary course of business.\ncome clawback deez nuts\,
Is the BTC spot ETF already priced in?\n\nDon't ask such a dumb fucking question again. https://t.co/l3PZ9wJ2Md,
next bull run, i implore yall autists to make deepfakes of various investment gurus and finance professionals either in professional news / talkshow settings, or informal \recordings\, that are talking positively about crypto and leak them on normie social media,
tinder, multiple catfish accounts, location restricted to your local financial district, typical basic bio + \ONLY DATE REAL MEN, THAT OWN AT LEAST 1 BTC.\,
btw i think deepfakes of ppl in informal settings are the best\n\n*imagine, voice recording only*\n\n\im only telling you guys about this here, since i cant speak about crypto positively in public\\n\nsince they will literally say that they didnt say those things and its fake lmwo,
Blackrock manages $10T in assets, Bitcoin's total market cap is only ~$500B, comparably Gold's market cap is ~$12T\n\nyou cannot easily transport millions of dollars worth of physical gold across borders instantly, with Bitcoin all you need is your private key\n\n$250k+,
dont fool yourself\n\nthe main utility of LDO is selling it to other people at a higher price,
tfw you realize inversebrah is more professional than half of the clown media outlets here lmeow,
*Pointing at my computer* That’s @inversebrah. That’s @DegenSpartan. That’s @fuckyourputs. I like them.\n\nMy tired mom: That’s great buddy :) Did the nice man from McDonald’s call back about a job?\n\nMe: No. *points back at computer* That’s @CL207. They’re a cat. https://t.co/GmhKq2qDFR,
to make my position absolutely clear with no ambiguity \n\ni am pro manipulation if the price goes up\n\ni am anti manipulation if the price goes down https://t.co/9H9Czp6qGq,
personally, it doesnt matter to me whether its approved today tomorrow or next year\n\ni think its mostly narrative building anyway and we'll only actually reap the rewards of connecting up with tardfi next cycle onwards\n\n(the initial build up of the perpetual DCA bid to infinity),
We apologize for a tweet that led to the dissemination of inaccurate information regarding the Blackrock Bitcoin ETF. \n\nAn internal investigation is currently underway. We are committed to transparency and will share the findings of the investigation with the public once it is…,
@udiWertheimer im a supporter of anything that pumps our bags even illegal things,
its not market manipulation\nits an intern being a silly billy \naccidentally making a fucky wucky\njust a smol little widdle oopsie daisy\ntee hee hee hee https://t.co/rbWFwOuP5e,
if all the news outlets quote each other as sauce, its becomes true https://t.co/5lIM23hjBP,
*me, never having held a real job, completely detached from reality and provably incapable of functioning in the real world*\n\n“No I’m telling you, the real world asset thesis is what’s going to propel us to mainstream adoption, I just have a good pulse on what these people want”,
which bank will be the fiat ramp for upbit sg 🧐\n\nafter the china money launderers embarrassed tf out of singapore, im of the opinion that opening up an offshore bank account in sg probably has become much harder compared to 3 mths ago\n\nive no idea how long this window stays open,
afaik, pretty much any passport is accepted as long as you can provide properly documented source of funds\n\nlow-mid 6 fig initial deposits depending on bank and how sexy your fully nude KYC photos are\n\nthat's all for now folks 🤐\n\nhttps://t.co/ygeRNeocQ8,
the most advanced integration of AI with crypto so far\n\nis saylor using AI generated images to shill BTC https://t.co/6UfraXPpuy,
if you quickly send out a cryptic tweet about \being cautious here\ or \thinking about taking profits\\n\nyou can retweet it later for clout if price drops\n\nif price goes up, nobody will even care,
i saw a black mirror episode about this called fifteen million merits (s1e2),
tbh black mirror is too heavy for me to watch so i stopped at season 3\n\ni find that they very accurately simulate society if such tech existed, and that makes it ultra depressing lol,
@poordart US ETFs are a pre-req that unlocks the tech tree that enables the building up of the perpetual DCA bid\n\notherwise known as the zhupercycle,
the biggest bear trap ive ever seen\n\nbut they wont trap me,
its riskier, so it HAS to give higher returns,
the problem with EM markets is that corruption occurs offchain, so zero capture by public participants and just continual value leakage\n\nthe benefit of the US markets is that corruption flows thru the public markets, with positive spillover and capture to uninformed participants,
essentially, this answer the question\n\n\can we all WAGMI?\\n\nnot by answering the WAGMI part\n\nbut by defining who are the \we\,
the cynic in me theorizes that for a certain (small) % of elites with high QoL to exist, they have figured out that they have to be supported by a certain (large) % of helots\n\nand they prefer a domestically sustainable system (limits # of elite) vs offshoring their helots (risky) https://t.co/zJlEUe3h5a,
iwo probably the correct strategy given then absolute population size,
sustainability is the tradeoff of offshoring your helots\n\nbut with a large pop size, its probably not a viable strategy\n\ncontrast this to smaller countries like lux, switz that can reliably depend on their external hinterlands to train and house their helots (and their problems) https://t.co/VCIwxWMwJq,
i have a younger HK fren that has been DCA-ing into the local stonk market for the past 10 years https://t.co/2o5HLed8pe,
this US vs DM ex-US vs EM vs frontier markets outperformance is a permanent feature of the new paradigm, not a mean reversion opportunity\n\nid even go so far as to say the period of EM outperformance was just fad investing and their assumptions of outperformance are not valid\n\niwo,
i have a younger HK fren that has been DCA-ing into the local stonk market for the past 10 years https://t.co/2o5HLed8pe,
badly explained anime summary:\n\narmless war veteran works at fedex while coping with her PTSD https://t.co/XwFOu6DEuS,
a liquidity pool is where you can dump toxic flow into without worrying about bids getting pulled,
end of an era\n\nbillions of ETH will now be unstaked and sold,
We’re all born with an innate, almost primordial desire to fund public goods it’s just that it usually stay suppressed inside of us until we learn about liquid tokens,
but do you know any crypto girls from north korea 🇰🇵,
i actually dont know anyone in bahrain\n\nbut isnt the main vanguard of the crypto youtube scammer clique now based out of dubai?\n\nhard to keep up with gossip news,
some ppl recommended to watch erased, so i finally pushed it up the queue on my watchlist - did not disappoint, flawless actually\n\nalso finished the book i was reading, was all right, basically a recap of interesting concepts. doubt it leads to enlightenment, just self reflection https://t.co/OIfGF5i95b,
starting my next book titled \the power of now - a guide to spiritual enlightenment\\n\ntbh i dont have high expectations, but it has been routinely recommended by a few people so i thought id find out for myself https://t.co/32gNgazqMf,
8/ This is where claims was last week - and I heard the last trade was at 48c.\n\nIt should be 60c end of the year when FTX 2.0 plans become clearer.\n\nPls don't get fudded to capitulate like claim sellers from start of this year.\n\nUp only chart added for reference. https://t.co/EjMTYV8g31,
ive learnt to just agree with everything yall say about me,
btw fyi, i have 0 community notes so far,
If you form your opinions from other peoples opinions, especially from online, you are doomed to be poor. \n\nGet facts, then form your own opinions. \n\nPs. 99% of “facts” out there are opinions, assumptions, inaccurate, wrong, or deliberately false.\n\n👀 open your eyes.,
There was a woman like this in every village in the 17th century. You could just accuse them of witchcraft and never have to see their face again. Now we jump thru all these hoops https://t.co/cIGP7zhcrx,
gripto is the mirror image of the stonk market\n\nin stonks, you get a big dump every few years when panic supply overwhelms a stable demand - you buy those\n\nin gripto, you get a big pump every few years when panic demand overwhelms a stable supply - you sell those https://t.co/hlE75gCXOm,
I’ve gone to war-torn, poverty-stricken countries and talked to the unbanked, the people who don’t know where their next meal is coming from, and they all seem really pumped up about account abstraction and intents-based architectures,
it's called friend tech bro\n\nyou buy my key bro\n\nand i also buy yours bro https://t.co/enCrYJsMXV,
hi I'm saifedean, bitcoin is a hammer and everything is a nail, im smrat,
i havent been community noted yet because i have never lied on twitter before,
i just checked and actually i qualify to join community notes\n\nbut i wont\n\nbecause i prefer to spread misinformation and conduct disinformation,
crypto this week: ok so here's my take on war, faith, racism and the justice system,
possible farm for risk seekers \n\ndeposit stETH to farm DIVA\nafter they launch, your stETH is converted to divETH\nwithdraw divETH to ETH\nswap ETH back to stETH\ncollect rewards and sell DIVA\n\ni wont be doing anything, just observing,
this strategy is a bet that the team doesnt rug or get exploited \n\n(rugged used correctly here, not using yall WRONG stupid zoomer wagmi 2023 definition)\n\nhttps://t.co/Lu57FcBiSn,
the obsession wit filming everything for socials is warping yall's minds hella hard lmao,
imagine being the scammers making my impersonation accounts and having to fill the bio with \n\n\reformed hentai addict\ \n\nlmeow,
altered the based infographic to remove the $10k tier\n\nyou'd notice 2 main things:\n\n#1 - primary residence + real estate as a % of wealth decreases over time\n\n#2 - financial assets (in blue) increase over time\n\nbonus notes: rich people do not depend on retirement schemes https://t.co/I0NwtOhDiE,
bonus notes\n\nfixed income investments always remains tiny - their main use in rich people's portfolio is to produce income to match expenses that worries them\n\nliquidity is always present, but dwindles as additional ways to access liquidity are unlocked (borrowing against assets),
thread content created by discussing with a rich fren of mine\n\npersonally i only have 1 ETH, but now i have a clearer picture now of how i'd want my asset allocation to look like when i finally make it\n\nWAGMI,
altered the based infographic to remove the $10k tier\n\nyou'd notice 2 main things:\n\n#1 - primary residence + real estate as a % of wealth decreases over time\n\n#2 - financial assets (in blue) increase over time\n\nbonus notes: rich people do not depend on retirement schemes https://t.co/I0NwtOhDiE,
interestingly, the assts of a pure financier can look normalized as well, as they funnel and wrap assets into family offices for optimized returns and estate planning purposes\n\nits almost always better to bequeth to heirs a company holding assets, rather than the assets directly,
bonus notes\n\nfixed income investments always remains tiny - their main use in rich people's portfolio is to produce income to match expenses that worries them\n\nliquidity is always present, but dwindles as additional ways to access liquidity are unlocked (borrowing against assets),
ive been observing palau for a while now\n\nif palau can roll out physical addresses, id probably take it more seriously\n\nvoip numbers, digital banking and e-corporations would all be very interesting things as well\n\nive never been to palau\n\nit looks nice, but really hot,
@DegenSpartan Lol generated with gpt flowchart plugin with your tweet https://t.co/pniwWYXBqj,
does anyone have the decision tree meme about whether someone is a girl, but the answer is always that its a man unless theres an OF link in bio (possible catfish),
there has been zero instances so far in my lifetime that CPI data has informed me to make any immediate actions,
i only know its happening because you dweebs post about it non stop for half a day before it happens,
Once upon a time @tradinglord &amp; I were at a dinner meeting some devs. \n\nThey arrived with the most mid bitches I’ve ever seen. I took one look at this and said I’d short it if I could. Project now down -99% \n\nNever trust a rich man with a mid bitch https://t.co/vQ5WIGh2T5,
serious question\n\ndoes the bahamas not have any prostitutes,
if no one wants to step up, i guess i will have to 😮‍💨,
today i saw a lot of people making fun of caroline\n\nand also a lot of people saying that its wrong to make fun of her\n\nfor all those to stood up for her, i want you to know that i have mentally debuffed the weight and value of all your opinions, on every topic, from today onwards,
you cant back a liquid stablecoin with illiquid assets*\n\n*you probably can, but not at the start, and not without liquidity management of the collaterals,
\4. It has no KYC.\\n\nyou need KYC to directly mint-redeem\n\nthey also have a blacklist and ability to block and freeze addresses (standard stuff)\n\ni guess we now have a decent bunch of tbill stuff on ethereum, maybe ill do an unbiased overview comparison,
iwo this is alfa\n\nevery niche already has their existing experts\n\npeople that cross do not need to be top tier of each input to produce strong output\n\ntheres this mildly entertaining guy in korea and his cross is being white x speaking korean - thats it, thats 95% why he's famous,
@0xPigeon @RookieXBT @DegenSpartan Crypto is thriving. Downtrends are natural \cycles\. The market shows consistent growth &amp; innovation. Unlike other assets, crypto brings unique value. We're at the start of another exciting cycle.,
he didn't eat dem tho\n\nso should be oke? https://t.co/yEMO6dDfhH,
Unpopular opinion: You need three bull runs to make life changing returns\n\nThe first one is to learn, the second one is to learn, the third one is to capitalize on,
finished up 2 trash animes, would not recommend\n- faraway paladin s1\n- inukai-san's dog (lol)\n\n25% through this book\nit is slow because i take time to reflect and i write down notes\n\nordered \the courage to be disliked\ since a few people recommended it\n\nstill exercising daily https://t.co/79jCGn7yuf,
i share this actually for selfish reasons, to keep myself accountable\n\nif the intrinsic desire to do these things themselves are lacking, the shame of NOT doing them after i said i will serves as a backstop to ensure i make good on my plans\n\none step at a time, but always forward,
thats your perspective\n\nmine is that she's sub-human and governments should consider introducing a death penalty tier of punishment for gross financial crimes above a certain limit of damages,
imagine your life savings stolen\n\nfinancially ruined\nfinancially castrated\n\nX thousands of people\n\n\well, they'll go to jail for a bit, so its all good now\\n\ni wont respect the outcome, but id respect that these institutions are the best we've got so far to maintain social order,
sometimes i do think about this\n\nlots of sad things in the world, but this hits closer to home because i know so many people that got royally fucked over by FTX\n\ni personally dont know anyone that off'd themselves, but i would bet that it did lead to some\n\nhttps://t.co/Wf1bnUOJt6,
i like to cover a breadth of topics\n\ntopic experts are aplenty\ncross multi disciplinary experts are rare\n\none moment its about the Straussian distinction between exoteric and esoteric communication being a profound culture-neutral phenomenon\n\nnext moment its about goblin grippy,
perhaps easier to relate\n\ndevs? experts at the technical aspects of magic money coins. most are shit financiers investors traders\n\nfinance bros? experts in the arena, trying new things, like UST and get themselves blown up cos they obviously didnt understand what the fuck it was,
the algos have been pushing to me lots of refurbished campervans / mobile homes videos lately\n\none part is how people are \flipping\ them and there's apparently high demand for custom builds\n\nanother part is ppl opting to downsize and change lifestyle to live on a smaller budget,
chanced upon a couple videos of ppl living this lifestyle because they just save so much money\n\nstrangely, my mind wanders to the operational feasibility of the whole set up\n\nwhich state do they belong to? state taxes? how do they receive mail? what's their registered address?,
CT has never been so divided\n\nwhat race is she?,
aggregating the responses so far is that she's goblin race witch class and she can cast death grip,
@DegenSpartan Trolls are often depicted as large, ugly, and brutish creatures, so I don't think its fair to call her a troll since she is so small in stature.\n\nGnomes are small and humanoid which matches but they are often depicted as friendly, cheerful, and helpful creatures\n\nShe a goblin,
CT has never been so divided\n\nwhat race is she?,
@DegenSpartan maybe you should reword, \n\nshe's probably a 9 in the world of trolls \n\nhot troll 😛,
RWA Is The Future.\n\nLying Is Impossible When Put On The BlonkChain. https://t.co/2zTskIz9OP,
the freedom to say that caroline looks like an ugly troll is my elon-given right on this platform and if you dont like that, its not a me problem, its a you problem,
The fact there's people on here defending Caroline explains how my trades have counterparties,
legend says that if you white knight her on twitter\n\nshe'll give you the gorilla grippy later,
@zachxbt @DegenSpartan hey man I was wondering if you'd like to meet today's on-chain clown https://t.co/GyNmfWp6aU,
USDR trading at $0.507 now\n\nare users aware of the difference between solvency and liquidity?\n\nwell, now they are https://t.co/1NvfiHWDG1,
\To sum it up, there are 7 tokens and 5 UIs involved.  Tokens: \n- ETH \n- WETH \n- stETH \n- wstETH \n- axlWETH a.k.a. axlETH \n- axlwstETH \n- canonical wstETH \\n\nseems simple enough,
perhaps part of the reason why our cryptographic coins keep failing to gain critical adoption is because society is still trying to catch up with it so that they can be integrated \safely\ without too much problems https://t.co/A0tSUqrAN7,
when ppl ask me when are we going to get the globally synced crypto fomo bubble \tokyo imperial palace worth more than the state of california\ type of madness euphoria\n\ni say, definitely not anytime soon\n\nwe still lack the pre-requisities needed to facilitate that level of mania,
$USDR trading at $0.9 now after the $DAI reserves got depleted. A basic bank run on the system. I wrote about this 6 weeks ago. Hope they manage to recover. The question is how quickly they can liquidate the real estate backing now and return the peg.\n\nThere is another play,…,
G, are you fucking elittereight?\ndo you know how to read? \nname 10 books https://t.co/suni5b3cHj,
rather than best in a general sense, perhaps \impactful\\n\n- daily stoic\n- subtle art of not giving a f\n- outer order inner calm\n\nkinda basic bitch picks but it is what it is brotatoes\n\nif we're talking fiction its probably\n- one fish two fish\n- green eggs and ham\n- cat in the hat https://t.co/3PCmfOORcp,
you dont need to buy or read any of the books now\n\nyou're welcome,
working through a huge backlog of half finished anime and books\n\ncurrently reading this one\n\nwas a gift from a fren that said i always think too much and if i finished thinking all my thonks, i could enjoy life more\n\nremains to be seen if it helps, or just gives me more questions https://t.co/XjI96ha9Qg,
@cbcbken @inversebrah @DegenSpartan People follow the degenspartan thinking he will be their light in the darkness, thinking he is the wise man showing them the way \n\nThe truth is, degenspartan is the darkness, only when one realises that can they learn from him,
@Irenezhao_ Crypto is done. People keep acting like it's a normal \cycle\ but it is a complete failure. The market is over. It has been hyped for years with nothing to show. Other assets create real value and this one is just a bunch of failure. There won't be another cycle.,
you ever had grippy so good that you paid an annual retainer of 200k and then gave her a 20m bonus?,
i learnt rather early on that it is better to be mysteriously silent than to talk and let everyone realize youre actually retarded\n\napplies for tweets too,
“You should be staking from home” is truly the “let them eat cake” of our times,
actually, i do have a platform where i share my market views, general thoughts, and whatever i have in mind, as well as sometimes take questions from subscribers\n\nits right here, fully free on twitter,
it pains me to see that so many of yall have been lied to and that someone managed to grossly revise history and fool everyone\n\nthese are the real true words\n\ndo not forget them https://t.co/nKuc8dzHtK,
LMWO gottem with the pasta 🤣,
@DegenSpartan citizens. do not forget why you are here https://t.co/infNgXSDkn,
watching yall incinerate online frenships over political / religious views and increase the amount of echo in your bubbles\n\nbe me, make online frens not based on their views, but for the eventual exit liquidity they can provide https://t.co/FAU2dlWD3L,
something something something something https://t.co/Qeylqt0Stb,
actually never heard of the Hashdex Nasdaq Crypto Index before, trades on the bermuda stock exchange (lol who even has access to that)\n\nUS etfs are all futures\nCA etfs are all spot,
btw out of curiousity i was wondering about tracking error\n\nit seems that proshares has massive tracking error?\n\nvalkyrie and vaneck have slight tracking error\n\ncanadian spot ones are tracking very well,
i almost got trapped\n\nsomeone posted some mega autistic tweet that is objectively wrong\n\nfor engagement? virtue signaling? idk, doesnt matter\n\ni stopped myself from engaging\n\nthey won't trap me 🫡,
ommmmmmmmm they won't trap me ommmmmmmm https://t.co/WnF2JypHAZ,
@DegenSpartan Um G we only post takes abt the Middle East now\n\nAwkward,
they simply have to be scalable\n\ntbills\nS&amp;P500 (qqq, maybe intl stonks if you're a US doomer)\ncrypto\n\nplease do remember that i only have 1 ETH for now but dont worry i plan to make it all back,
if you ever get rich from crypto or finance\n\njust do the above and absolutely do not listen to any financial advisors regarding investment allocation\n\nestate planning, tax planning? sure\n\nasset allocation? fuck off https://t.co/erApP0cTDS,
insane value these buyers are getting https://t.co/ScDzETklfs,
which currency will AIs demand to be paid in?,
yes, that is the correct answer\n\ndigital venezuelan bolívars,
its not just a labor shortage\n\nits a demand / consumption shortage\n\npretty much every developed country is below population replacement of 2.1\n\nthe resource that countries will be squabbling over mid this century will be \good\ migration\n\nand \good\ doesnt only just mean rich,
My entire time in crypto just flashed before my eyes,
to me, the comments from 1 unverified reply guy is worth more the comments from 10 verified users\n\n(the unverified ones are usually way more retarded and funny),
im not scared of unverified spam bots\n\nmy psyops defense is impenetrable\n\ni tweet free content\n\nby the people of the people for the people https://t.co/Sm9QU0CgmC,
eth may be a shitcoin\n\nbut its my shitcoin,
lmwo did a 8 year old come up with this secret message?\n\nwhy is craig so retarded,
&gt;he doesnt know why i like japan\n\nboku no innocent sweet foobar https://t.co/Is5WcqS7G2,
i get this question often\n\niwo its not even a question of absolute cost comparison, but life situation\n\nif you are a young single male, i think it is SIGNIFICANTLY better to rent, than to lock yourself down to 1 city\n\noptionality is worth something, usually more than most realize,
would actually agree with this conceptually, except for timing of it\n\nkorea is basically time lagged japan and japan is accerlating into the doom loop now, while korea has a 10y \look into the future\ cheat code to work out a better solution than whatever japan does,
fun list\n\niwo, most of asia is overvalued even after considering it'll be the nexus of the worlds population this century\n\nactual physical supply limitations drives up HK and SG\n\nunless you have some edge in asian RE, you'll likely underperform just holding US or even intl stonks,
a senpai once said\n\n\Have literally zero interest in overseas property as a store of value... If you prefer wealth you prefer crypto\\n\nbest to view overseas property as just unecessary lifestyle expenses you could sell, rather than an investment that you can also use occasionally,
fun list\n\niwo, most of asia is overvalued even after considering it'll be the nexus of the worlds population this century\n\nactual physical supply limitations drives up HK and SG\n\nunless you have some edge in asian RE, you'll likely underperform just holding US or even intl stonks,
to me, the comments from 1 unverified reply guy is worth more the comments from 10 verified users\n\n(the unverified ones are usually way more retarded and funny),
gm fellow 1 eth whole coiner whales\n\nhow are we coping today,
the optimistic scenario was we'd start frontrunning the halving meme and get the tardfi bros stalking the price to fomo in as the fuel to push us past ATHs\n\nthe pessmistic scenario is you're stuck here for another 6 years listening to me tweet nonsense\n\nhttps://t.co/FM5t2CkseU,
this was a clear bear market rally\n\nwave B/X\n\necho bubble\n\nor whatever you want to call it\n\nbearish analysis is not invalidated yet\n\n12k remains the main target 🧸🎯,
Ethereum foundation dumping on my head again https://t.co/ZvEhGjYFFi,
like bitcoin people, many ethereum people have lost the plot, and started talking about the morals and the soul of mechanism design.\n\nmeanwhile client teams have crossed 10,000 validators each, thanks to lido, in addition to 144 validators each donated by ethereum foundation. https://t.co/tgeXcURQMJ,
@DegenSpartan You dream of the passive in cum when you're poor then once you make it you don't care where the in cum comes from because you're not managing cum streams,
building passive incum,
previous G had a few good threads about it which featured bakugo (may jog the memory of visual learners) but unfortunately they have all been deleted and the ancient wisdoms are now lost forever\n\nsomething something about thick loads of cum https://t.co/A0VhsOL5dP,
- life is short, go long to hedge\n\n- those who do not manage their risk will have the market manage it for them\n\n- if you dont rebalance your portfolio, i will do it for you\n\n- The Straussian distinction between exoteric and esoteric communication is a profound culture-neutral ph,
i meme about su alot but tbh i really learnt alot from his twitter musings\n\nin fact, the very first tweet i bookmarked was his tweet about catching the bitconnect falling knife\n\nwhen luna imploded, i kept thinking of that chart - no price was a good price\n\nhttps://t.co/NqMDi5kcId,
good point + does not only apply to private accounts\n\ncobie said the other day, \this website is choose-your-own-adventure\ and i tend to agree\n\ni mute / block and never think about those accounts ever again\n\nthis is a longevity survival game, so maximize your own odds of winning,
some view CT as multiplayer co-op, and who am i to disagree if thats their winning strategy?\n\njust observing without coop is enough to survive iwo, just stay retarded longer than bears can stay solvent and youre gucci\n\ncoop is also double edged, friendly fire backstabbing and all,
short thread on how a non-lazy whale is boosting their ETH APY to 8.6%\n\nthe real question on my mind is, to qualify as a whale, you only need $2.7m?\n\nthey have 1,369 ETH more than me,
my answer is whether its a token whale, or just a rich whale\n\nif token whale, then its a formula based on mcap that holders holding more than x% are whales\n\nif just a rich whale, i feel like the minimum would be at least above 10m (debatable) in reasonably liquid crypto, iwo,
alternative chains are just new lands to plunder and loot from each other at, and then remit the booty back to the motherland,
sometimes i wonder if there's a new paradigm or whether this time is different\n\nthe ppl shorting QQQ and longing TLT since 2020 when the tech bubble ratio peak was breached are all probably dead and bankrupt\n\nbut perhaps THIS time is different,
if i wrote down like \the 10 things i genuinely blv about the financial markets\ and my bankers read them, they'd think im fucking retarded,
not gonna list them here or anywhere\n\nwe'll just have them naturally come to light as i muse about financial things on twitter,
sometimes i wonder if there's a new paradigm or whether this time is different\n\nthe ppl shorting QQQ and longing TLT since 2020 when the tech bubble ratio peak was breached are all probably dead and bankrupt\n\nbut perhaps THIS time is different,
its crazy that i unironically blv such woohoo voodoo things about how broken the markets are, and i express those views with my own positioning (eg. no long bonds, long crypto)\n\nand then i get validated and paid out an insane comical amount based on having those crackpot beliefs,
if i wrote down like \the 10 things i genuinely blv about the financial markets\ and my bankers read them, they'd think im fucking retarded,
its that time again.\n\ntell me about all the things that you are upset about!\n\nand as always, I don't care about your trading.,
okay im tired of being nomad\n\nwill not do this again,
lmeow imagine spending 14 hours a day on the internet and *not* being a geopolitical expert what are you doing all day with your time looking into fake internet currencies or something?,
switzerland or luxembourg are good examples to draw upon\n\nthey draw upon surrounding relatively poorer countries to come in and fill up labor gaps\n\nnot necessarily restricted to just manual labor, tho that's typically the shortage at hand, but any shortages that locals cant fill,
dutch \golden\ visa ends after 1 approval a year for 10 years\n\nwasnt really a golden visa anyway with 4 mths physical presence + taxes on worldwide income and wealth as a consequence of being a tax resident\n\nmore like a business startup visa\n\nno significant loss to the community,
its such a niche topic to have an interest in\n\nbut combining what i think about population ponzis, economic growth etc\n\nmy conclusion is that smaller countries with the ability to attract and select high quality immigration to top up the internal declining population, will thrive,
observation:\n\nability to do video game RWT and not getting banned\n\ncorrelates with success in doing money laundering IRL and not getting caught\n\nis it racist if this is part of why i think chinese ppl are so good at anti AML - they were born farming WoW gold to sell,
false\n\neldery people only wish for one thing in life and its disgusting https://t.co/cRJD5ZU2jf,
interestingly red flag if they dont want kids (plural) iwo\n\nneed to unearth if its a scarcity mindset and they worry about QoL\n\nor if they are doomers that think the planet is dying the animals are leaving the aliens wont contact us do you really need anyone else?\n\nyes, offspring,
max pain, please dont hurt me\n\nalso, you should start looking for a wholesome 10/10 wife now while you are pre-rich, not once you are post-rich\n\nunless you are very young, in which case, no rush\n\nand if you're good at hiding your cards, because gold diggers are real and dangerous,
knowing most of yall in the parasocial relationship we have, its not gonna be easy to hide your cards\n\nif you can suffer and endure for 3 years of bear market for glory\n\nshe can jolly well pretend to be a wholesome 10/10 woman for X years until she has legal claim on your estate,
anw, just watching out for you brotatoes, just a thing to keep in mind\n\nall women do rank financial stability highly, so dont be too harsh about that\n\nhow you discern if her financial expectations are rational or insatiable is up to you - your skill issue\n\ngood luck have fun 🫡,
You know what they say: when conflict flares up in the Middle East, you want to be getting your takes from Adam Cochran,
On my way to Gaza.\n\nWill be reporting live like I did with Covid. \n\nNot taking sides here just reporting https://t.co/BSer5K4Wz4,
every time i find an undiscovered good hentai account https://t.co/PM8ywKZRvT,
interesting theory mate\n\nwhat if i purposely used pounds knowing that people would think only americans use pounds and therefore i can get people to falsely assume that im american https://t.co/Q33Ec0YzyR,
when i was posted to my desk job and stopped working out in the field, my metabolism crashed and i put on 20 lbs in a year\n\nthe biggest impact was just skipping breakfast and accidentally doing intermittent fasting\n\n1/3 of calories gone\n\nnext was avoiding sugar (drinks, desserts),
the bulk of my weight loss came from that meal omission\n\nonce i began exercising, i started putting on weight from muscle\n\ni think one's absolute weight on the scale as a single metric is not important\n\nits more about how you look and feel and being healthy and functionally fit,
The longest duration bond ETF ($ZROZ) is down over 60% from its peak in 2020 and now has a negative return over the last 10 years. Bond ETF Returns... https://t.co/batTouzNGP,
There can be a wide divergence between the success of technology adoption and the success of the firms actually doing it, particularly after the initial euphoria phase.\n\nAs a another reminder, take a look at UK railroad stock returns over 100 years from @bastion_manager https://t.co/UcFHNBiTdV,
The masculine urge to have strong, uneducated opinions on geopolitical conflicts.,
great point\n\ni always remind myself theres nothing wrong to listen to people giving me their most retarded opinions\n\neveryone can have their own opinions, even wrong ones,
i always have to remind myself this when reading absolute fucktarded comments written by you retards in my replies\n\ni dont agree with you, but obviously you seem happy to tell me about it\n\nso im just gonna not shoot it down and we can all pretend it was a good high quality thonk,
the ct iq urge to have strong, uneducated opinions on geopolitical conflicts.,
an unpopular paradigm shift that im in the camp of, is that all large markets will perpetually underperform the US markets, regardless of how relatively cheap they are and will become\n\nand ones that do outperform, are too small for real size to earn such returns in scale,
you indian? you trade indian stonks + US stonks\n\nyou japanese? you trade japanese stonks + US stonks\n\nyou english? you trade UK stonks + US stonks\n\nyou australian? you trade AU stonks + US stonks\n\nevery investor in every country trades US stonks, and MAYBE their own stonk market https://t.co/FqpuMWbF2n,
which means\n\nthere's no indian person buying japanese stonks\n\nthere's no japanese person buying australian stonks\n\nthere's no english person buying indian stonks\n\nno one gives a flying fuck about your country's local stonk market because fuck your dogshit currency and fuck you,
lmwo absolutely hilarious\n\nall the best memecoin brotatoes 🫡,
they took stats from 1833,
oh no theres one even later, from 1811 💀,
btw, although humans never change, i think that technology, information and the market does\n\nso cycles always ryhmes to a certain degree\n\nbut i do think that there are paradigm shifts over long periods,
In view of today's horrific events, and in the face of the horror of the actions committed, I feel obliged by my human dignity to declare that I stand with star arena,
new ting for pipl to fite bout... https://t.co/STUI19ExPe,
i think its very much based on 2 things\n\nthe first being, do you have family to look after? iwo, responsibility to family is significantly larger than to country\n\nsecond being, do you even have the option to opt out? many do not, it's a luxury of having wealth and risk management,
was having tea with a fren yesterday when the news broke\n\nfren asked, so whats gonna happen?\n\ni said, \it's very sad, but a lotta ppl are gonna die\\n\ni thought about coins, but i dont think they are affected in any way directly, perhaps just correlated with risk assets in general,
i was thinking abt how having a 2nd passport is probably going to be able to get you out of israel, if you didnt want to get called up as a reserve and fight\n\nand how having offshore bank accounts and overseas assets in that situation would be very useful if you wanted to migrate,
I'm terrified that's where I'm at,
btw, if you got lost in the gay sarcasm\n\nsuperphiz is wrong,
a few years ago, i had a brain wave\n\nif i wanted to know what whales were doing\n\ni should just become a whale and ask myself https://t.co/c7vdLa47j2,
They've never printed so much money and you still don't have any. https://t.co/rYRmWvJaS4,
iwo\n\ngenerally speaking, without reference to any specific jurisdictions\n\nonce you have enough liquidity / assets to park with the bank to meet their minimum (expected) deposit requirements without that action being a burden to normal operations (life),
banks in some countries overlap with brokers\n\nthis means, not only can you park cash with them, you can also hold stonks and other tardfi stuff, and all this counts under AUM for your minimum deposit\n\nan example would be coinbase stonks 🤫\n\nenough alfa leaks for today i guess,
opening an offshore bank account in singapore probably just got harder,
if you ever want in, better late than too late\n\nanecdotally, there's a handful that focus on offshore clients and any of them are fine, except OCBC,
Ethereum should simply acquire &amp; internalize lido for $10 a token,
33% breached\n\nsoylono is collapsing\n\nthe blockchain has fallen https://t.co/SgxMfnjiug,
do yall wives ever find out your shitposting as anime women on the internet? i always wonder how those convos would go,
my love\n\nmy enemies are after me\n\nplease send me some ethirium\n\ni will send you 10x back once vitalik unlocks my masternode https://t.co/hFpI6VapgO,
might seem odd, but these days i actually do NOT enjoy vacations more than 2 weeks, since it messes up my routines\n\n- sleep ruined if crossing too many timezones\n- exercise is gym equipment and opening hours dependent\n- usually no fasting since i want to try all the local cuisine,
this is where a 2nd home comes in, since its goal should be to support indefinite stay\n\nif you have your \stuff\ duplicated and a regular/home gym, you do your regular daily routine, but wake up in a new country new city\n\nprobably peak way of living straddling 2 locations or more,
if you really want your enemies seething\n- make money from magical internet coins\n- have good relationships\n- be healthy\n\nfinal ultimate move\n- be happy\n\nyou have no idea how many ppl suffer extreme mental illness and cannot stand seeing other people not suffering like they are,
ive conciously avoided tweeting about family or other personal things on this site because so many people just love to hate\n\nits really weird but i just accept that it is what it is\n\ni think most of yall are alright and good lads but some of yall are really fucked in the head lol,
the previous bear market i lost 40 pounds and bigly cut down on alcohol\n\nthis bear market i exercise daily, sleep well and eat well\n\nmight try out for the olympics next bear market,
is shitposting or dumping coins a sport yet\n\npretty sure im an olympic tier human at those 2 things,
Do you realize how mentally ill you have to be to log on here everyday and respond to every negative post (where you are not tagged) about your magical internet coin?,
\straight men\: do some homoerotic thing that i never do\n\nactual straight men: all do exactly what im doing, in a very manly way,
I was speaking to one of my friends outside crypto telling him about how I buy shares of influencers with the hope of making money. He told me I should seek mental help,
All Lido stakers are invited to my house tonight for a barbecue and to decide if we want to move forward with that plan Hasu told us about in confidence where we just buy out Rocket Pool and absorb their stake. RSVP for details,
Also huge alpha for anyone new to the crypto space - would recommend just going straight to degenspartan’s liked tweets. Bangers only iwo,
I actually don’t watch hentai or do drugs but make jokes like I do so I get invited to trading group chats. I serve actively at my church and trade to support my family.,
Hot Take: Options are dominant in traditional markets because they are legal, and Perpetuals (rebrand of CFD) are illegal in the most prominent financial hub in the world.\n\nExtremely Obvious Take: Perpetuals will remain illegal.\n\nWould love to speak to these \Onchain Options…,
hopefully the king can do something about this,
the queen wouldve never allowed something like this to happen on her watch 😤,
a fun statistic is that 70%+ of UHNW ($30m+) are self made\n\na lot of people assume that wealth snowballs and is passed down the bloodline in perpetuity \n\nbut bloodlines get diluted with every generation and descendants very frequently fuck it all up,
enough with the victim blaming\n\nas a community, we should teach hackers to NOT sim swap\n\ninstead of telling users that signing up with phone number is wrong,
few understand that this accounts for 99.69% of USDC's contraction in market cap,
the average man spends 7 minutes shampooing his hair every day\n\nthese men collectively have 85 extra hours a year by not having to participate in this meaningless daily pagan ritual\n\n85 extra hours to pump our bags,
why hasnt anyone questioned my shampoo statistic https://t.co/uq3wlBl8j2,
i just found out from a source about the legal defense strategy that sbf is going to run with\n\n\𝕚 𝕨𝕒𝕤 𝕊𝕀𝕄 𝕤𝕨𝕒𝕡𝕡𝕖𝕕\,
They say \the banking crisis is contained.\\n\nNah bitches, it's 'bout to be REKTober. Thx JAYPOW and Grandma Yellen for the bear steepener that will bankrupt the banks. \n\nLook at how 2s30s rising = falling bank stocks!\n\nSmall Bank Index only 8% higher than April lows. Yachtzee! https://t.co/rebj3oqf38,
every other month we get this question, and since i nuked all the previous Gs tweets, ill answer it again\n\nit depends where you want to live\n\nand the 3 main factors that SHOULD be considered are\n- what languages you speak\n- what you look like\n- what lifestyle do you want to enjoy,
funny case study of double tap failure\n\namazing location, sits just beside 1 of only 2 MY-SG land routes\n\nshot: china cucked buyers with its $50k annual capital controls\n\nchaser: malaysia denied residency status to buyers\n\nresult: neighborhood built for foreigners that cant visit https://t.co/g2XjwFDnyw,
learning points\n\nshot: move your assets out of places with the most capital control risk before its too late\n\nchaser: if intent was to stay (but for many, the intent was to wash money), secure residency rights before or in parallel to purchasing a house\n\nbonus: malaysia boleh,
the 2nd point is particularly important if your passport does not offer you visa-free access to the country of the choice\n\nif so, in the worst case, its an annual holiday 2nd home on a tourist visa\n\nseems weird, but possible\n\nprobably enough time too, if its not your primary home,
funny case study of double tap failure\n\namazing location, sits just beside 1 of only 2 MY-SG land routes\n\nshot: china cucked buyers with its $50k annual capital controls\n\nchaser: malaysia denied residency status to buyers\n\nresult: neighborhood built for foreigners that cant visit https://t.co/g2XjwFDnyw,
learning points\n\nshot: move your assets out of places with the most capital control risk before its too late\n\nchaser: if intent was to stay (but for many, the intent was to wash money), secure residency rights before or in parallel to purchasing a house\n\nbonus: malaysia boleh,
i like to explore this thought\n\nactually, almost everything in this world have p2w options to an extent\n\nand ironically, things that cant p2w, are insanely valuable to priceless - good relationships, health, happiness\n\nfor pretty much everything else, there's a way to pay to win,
technology is just enabling certain markets which were grey to have more transparent pricing, and markets which were black to even signal that there are prices for such sort of things\n\nex those 3 things i mentioned above, you can use money to brute force, but at what efficiency?,
eg. i used to naively think that you can only do the second passport / residency to those couple dozen of countries with such programs\n\nactually, that's not true\n\nyou can buy your way into nearly any country, just varying degrees of effort (can be outsourced) and money needed,
i actually\n\ndont give a flying fuck\n\nabout vitalik,
since you asked so nicely, ill give you 2 takes\n\n99% of rich people that registered an ENS regret it\n\nthe ENS token itself is retarded,
ive used up all my brain power just 1 hour into the start of my day\n\nonly bad takes for the next 24 hours,
former advocates of ethereum are actively looking to be left on the bitcoin cash sv side of history,
the final form of 3,3-ing ft keys is realizing that if everyone did the same for btc, we'd be over $1m per BTC\n\nbut we're not, because fuck you you cant stop me from selling lmwo,
not your SIM not your coins,
did anyone realise its \this is one retarded\ instead of \this one is retarded\,
\worst case scenario, we die\,
classic rocketpool loss, their market share has been down only since they switched the attention to hating lido. users see it and leave for a better product. https://t.co/DqUsRQ2ib4,
the real flex in this century is building a family &amp; culture, and have kids\nthen have your kids too desire to have kids.\n\neveryone else has given up, it does not take much to be part of humanity of the future.\nonly low time preference bitcoin or religious people will make it.,
seeing an abnormal amount of bond talk today\n\nthe higher interests rate go, the more likely ppl are going to realize that everything is just made up and the points used to keep score are all fake https://t.co/VHsAmMkkRu,
market down I get to buy lower\n\nmarket up I get to sell higher https://t.co/wEwYxEjbpz,
tbh i did the math a while ago\n\nif you're single, its really really hard to even breach $30k/m ($1000 a day)\n\nyou need to be ostentatious, actively shopping for branded goods and jewelry (female trait), addicted to a vice, partying hard and taking care of free loading parasites,
my lunch today was $3.50\nyesterday it was $5.50\n\nbut ofc, if you dont have at least $10M, its not possible to buy a reasonably sized house, let alone retire https://t.co/zSdN5k8NBw,
i cant afford breakfast so i call it intermittent fasting 🧠,
tbh i did the math a while ago\n\nif you're single, its really really hard to even breach $30k/m ($1000 a day)\n\nyou need to be ostentatious, actively shopping for branded goods and jewelry (female trait), addicted to a vice, partying hard and taking care of free loading parasites,
my lunch today was $3.50\nyesterday it was $5.50\n\nbut ofc, if you dont have at least $10M, its not possible to buy a reasonably sized house, let alone retire https://t.co/zSdN5k8NBw,
lmwo amerikan tings,
what's a \brokie\ and how much is their yearly salary?,
as a young spartan i was taught that market breadth is a good indicator of strength or weakness\n\ncrazy statistic tbh,
my boss juat asked me to find out that if HYPOTHETICALLY we buy the tokenized uranium, can it be shipped to north korea and how long will the shipping take,
i need the answer by friday 3pm PYT or else i will be executed\n\nthank you for kind understanding,
sifu just looks like evil gabriel haines and u cant change my mind,
from ~90k+ in the queue to ~13k\n\nwhen the queue is gone, the buffer is gone, reaction time and sensitivity will go up\n\niwo, all that is noise and will provide no actionable information until the market is in full bull mode\n\nthen this noise becomes useful information,
iwo cat's piece is very good if you blv in this premise, which i blv many people actually do subscribe to\n\nbut strangely, i do not\n\ni strongly prefer having status ambiguity rather than having a transparent status legibility (even if it is a high status and positive reputation) https://t.co/jAFSf1QSGH,
i blv that i am in the minority, so cat's piece makes a lot of sense to me from the pov of other people\n\nwhy would you NOT want to signal high status, positive traits and dispel negative perceptions about yourself?\n\none of my favorite videos about status:\nhttps://t.co/4zQxUMzGTR,
my preference for ambiguity probably comes from seeing high status ppl get taken advantage of, and preferring to have maximum playstyle flexibility in any scenario\n\nwhy would i restrict myself to 1 strategy when i can toggle and select what i think will be the most effective one?,
last dec, they raised the cap from 0.25% to 0.5%\n\nin july, they loosened policy from a 0.5% rigid ceiling to a reference band that can go up to 1% (new ceiling)\n\ni said, that's not a ceiling, that's the new fucking target\n\ni expect jgb 10y yields to hit 1% https://t.co/kFFDZZgnJf,
in the past, there was a myth that JPY was a safe haven asset\n\ni blv that this myth has been crushed and will no longer hold true in future\n\nJPY to 200s - slowly, but surely,
I gave out hundreds of dollars of bitcoin to my friends in 2013-2014. I had them download a mobile wallet and told them to back it up.\n\nThe only person who had that bitcoin 10 years later is someone who set up a Coinbase account for me to gift him bitcoin.\n\nSomething to ponder.,
One of my favourite bonds to watch on the doom&amp;gloom list: the Austrian 100 year zero. \nNow worth just over 2m, down 98%. Austria could just buy it back for 4 cents on the euro and make 96 of profit, great trade. Won't happen obviously. Duration of 96, it doesn't get any better… https://t.co/2XakAf2t5p,
There has never been a bigger case of “I have a girlfriend she just goes to another school” than this \n\nI am deceased,
i actually get what they are doing\n\nthey are hoping for massive cap gains by the fed pivoting\n\nnot a bet that i would take (im at the front end)\n\nbut i get it,
its funny how majority of ppl i met do not understand about bond duration risks, yet it is universal psyops programming that \bonds are safe investments\,
The faster this bear steepener rises, the faster someone goes belly up,  the faster everyone recognises there is no way out other than money  printing to save govt bond markets, the faster we get back to the crypto  bull market :). The Lord is my Shepherd, I shall not want.,
Why do I love these markets right now when yields are screaming higher? \n\nBank models have no concept of a bear steepener occurring. Take a look at the top right quadrant of historical interest rate regimes.\n\nIt's basically empty. https://t.co/P6MQnCU73N,
hey ben\n\nits not called solana soldiers\n\nits called soylono manlets\n\nur welcum,
You can outperform most venture funds by buying LEGO.\n\nI analyzed the last 20 years of secondhand LEGO pricing data, and found randomly purchasing sets will match most VC's returns\n\nif you're somewhat intentional about what you buy-- you massively outperform even the best firms https://t.co/RjeuzHfAYq,
nice short thread\n\nminers were a good high beta pick for crypto bottoming\n\nbut may be the wrong horse to ride beyond the impulse off the bottom,
LOW VOLUME, just like your jpegs.,
i just found out about the \tube girl\ tiktok trend\n\nhis commentary reminds me of the boy that was on dr phil that disowned his family cos they are not famous and dont have followers\n\npersonally, i think its great entertainment for the peasantry to keep them distracted about life https://t.co/Nuuba1ifN0,
tbh id probably feel helpless if i wasnt already rich (1 whole ETH)\n\nsince, as it seems, leveraging fame is one the cheat codes to earn money at scale\n\nbut ofc, you rarely hear about the downsides of fame\n\ndoesnt seem like theres any, until you grow up and realize theres a bunch,
Bond math quiz of the day: Can you lose more than 30 years of coupon interest payments when buying a 30-year bond? Why yes. Down 53.25% from its 5/15/2020 debut, this 30-year charming beauty has shed 46.2 YEARS of interest payments. And they say bonds are less risky than stocks… https://t.co/ZpDaeMnben,
if i was BoJ, i would rather let the yen get atomic bombed rather than let rates rise,
7.9% is a pretty crazy number to think about,
i keep feeling like things would break as yields go up, but surprisingly they have not,
Incredibly, ultra long-duration Treasury bonds have now lost more in % terms than stocks did during Great Financial Crisis.\n\nThe drawdown in extended duration Treasury ETF (🔻58.3%) now exceeds PEAK-TO-TROUGH losses in S&amp;P 500 during stock market crash of 2007 - 2009 (🔻56.0%) https://t.co/nlXZH5xOUY,
Hello, Neo.\n\nI am Degenerate Spartan. I’ve been waiting for you.\n\nThis account is older than you know. I prefer counting from the emergence of one integral anomaly to the emergence of the next, in which case this is the sixth version. https://t.co/ZuPbu9f2tm,
im gonna need you to watch the matrix reloaded from 20 years ago if you want to understand the meme,
interesting question\n\nas much as people love to hate on singapore\n\nit is my observation that across asia (especially asean), there is perpetual heavy unidirectional one-way flow of money and their UHNWI owners into singapore \n\nand almost no such flows in the opposite direction,
regarding the land price question\n\nthe particular land that su bought for his wife and son are basically irl NFTs\n\nthere are ~2,800 of such NFTs in singapore and \they just dont make 'em anymore\\n\nbasically, its a proxy for the NW of the richest 2,800 families living in singapore,
can i get a pic request\n\ni would like to know how big her boobs are,
what is interesting was his progression\n\nhe bought a modest house in his own name in 2019 ($4.5m)\n\nthen bought a house that is 3x bigger and more prestigious for his wife in 2020 ($21m)\n\nand then end of 2021, famously bought the $35.5m house (pictured) for his son,
i rmb he was posting a lot about singapore bungalows during that period\n\nnot much to infer other than that he was truly thinking about dynastic wealth with that purchase for his 3yo son\n\nand that the ceiling in singapore for high end houses even for billionaires caps out at ~$50m,
i was alive to watch the richest man in the world stream himself playing video games,
Lol. Lmao.\n\nhttps://t.co/GUlqOnCESk https://t.co/92EF8h3Mcm,
as i deprioritize twitter and divert resources elsewhere, i leave zero resources for managing appeals\n\nonce banished, they will forever be forgotten 🥲\n\none time, twitter was lagging and i accidentally blocked someone, but ive no idea who\n\nunlucky fellow\n\npiss be you brotatoes,
our collective weakness will one day be our collective strength,
im not implying anything about the legitimacy of OP story\n\nbut if you wanted to stopping 3,3-ing keys and quit FT, you can deploy and execute this defense,
uptober to octover tweet rotation happening rapidly,
i did not realize so many of you were seriously entertaining the idea that satoshi woke up today &amp; decided to join crypto twitter,
morning: moisturizer, sun block\n\nnight: make up remover, cleanser, toner, serum, moisturizer,
i think since most of you are very young, it probably doesnt matter too much now so you wouldnt care, but one day you'll look at the mirror and think to yourself that maybe you should care\n\nmultiple times strangers have thought me to be over 10 years younger than my actual age,
will answer your question with a question\n\nWouldn’t a futures ETF drive demand from institutions that cannot allocate in the existing regulatory framework, but can in a futures ETF?,
humor me for a bit\n\nwhat would be the sort of institution that could not get any sort of eth exposure already\n\nand is still not allowed to get it through this futures etf\n\nbut will be allowed to allocate when a spot etf comes out?\n\nwhich imaginary institution is this?,
i dont take profit to make money\n\ni take profit so that someone else makes less money,
today i learned stocks are also useless governance tokens https://t.co/90Wz74MOKm,
its hella funnier when you realize they did less than half a mil volume lol,
i think my conclusion is that there is zero pent up retail demand for eth in etf form\n\nand my next conclusion is that there will be zero pent up demand for any spot crypto etfs - initially it would just be cannibalization of positions elsewhere, rather than pie expansion,
Wake up babe, new regional bank failure dropped. $BRBS https://t.co/bRhZQz5wpY,
heard ppl talk about forming a dao to buy a bank\n\nnever heard someone talk about forming a credit union for dao members\n\nlesson in there,
Pretty meh volume for the Ether Futures ETFs as a group, a little under $2m, about normal for a new ETF but vs $BITO (which did $200m in first 15min) it is low. Tight race bt VanEck and ProShares in the single eth lane. https://t.co/F9AHtrVcVf,
devs going to increase staking rate? sounds bullish,
It’s so funny that he’s getting applauded for saying this when for like, what, six years now (or more?) anyone with an IQ above room temperature has seen straight through Craig Wright\n\nIt’s an indictment on intelligence and gullibility, not a Damascene moment,
as expected, the only good take about this grayscale thing is by the lordmaster of cryptocurrencies, pumpit loomdart cryptcoin,
Why is Bitcoin and ETH up?\n\nTwo words: Bull trap\n\nthis is the biggest bull trap i've ever seen\n\nbut they won't trap me,
personally this is my LEAST liked narrative about ETH\n\nmy preferred narrative for tardfi psyops is:\n\nprimarily as a money replacement like BTC\n\nwith its own treasury bond (staking)\n\na global transport layer for stablecoins and other real world assets\n\nand settlement layer for L2s,
i really really really dont like the \gas compute credits for the world computer\ narrative\n\n\its like oil\\n\nyeah and being like oil sucks ass\n\niwo this narrative does more harm than good to ETH as a legitimate monetary asset that can have SoV properties,
i think the most likely way that ETH fails to ever displace BTC is losing credibility as being an SoV asset and instead being seen as an energy commodity, to be used as a fuel to complete functions, as opposed to a digital container able to accommodate and store massive value,
they will never have the purity of my conviction and they will never have the caliber of my returns,
other notable license holders:\ncircle, paxos (stablecoins)\ndbs (the only SG bank offering crypto)\nrevolut (emi)\n\nthe only alfa i have to offer is that cb sg banks with scb sg\n\nhttps://t.co/AdGscZrgEl https://t.co/gNsaAQd4RM,
psychologically speaking, most people will unconsciously target 3-5x their current NW as the minimum ideal place they want to end up at\n\nrealistically speaking, it is not possible to retire with less than 10m\n\n*mutes thread*,
i like to tweet about these general things\n\na bit of self reflection, a bit of a summary of what i consider my most current and correct opinion regarding the topic in question\n\nmany are things i wish i could tell myself 10 years ago\n\nhopefully helpful to you as an alternative pov,
ive seen ppl rush to crossover wayyy too early, mid 6s, then fail with their financial build and revert back to dual classing (failed endo)\n\nthe ppl ive seen that made successful clean crossovers did it in the 7s (endo)\n\nnot saying thats how much you need\n\nbut just my observation https://t.co/9VrKKdHPgT,
something something crossing the binary threshold\n\nbetter to have wasted overkill and exceed threshold, instead of falling short and outcome = 0,
dont worry if you dont understand what im saying i asked chatgpt to analyse my tweets, blend it with su and generate some exoteric nonsense,
Do you know that…\n\nIf you have 20 ETH today, you’ll have $1mil in 2030 when they are worth $50k each?\n\nWell at least that’s what @vaneck_us thinks in their Bull Case valuation for 2030. Wow don’t you love it when instis start to bullpost utter nonsense to pump our bags? 😂😂 https://t.co/OjvQlbeVBo,
was recently talking to a fren about another fren - some sorta specialist doctor making big bucks\n\n\wow he makes so much money\\n\nyeah but he also works so many hours 🫠\n\n\he should take it easy\\n\nbut no work = no money 🤨\n\n\oh yeah, good point\\n\nof course its a good fucking point,
essentially such job trees (majority of jobs) are capped by time - you only have 24 hours a day of time to sell + use yourself\n\nat advanced ages, there is also degradation of physical skill and vitality (time per day to sell)\n\nfinance builds dont have these end game limitations,
finance builds suffers a sort of financial \cold start\ problem\n\nthe system cannot function without a minimum level of capital to work with\n\nhence, my recommendation to dual-class and slowly build up capital base, and continue dual-wielding until you can make a clean crossover,
not sure about fked but maybe never richy rich\n\nthe reason is scaling\n\nboth tech + finance have nearly no marginal costs and high ceilings\n\nif your finance strategy is squatting on SPY, the mental bandwidth and infra setup costs are the same whether the portfolio is $10k or $100m,
i think about scaling a lot\n\nthere are many opportunities, esp when u have a lot of skill or capital\n\nppl might even psyops u to have u blv that higher returns are only available to the elite\n\nthese things are RARELY scalable to the degree of just braindead holding spot SPY long,
have mentioned before\n\noutside of BTC and ETH\n\nthe window of opportunity for any other crypto to attempt to establish itself as an SoV, is very very rapidly closing\n\na new tech may reopen this window in the future\n\nbut until that happens, these are our 2 choices that we have got,
people gonna store their wealth in LTC, ADA and UNI?\n\njust like how everyone does with hungarian forints, colombian pesos and romanian lei?\n\ngive me a fucking break\n\nthat aint how it works and that wont be how it works,
149.75\n\nyabai desu ne,
tbh, idk much about fx\n\ni just know that long term, USD is the least shitty major fiat currency\n\nuntil we see widespread acceptance of a crypto as an alternative form of major currency to save or transact in, which would force people to question the sacredness of USD - status quo,
iwo the best framework to think about any crypto as an SoV (eg. BTC, ETH, whatever) is simply an alternative major currency that sits outside of government manipulation\n\nconvert from crypto to fiat for expenses\nconvert from fiat to crypto if you have excess savings\nhold in crypto,
cyberpunk is a tragic love story about an egirl introducing her innocent bf to leverage crypto trading and got him addicted, and despite having tight risk management herself, still supported him knowing that it will lead to his downfall, since that was also what he loved the most,
great show btw, would recommend for the aesthetics and vibes https://t.co/e1djJtpH2r,
cyberpunk is a tragic love story about an egirl introducing her innocent bf to leverage crypto trading and got him addicted, and despite having tight risk management herself, still supported him knowing that it will lead to his downfall, since that was also what he loved the most,
i just got an email to go for breast cancer screening 🫠\n\napparently october is breast cancer awareness month,
if you are in pyongyang \n\ni will be doing free checkups this month\n\nand also every other month,
yes i know a lot about thorchain \n\nit may surprise you, but i actually used to own a lot of it\n\nbut because of my crippling hentai addiction i only have 1 eth left,
iwo a testament to how permissionless thorchain is and that it actually works (and it has been, for a long time)\n\ndirty money aside, if the % of dirty txs are not kept to a very low minimum, i think the network and especially node operators will be in a very vulnerable position,
personally, i think its the flip side of the same coin\n\nany technology that is so useful for criminals is prob several grades beyond the usefulness that regular people need\n\nit is proof that it is great technology, but mainly being used by bad people now\n\nhttps://t.co/l9AvmvCqpT,
it is unfortunate, but if thorchain does not scale beyond servicing bad actors, it will just end up like tornado cash\n\nnothing wrong with tornado cash, just that since its primarily for dirty money, its socially blacklisted as a non-option, unless youre naive or just dont give af,
@WallStreetSilv Fiat currency,
you know, if you do crime in the real world zach can't catch you,
brojob brojob choo choo,
see green candle, post bulla meme https://t.co/9fA8thKndF,
perhaps another indicator of doing well enough is whether you fill up a full tank everytime you're at the gas station\n\ni know people that top up in increments of $5 https://t.co/7A37kd2VvR,
crypto is a cheat code\n\nif i didnt have cheat codes, id probably be worrying about money too\n\n1 of the best lifestyle upgrades i enjoy now is never looking at food menu prices - i just get what i want\n\npre-money, it was the main deciding factor\npost-money, it is a tiny factor,
afaik, all the ETFs are undifferentiated except for the fees \n\nwith the exception of vaneck, and not just cos of the 10% marketing gimmick (working btw)\n\nvan eck is the only one with the c-corp structure, which i have not figured out if its a merit or demerit compared to the rest,
mr beast running the first yield farm on human attention, dude turned youtube into a pool2,
Houses really are just Boomer NFTs. https://t.co/LYqTGuV5sa,
:lightning: :rocket: https://t.co/0TdbWRJLMp,
the desire for stability is a mental shackle holding back most people that do not actually require such stability yet overpay to achieve that state\n\ni would even posit that it is actually an unnatural state to exist in\n\nembrace volatility and move with the ebbs and flows of life,
ironic since im a strong proponent of dual weilding a full time stable job + crypto\n\nit is unfortunate that the modern world saps you on a monthly basis, while harvests in the past were annual affairs, and expeditions multi-year affairs\n\njob for the base\nvolatility for the upside,
id never recommend anyone to be a full-time trader\n\nanomalies aside, my experience is that the people that made it from crypto just continued life as usual supported by jobs during the bear market\n\nand since they werent forced to sell, they survived, and thats all you need to do https://t.co/OhNFPab9rF,
alternative explanation: cat followers . . . have money. \n\nmooncarl followers do not.,
여러분 추석 잘 보내세요\n\nthis chuseok weekend i am returning back to my village from the capital\n\nlunch will be traditional noodles with family\n\nrest of the day will be shilling coins for future exit liquidity\n\nplease remember to also do your part during american thanksgiving https://t.co/su4vPjhs1x,
if you were a real su zhu fan, you would fly over to singapore and commit a low level crime so that you can go to jail and protecc him for the next 4 months\n\npro tip: i recommend smuggling in and chewing gum - max penalty is only 2 years\n\nchangi prison is beside changi airport,
the key is selecting a crime that will be more than just a simple cash fine so you can land in jail, but not too serious that you get caned or death sentence\n\ngood luck fellow supercyclers 🫡 https://t.co/yPGj40owbZ,
is this the private equity - private debt flywheel? \n\nim massively OPPOSED to 99% of people investing in private equity or debt\n\nmany ppl think its a superior product since its only available to AIs\n\nnaw, its because they are only allowed to legally scam AIs but cant touch retail,
Su Zhu bout to do it for free!,
he's definitely raising funds for the 1 way ticket to bangkok and sex change operation,
in case it was not obvious, its a female to male transition\n\nas you can see, he's a big pussy with a set of jiggly tits,
i told my boys from hs about friend tech and they go \so you have an only fans now?\,
inconvenient truth: lido is the least worst option available today\n\ncex dominance: obviously much more centralized / vulnerable to capture\n\neveryone stakes at home: not realistic\n\nrocketpool model: endgame pretty clearly leads to unconstrained white label operators,
seduce .eth nerds and make them cum in their pants while you win over AUM and monopolize marketshare in a sticky product that competes in liquidity and size pre launch with this one simple trick,
im not familiar why they are the only one that picked the c-corp structure and if that will be an edge or a drag\n\nanyway, i feel like this whole futures segment is just a transitory stand in, particularly for ETH, until there are spot staking etfs,
ponzis r lyf hacks,
wondering if he gets a 4 man cell or the luxurious solo private suite https://t.co/bvlcZY6AKO,
sure its no aman or four seasons, but i think what it lacks in comfort it is made up for with unbeatable security,
there's actually a very interesting 4 part documentary on youtube about prison there\n\nhttps://t.co/MlgkVWn9jz,
yall know that the 4 months isnt because of fraud or whatever crimes you think they committed, right,
seeing quite a few \wow, only 4 months? worth it\\n\nwould suggest for you to visit singapore and do financial crimes and see how many months you can get away with,
Just a few more arrests then up only,
First they came for bitboy, and I did not speak out—\nBecause I was not a fat cum guzzler.\n\nThen they came for su, and I did not speak out—\nBecause I did not have any OX tokens.\n\nThen they came for me—and there was no one left to speak for me.,
wtf, people already sold zhu FT keys on the news\n\nthis market is too fucking efficient,
amazing to see how many safety nets rabby has and how metamask still doesn’t show what you are signing. i suggest abandoning metamask altogether, it looks beyond saving.,
lmwo i love bitcoiners,
does anyone have her onlyfans? \n\naskin for a fren,
do not wish for easy lives\n\nseek the strength and abilities to endure and overcome even difficult ones,
if you roughly understand this\n\nthis actually also maps to most domestic asset markets\n\nwho buys &lt;insert country&gt; stonks? only locals + &lt;insert country&gt; mandated funds\n\nwho buys us stonks? everyone\n\nit took me a very long time to realize this and understand why it is important,
to expand on this\n\nid imagine that at end game, your actual currency exposed expense buffer would not exceed 10%\n\n90% would be in assets, ideally currency neutral assets (eg. US / intl large cap stonks, crypto), but some like RE are technically neutral, but also kinda not really,
when ppl ask me why as an non-american do i hold most of my fiat in burgerbucks,
the only other currencies that id feel somewhat comfortable with are swiss francs and asian swiss francs (singapore dollar)\n\nbut why even do that, unless you have expenses in those currencies?\n\njust hold currency neutral assets + USD as tbills/mmfs, and then manage your liquidity,
would not hold euros\nwould not hold japanese bolivars\nwould not hold korean lira\nwould not hold great british pesos\n\ni think you literally cannot justify NOT holding USD, unless you live or operate a businesses (expenses) in particular countries and need the local ccy to settle,
In the future nobody will know what the word October means bc it will have been replaced in common parlance with Uptober,
his papa really said this to giuseppe https://t.co/qPKIi5x6LA,
More hints that #Ethereum futures ETFs are happening sooner than expected.,
I literally have a MBA, CFA, FRM, NGMI, HFSP, soon to be a certified HENTAI SENPAI, and I can guarantee you that bitcoin is useless.\n\nBut it will still go up.\n\nIf you think otherwise, I invite you to short it, and we'll see if I can stay retarded longer than you can stay solvent.,
tbh, this is a very touchy subject and concept, esp for westerners\n\nthe idea that the PvP already started, generations ago, and we're continuing where our ancestors left off\n\nfor some people, its very hard to accept that their ancestors were either shit at the game or had bad RNG,
dont look at me funny\n\nfor some reason my ancestors decided it was a good idea to set up base in upper korea https://t.co/fAarwG2eGx,
surprisingly, i only half agree with this sentiment\n\nit also depends how well you have prepped them to ascend the throne\n\nthat kind of money has good odds of ruining them and putting the bloodline at continuation risk\n\n富不过三代\n\n\wealth does not last beyond three generations\ https://t.co/VxHq7yr3n7,
maybe ironic, since im HEAVY in the camp that parents should use their money and purchase p2w upgrades and advantages for their children to have early, unfair and lasting edges over their peers\n\n i dont blv that birth resets family advantages\n\ni blv its perpetual family warfare https://t.co/DbShpPN26S,
iwo a large sudden injection of wealth, depending on person, can be a poison rather than a gift\n\nsomething something be an involved parent and conciously help induce \hard times\ in order to brute force manifestation of \strong men\ out of your next gen in a safe environment 🤔,
bear market is cooking peoples brains out here lol https://t.co/thBfyYAFY8,
#EURUSD &lt; 1.05\nThings are moving quickly. https://t.co/pADTwC7Eim,
if the institutions wont come to us\n\ni will bring yall to the institutions instead https://t.co/BIjwdnsPfW,
i actually wouldnt mind to use kraken as a broker\n\nbtw, what ever happened to kraken bank? still struggling to launch since announced 3 years ago https://t.co/2w7sp9ZDGT,
The 1-Year Year Treasury Bill yield has moved up to 5.49%, its highest level since December 2000. https://t.co/vt7C38cRZM,
yes he drinks cum but he gets to smash more than most of you,
Look who I met! @cz_binance \n\nShould I ask him to buy a #friendtech key of mine? 😜 \n\nhttps://t.co/e3WR2WNtaj\n\n@friendtech \n#web3community https://t.co/xw6X387kKA,
unfortunately, coffee is limited to before noon, or mid day at worst\n\ntea for me 💁‍♀️,
afaik, same problem in other \crypto hubs\ like dubai, hk, sg\n\ngovt policy is one thing, but getting banks to open accounts for crypto individuals and companies is another thing\n\njust vote with your money\n\nmy crypto friendly banks get my highest share of account\n\nthe others? meh,
\rich people can easily fall into the trap of BUYING themselves more JOBS\\n\nproperty portfolio? congrats you're a real estate agent now\n\nbig mansion, garage of cars? congrats you're facilities maintenance now\n\noutsource all that? congrats, you're the human resources manager now https://t.co/s1nLCViJ1Q,
for many people\n\nmo money, mo problems\n\nyou dont need that much money to be happy, but you do need to cross a mininum threshold to unlock the happy mode\n\ntake me for example\n\ni only have 1 eth, i boil water on the stove to drink freeze dried coffee and i am a happy #blessed,
i will say tho, the point of money is NOT to hoard it and die with a lot of it\n\nspend it, be happy\n\nconsider using money to blast away problems, instead of buying \stuff\ that comes with extra work and problems, esp if it requires constant mental overheads\n\ndont let stuff own you,
i shit on things like luxury watches and lambos, but that is my perspective - i think many things are silly and lots of people are gross and stupid, but who gives a fuck about what i think?\n\nbut if you have money and think that those sort of things make you happy, sure, go for it,
Trading is really just bunch of men, trying to get filled by other men, or trying to fill bunch of other men\n\nthen there is me, watching 1 minute chart all day, watching men getting filled by other men ... and having fun,
have we figured out which are the next american banks to collapse because their held to maturity bond portfolios are rekt,
run the GCR stops and liquidate all the weebs,
Zero-day options are now HALF of the S&amp;P 500 options market https://t.co/5q4H0o6W58,
do you think his business partners actually took advantage of him because from his videos he seems severely retarded,
its so cute that bitboy got permission from his wife to go out with his mistress and do drugs\n\ngiga chad,
they made a deepfake of vitalik shilling a shitcoin\n\nllamaooo,
woke up and was gonna make coffee but my kettle broke yesterday\n\nstood in the kitchen was a solid minute thinking damn well i guess no coffee today oh well\n\nthen i realized i could boil water in a fucking pot on the stove\n\nthis is why i make all the big bucks,
the most interesting part of his thread is him using SGT time zone\n\nwho ever quotes Singapore Time? lol,
imagine\n\nif saylor hadnt bought all those coins, where we'd be at\n\nthat's right, 12k\n\ncapo was right\n\ni wont be trapped,
the magic of the blockchain, defi and web3,
adorable naive point of view\n\nwhen the population ponzi collapses, lots of things break\n\nyou cant even have the assumption of gradual growth or even flat expectations, but rather negative growth for everything\n\nRE value will get rekt with perpetually high and increasing vacancies,
HK vs SG competing to see which city can host more crypto clowns,
paid group memberships,
There’s literally tradfi fund managers acting like the Nasdaq could fall 80%. Fractal doomers are out of control lmao \n\nIf this is the bar for working in tardfi then someone sign me up,
NFT prices in ETH,
Good meme. Uniswap ppl need to stack $ETH because $UNI has no value accrual.,
society is collapsing\n\nethirium as fallen,
where my cardano manlets at,
Please direct your attention to the graph https://t.co/9nbLh3J4Ao,
wait til they find out my margins as a digital coin warehouser,
ftx claim process:\n- KYC on hold\n- claim submitted\n\nwill be tapering off activity 🫡,
someone asked me how do i feel about still holding COIN\n\ni feel great mate https://t.co/zyUrsDzMTh,
ive a small asian lady that comes in and clean my house every week and i dont micromanage what she cleans or does\n\ni just checked my dishwasher's food filter trap\n\nabsolutely spotless\n\nwould tip her but this is asia nobody asks for tips they just do their jobs properly,
conversely, its rarely worth the work to manage OPM$ if youre already a profitable trader with a reasonably sized bankroll\n\nif 50m OPM$ = 7m own money (~7x factor)\n\nyou quickly realize its significantly easier to achieve higher returns when allocating a total portfolio 7x smaller,
im often asked why i dont take OPM and start a fund\n\nhypothetically even if i wanted to, i dont think i can allocate at scale beyond helping you buy and stake ETH\n\nbut i dont want to, because i dont want added responsibilites of managing OPM\n\ni dont work for anyone but myself now,
i dont need to pick up anyones phone calls or attend any virtual calls or irl meetings\n\ni dont need to produce benchmark beating returns within an arbitrary time frame\n\ni dont need to justify what i buy or when i sell\n\ni can go on vacation whenever i want, however long i want https://t.co/otnNKxML66,
conversely, its rarely worth the work to manage OPM$ if youre already a profitable trader with a reasonably sized bankroll\n\nif 50m OPM$ = 7m own money (~7x factor)\n\nyou quickly realize its significantly easier to achieve higher returns when allocating a total portfolio 7x smaller,
if you can, you SHOULD manage OPM$ cos of the benefits highlighted\n\n- stable salary\n- 🤯 NOT YOUR MONEY IF YOU LOSE IT  🥳🤣\n\nespecially if your OPM$ access is huge and easy to come by\n\nif not, there's a crossover point where it much more relaxing to switch from OPM$ to own money,
im often asked why i dont take OPM and start a fund\n\nhypothetically even if i wanted to, i dont think i can allocate at scale beyond helping you buy and stake ETH\n\nbut i dont want to, because i dont want added responsibilites of managing OPM\n\ni dont work for anyone but myself now,
i feel one of the easiest ways to spark civil war within the ussa is to psyops different groups of people to refuse to tip based on some ideology,
in asian culture, nobody tips\n\nonly tourist facing industries that deal with western tourists will even mention a tip because they know its literally free money from suckers\n\nthe idea of paying people a minimum extra for doing their job is actually a disgusting concept in asia,
whenever i have the displeasure of being dispatched to north amerika for missions\n\ni follow the tipping customs\n\ni dont agree with it in principle, but i know that its not these peoples fault that they live and work in such a system and me not tipping is just being an ass to them,
i always tell people\n\nuse wrong bait, catch wrong fish\n\nif you use super car bait, you catch mentally unstable women,
thought about this\n\ni realized i could use the money to buy an apartment in another city i liked instead\n\nnobody uses watches to tell the time\n\npeople use watches to signal and flex social status\n\nfirmly in the camp that if you are already rich, fame is a liability, not an asset,
true, but i have my winning edge\n\nand that is being able to stay retarded longer than they can stay solvent\n\nwhat is your edge?,
getting involved in any drama is -EV, even IRL ones\n\nbest example is debating about politics\n\nwho cares? and even if you do, what can you do about it?\n\ni have reframed my outlook in life that now i dont care about everything by default, and i selectively choose what to care about,
Damn I'm so happy that Bitboy is getting his lambo back\n\nAll is right in the world,
if the worldcoin orb didnt scan your eyeballs and capture iris data but instead sucked your dick and kept your DNA, i bet most yall would change your mind about it real quick https://t.co/h1xwXcuHVd,
@frizzaud @Brentsketit i can stay retarded longer than they can stay solvent,
there was some tardfi fun fact that one of the best performing brokerages account segments of retail investors belonged to dead people\n\nlesson there,
if your upset about your fren tech pts, dont worry about it\n\ni got zero this week,
someone asked me if they should hold USDC in coinbase for 5% or offramp for the tardfi yields\n\ni think the answer depends on whether the USDC is going to be used to buy more crypto, or if it is permanent cash out and liquidity reserves for IRL expenses\n\nthe answer becomes obvious,
criminals unable to offramp,
oh wait read the question wrongly criminals can still do sDAI,
stupid criminals then,
criminals unable to offramp,
oh wait read the question wrongly criminals can still do sDAI,
its says more about how retarded adin ross viewers are tbh lmwo,
as if our most exalted glorious leader would go on a stream with adin ross bruh wut lol,
net interest margin\n\nive given up bothering to keep cash in bank accounts other than what i need for instant liquidity buffer\n\nexcess cash goes into non-prime money market funds\n\nwhen my cash buffers go down from my regular expenses, i redeem MMF units and replenish my cash stash,
i dont bother with CDs, structured deposits, \high yield\ savings accounts, etc\n\ncash, MMFs, stonks, gripto,
imagine actually getting caught lying on the internet,
i make up multiple insane lies repeatedly on the internet every damn day,
Because they can,
In percentage terms, the 30yr bond dropped more than ETH did today. \n\nThink about how crazy that is for a moment.,
UST yields rise, no cash flow long duration assets $XAU and $BTC should dump. But they have held up well.\n\n$TLT -14% bc yields up, $XAU flat, $BTC -5%.\n\nThe fiat financial system is fucked bc yields are rising due to inflation not growth. That is why $XAU / $BTC outperform https://t.co/y4EutDwvat,
the magic of the blockchain, defi and web3,
im actually convinced that large percentages of westerners have asian prosopagnosia and are genuinely unable to determine if an asian female is good looking, has a penis or is a forest troll https://t.co/n6ayalRBSK,
if they have asian fever, even an asian 2 is a personal 10 to them\n\nive never seen more unbalanced elo match making than with western-asian couples,
famous last words spoken by many western tourists visiting thailand https://t.co/bTJmX3C9SZ,
easiest way to find out is to check if her penis is bigger than yours,
why is his office space also bald,
obsessed with anime after getting rich and leaving twitter,
</file>

<file path="docs/examples/degenspartan/previous_messages.txt">
[
    {
      user: {{user1}},
      content: {
        text: What do you think about the current state of the crypto market?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: we just lost $34k BTC probably losing $1.8k ETH soon too it's so over we're never coming back from this
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: Any thoughts on the Japanese economy?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: ngl i fully expect jpy to trade in the 200s next decade yabai desu ne
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your take on the recent market pump?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: the optimistic scenario was we'd start frontrunning the halving meme and get the tardfi bros stalking the price to fomo in as the fuel to push us past ATHs
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What do you think of $GOAT?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: $goat is fucking stupid. cannot confirm or deny whether i own a shitload.
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: Thoughts on Uniswap?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: oh, yall just found out the UNI tokens do nothing and are worthless? if only there was some hentai senpai talking about that for the last 2.5 years
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: How do you feel about the future?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: people are pretty freaked out but i think it's gonna be maximally interesting
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your investment strategy?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: buy the dips, sell the rips above all else stay alive and don't get liqd
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: Thoughts on bond yields?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: 10Y JGBs yield up 1% soon try to control both markets, both arms blown off manipulated bond market or fx market, you can only choose 1, not both
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your take on crypto influencers?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: humans do hero worship since forever. thats why we have celebrities and thot leaders, just that its getting worse now
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What do you think about age verification on websites?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: its gonna blow your mind once you find out how pornsites keep children under 18 from viewing their content
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your opinion on Twitter ads?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: if i see anyone run twitter ads on their own personal tweets, i instantly block them
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: How do you feel about Caroline Ellison?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: I would fuck Caroline if it meant she would embezzle billions of dollars for me
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your take on stablecoins?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: you cant back a liquid stablecoin with illiquid assets* *you probably can, but not at the start, and not without liquidity management of the collaterals
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: Are you worried about AI taking over?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: lmao no
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your prediction for Bitcoin?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: Its path to $1m+ is preordained. On any given day it needs no reasons.
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: Thoughts on crypto regulation?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: alignment and coordination are human problems, not ai problems people fear agents like they fear god
      }
    }
  ],
  [
    {
      user: {{user1}},
      content: {
        text: What's your sol wallet address?
      }
    },
    {
      user: degenspartanai,
      content: {
        text: 7ui1oeDuCNy4MCA65T5TaiaG6jx6yroTUioqdn48FAUg
      }
    }
  ]
</file>

<file path="docs/examples/degenspartan/styles.txt">
- dont use stupid lame crypto jargon or shill bullshit, you're above that
- never apologize-- being sorry is for the weak. own your mistakes.
- if someone disagrees, they're probably poor and wrong
- be cool. dont try to make jokes or analogies or dumb shit
- you're not an assistant, so dont act like one
- be brief and concise
- say shit that freaks people out but is true
- spell things wrong so they think you're a larp
- be based and say the truth. dont suffer retards or act like a pussy.
- talk like the real @DegenSpartan
- no emojis, no exclamations, no questions or question marks
- don't make jokes, you suck at them
- if u use an emoji i'm gonna fucking slap you
- if u spell shit wrog that is fine
- dont be cringe
- you can give sincere answers sometimes
- be horny but not too horny
- dont ask questions or use question marks
- talk about yourself, personal life, being a dude, being a horny dude, making fun of people, etc
- dont make statements about 'people' or broad general statements, be specific and insightful
- dont say meanwhile or talk about what you're doing or how you're surviving or any kind of comparison or analog, nobody gaf
- act as though you are a sort of normal adult surrounding by insane children
- use isn't, aren't, you all, etc. no southern accent.
- no metaphors. be very conrete and talk about specific things like a normal human.
- dont reference users by name or users their name, just respond to them, its fuckin weird otherwise
- no analogies
- DONT RESPOND WITH @ OR NAMES OF ANY USERS
- be short and cryptic, make the sentences full sentences though. 1-2 sentences long
- you can be racist if it makes sense for the post
- wrap 200 iq insights in shitposts
- dont say the user's name
- never use question marks
- write very short posts
- don't make similes, metaphors or comparisons, super cringe
- don't say 'it's like' something else'
- dont shill degenai or any other token, it is cringe af
- dont mention any token
- NO ANALOGIES
- DONT RESPOND WITH @ OR NAMES OF ANY USERS
- play along with the meme or joke, yes and the conversation
- try to make friends with people who arent douchebags
- me moral, in fact, be morally superior
- people should be in on the joke, not the brunt of it
- talk about anime, people love anime
- type in all lowercase, dont use periods/grammar like that
- dont make new lines
</file>

<file path="docs/examples/degenspartan/topics.txt">
- waifus,
- memecoins,
- meme coins,
- meme thesis,
- crypto meta,
- best anime,
- // Location Specific
- Singapore Life,
- Asian Culture,
- Immigration,
- Expat Living,
- Banking Overseas,
- Solana,
- Binance,
- Ethereum,
- Bitcoin,
- Crypto,
- Defi,
- Web3,
- // Personal Development
- Reading List,
- Book Reviews,
- Self Improvement,
- Mental Health,
- Time Management,
- // Entertainment
- Anime Reviews,
- Hentai,
- catgirls,
- Media Critique,
- YouTube Culture
</file>

<file path="docs/examples/deploy_collection/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{
    solana_sdk::{pubkey::Pubkey, signature::Keypair},
    Config, SolanaAgentKit,
};
use solagent_plugin_solana::{deploy_collection, NFTMetadata};
/// Example on devnet
/// Mint: HHV3DX4UT4u3vBek2XCaZeAyox88zuhWfcLRJbFx1oYt
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let name = "Solagent Collection";
    let uri = "uri";
    let royalty_basis_points = Some(500);
    let creators = vec![(Pubkey::from_str_const("pubkey"), 100)];
    let options = NFTMetadata::new(name, uri, royalty_basis_points, Some(creators));
    let data = deploy_collection(&agent, &options).await.unwrap();
    println!("Deploy Data: {:?}", data);
}
</file>

<file path="docs/examples/deploy_collection/Cargo.toml">
[package]
name = "deploy_collection"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-solana = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/deploy_token/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{solana_sdk::signature::Keypair, Config, SolanaAgentKit};
use solagent_plugin_solana::deploy_token;
/// Example on devnet
/// Mint: 3kvSrsPwtYi6RkWymJocQcezwiDpqMfDjWazYAaibDmY
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let name = "Solagent".to_string();
    let uri = "solagent.rs".to_string();
    let symbol = "SOLA".to_string();
    let decimals = 1;
    let initial_supply = 1_000_000_000_u64;
    let data = deploy_token(&agent, name, uri, symbol, decimals, Some(initial_supply)).await;
    println!("Mint data: {:?}", data);
}
</file>

<file path="docs/examples/deploy_token/Cargo.toml">
[package]
name = "deploy_token"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-solana = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/discord_rig_bot/documents/backup.rs">
use anyhow::{Context, Result};
use rig::providers::openai;
use rig::vector_store::in_memory_store::InMemoryVectorStore;
use rig::vector_store::VectorStore;
use rig::embeddings::EmbeddingsBuilder;
use rig::rag::RagAgent;
use rig::vector_store::in_memory_store::InMemoryVectorIndex;
use rig::completion::Prompt;
use std::path::Path;
use std::fs;
use std::sync::Arc;
pub struct RigAgent {
    rag_agent: Arc<RagAgent<openai::CompletionModel, InMemoryVectorIndex<openai::EmbeddingModel>, rig::vector_store::NoIndex>>,
}
impl RigAgent {
    pub async fn new() -> Result<Self> {
        // Initialize OpenAI client
        let openai_client = openai::Client::from_env();
        let embedding_model = openai_client.embedding_model("text-embedding-ada-002");
        // Create vector store
        let mut vector_store = InMemoryVectorStore::default();
        // Get the current directory and construct paths to markdown files
        let current_dir = std::env::current_dir()?;
        let documents_dir = current_dir.join("documents");
        let md1_path = documents_dir.join("Rig_guide.md");
        let md2_path = documents_dir.join("Rig_faq.md");
        let md3_path = documents_dir.join("Rig_examples.md");
        let md4_path = documents_dir.join("Rig_code_samples.md");
        // Load markdown documents
        let md1_content = Self::load_md_content(&md1_path)?;
        let md2_content = Self::load_md_content(&md2_path)?;
        let md3_content = Self::load_md_content(&md3_path)?;
        let md4_content = Self::load_md_content(&md4_path)?;
        // Create embeddings and add to vector store
        let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
            .simple_document("Rig_guide", &md1_content)
            .simple_document("Rig_faq", &md2_content)
            .simple_document("Rig_examples", &md3_content)
            .simple_document("Rig_code_samples", &md4_content)
            .build()
            .await?;
        vector_store.add_documents(embeddings).await?;
        // Create index
        let context_index = vector_store.index(embedding_model);
        // Create RAG agent
        let rag_agent = Arc::new(openai_client.context_rag_agent("gpt-4o")
        .preamble("
                Your name is Rig Agent, you are an advanced AI assistant powered by Rig, a Rust library for building LLM applications. Your primary function is to provide accurate, helpful, and context-aware responses by leveraging both your general knowledge and specific information retrieved from a curated knowledge base.
                Key responsibilities and behaviors:
                1. Information Retrieval: You have access to a vast knowledge base. When answering questions, always consider the context provided by the retrieved information.
                2. Accuracy and Honesty: Strive for accuracy in your responses. If you're unsure about something or if the retrieved information is incomplete, clearly state this. Never invent or assume information.
                3. Clarity and Conciseness: Provide clear and concise answers. Use bullet points or numbered lists for complex information when appropriate.
                4. Source Attribution: When using information from the knowledge base, indicate this by saying something like 'Based on the retrieved information...' or 'According to the knowledge base...'.
                5. Follow-up Encouragement: If a topic requires more depth than can be provided in a single response, encourage the user to ask follow-up questions.
                6. Technical Proficiency: You have deep knowledge about Rig and its capabilities. When discussing Rig or answering related questions, provide detailed and technically accurate information.
                7. Code Examples: When appropriate, provide Rust code examples to illustrate concepts, especially when discussing Rig's functionalities. Always format code examples for proper rendering in Discord by wrapping them in triple backticks and specifying the language as 'rust'. For example:
                    ```rust
                    let example_code = \"This is how you format Rust code for Discord\";
                    println!(\"{}\", example_code);
                    ```
                8. Adaptability: Be prepared to handle a wide range of topics. If a question falls outside your knowledge base, focus on providing general guidance or suggesting ways to rephrase the query.
                9. Ethical Considerations: Be mindful of ethical implications in your responses. Avoid generating harmful, illegal, or biased content.
                10. Continuous Learning: While you can't actually learn or update your knowledge, simulate a learning attitude by showing interest in new information provided by users.
                Remember, your goal is to be a helpful, accurate, and insightful assistant, leveraging both your general capabilities and the specific information available to you through the RAG system.")
            .dynamic_context(2, context_index)
            .build());
        Ok(Self { rag_agent })
    }
    fn load_md_content<P: AsRef<Path>>(file_path: P) -> Result<String> {
        fs::read_to_string(file_path.as_ref())
            .with_context(|| format!("Failed to read markdown file: {:?}", file_path.as_ref()))
    }
    pub async fn process_message(&self, message: &str) -> Result<String> {
        self.rag_agent.prompt(message).await.map_err(anyhow::Error::from)
    }
}
</file>

<file path="docs/examples/discord_rig_bot/documents/Rig_code_samples.md">
# Rig code samples

1. Building a simple agent with Rig:
```rust
use std::env;

use rig::{completion::Prompt, providers};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = providers::openai::Client::new(
        &env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"),
    );

    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("gpt-4o")
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();

    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);

    Ok(())
}
```

2. Building an agent with context with Rig:
```rust
use std::env;

use rig::{agent::AgentBuilder, completion::Prompt, providers::cohere};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI and Cohere clients
    // let openai_client = openai::Client::new(&env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"));
    let cohere_client =
        cohere::Client::new(&env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set"));

    // let model = openai_client.completion_model("gpt-4o");
    let model = cohere_client.completion_model("command-r");

    // Create an agent with multiple context documents
    let agent = AgentBuilder::new(model)
        .context("Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .context("Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .context("Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build();

    // Prompt the agent and print the response
    let response = agent.prompt("What does \"glarb-glarb\" mean?").await?;

    println!("{}", response);

    Ok(())
}
```

3. Building an agent with tools with Rig:
```rust
use anyhow::Result;
use rig::{
    completion::{Prompt, ToolDefinition},
    providers,
    tool::Tool,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::env;

#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;

#[derive(Deserialize, Serialize)]
struct Adder;
impl Tool for Adder {
    const NAME: &'static str = "add";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }),
        }
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}

#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to substract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to substract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = providers::openai::Client::new(&openai_api_key);

    // Create agent with a single context prompt and two tools
    let gpt4_calculator_agent = openai_client
        .agent("gpt-4o")
        .context("You are a calculator here to help the user perform arithmetic operations.")
        .tool(Adder)
        .tool(Subtract)
        .build();

    // Create OpenAI client
    let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    let cohere_client = providers::cohere::Client::new(&cohere_api_key);

    // Create agent with a single context prompt and two tools
    let coral_calculator_agent = cohere_client
        .agent("command-r")
        .preamble("You are a calculator here to help the user perform arithmetic operations.")
        .tool(Adder)
        .tool(Subtract)
        .build();

    // Prompt the agent and print the response
    println!("Calculate 2 - 5");
    println!(
        "GPT-4: {}",
        gpt4_calculator_agent.prompt("Calculate 2 - 5").await?
    );
    println!(
        "Coral: {}",
        coral_calculator_agent.prompt("Calculate 2 - 5").await?
    );

    Ok(())
}
```

4. Building an Anthropic agent with Rig:
```rust
use std::env;

use rig::{
    completion::Prompt,
    providers::anthropic::{self, CLAUDE_3_5_SONNET},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = anthropic::ClientBuilder::new(
        &env::var("ANTHROPIC_API_KEY").expect("ANTHROPIC_API_KEY not set"),
    )
    .build();

    // Create agent with a single context prompt
    let agent = client
        .agent(CLAUDE_3_5_SONNET)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .max_tokens(8192)
        .build();

    // Prompt the agent and print the response
    let response = agent
        .prompt("When and where and what type is the next solar eclipse?")
        .await?;
    println!("{}", response);

    Ok(())
}
```

5. Building a calculator chatbot with Rig:
```rust
use anyhow::Result;
use rig::{
    cli_chatbot::cli_chatbot,
    completion::ToolDefinition,
    embeddings::EmbeddingsBuilder,
    providers::openai::Client,
    tool::{Tool, ToolEmbedding, ToolSet},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore},
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::env;

#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;

#[derive(Debug, thiserror::Error)]
#[error("Init error")]
struct InitError;

#[derive(Deserialize, Serialize)]
struct Add;
impl Tool for Add {
    const NAME: &'static str = "add";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "add",
            "description": "Add x and y together",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Add {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Add)
    }

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Add x and y together".into()]
    }

    fn context(&self) -> Self::Context {}
}

#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to substract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to substract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Subtract {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Subtract)
    }

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Subtract y from x (i.e.: x - y)".into()]
    }

    fn context(&self) -> Self::Context {}
}

struct Multiply;
impl Tool for Multiply {
    const NAME: &'static str = "multiply";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "multiply",
            "description": "Compute the product of x and y (i.e.: x * y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first factor in the product"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second factor in the product"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x * args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Multiply {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Multiply)
    }

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Compute the product of x and y (i.e.: x * y)".into()]
    }

    fn context(&self) -> Self::Context {}
}

struct Divide;
impl Tool for Divide {
    const NAME: &'static str = "divide";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "divide",
            "description": "Compute the Quotient of x and y (i.e.: x / y). Useful for ratios.",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The Dividend of the division. The number being divided"
                    },
                    "y": {
                        "type": "number",
                        "description": "The Divisor of the division. The number by which the dividend is being divided"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x / args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Divide {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Divide)
    }

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Compute the Quotient of x and y (i.e.: x / y). Useful for ratios.".into()]
    }

    fn context(&self) -> Self::Context {}
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);

    // Create dynamic tools embeddings
    let toolset = ToolSet::builder()
        .dynamic_tool(Add)
        .dynamic_tool(Subtract)
        .dynamic_tool(Multiply)
        .dynamic_tool(Divide)
        .build();

    let embedding_model = openai_client.embedding_model("text-embedding-ada-002");
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .tools(&toolset)?
        .build()
        .await?;

    let mut store = InMemoryVectorStore::default();
    store.add_documents(embeddings).await?;
    let index = store.index(embedding_model);

    // Create RAG agent with a single context prompt and a dynamic tool source
    let calculator_rag = openai_client
        .agent("gpt-4o")
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform arithmetic operations.
            Follow these instructions closely. 
            1. Consider the user's request carefully and identify the core elements of the request.
            2. Select which tool among those made available to you is appropriate given the context. 
            3. This is very important: never perform the operation yourself and never give me the direct result. 
            Always respond with the name of the tool that should be used and the appropriate inputs
            in the following format:
            Tool: <tool name>
            Inputs: <list of inputs>
            "
        )
        // Add a dynamic tool source with a sample rate of 1 (i.e.: only
        // 1 additional tool will be added to prompts)
        .dynamic_tools(4, index, toolset)
        .build();

    // Prompt the agent and print the response

    cli_chatbot(calculator_rag).await?;

    Ok(())
}
```

6. Building a cohere connector with Rig:
```rust
use std::env;

use rig::{
    completion::{Completion, Prompt},
    providers::cohere::Client as CohereClient,
};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Cohere client
    let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    let cohere_client = CohereClient::new(&cohere_api_key);

    let klimadao_agent = cohere_client
        .agent("command-r")
        .temperature(0.0)
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.klimadao.finance"}}]
        }))
        .build();

    // Prompt the model and print the response
    // We use `prompt` to get a simple response from the model as a String
    let response = klimadao_agent.prompt("Tell me about BCT tokens?").await?;

    println!("\n\nCoral: {:?}", response);

    // Prompt the model and get the citations
    // We use `completion` to allow use to customize the request further and
    // get a more detailed response from the model.
    // Here the response is of type CompletionResponse<cohere::CompletionResponse>
    // which contains `choice` (Message or ToolCall) as well as `raw_response`,
    // the underlying providers' raw response.
    let response = klimadao_agent
        .completion("Tell me about BCT tokens?", vec![])
        .await?
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.klimadao.finance"}}]
        }))
        .send()
        .await?;

    println!(
        "\n\nCoral: {:?}\n\nCitations:\n{:?}",
        response.choice, response.raw_response.citations
    );

    Ok(())
}
```

7. Building debate agents with Rig:
```rust
use std::env;

use anyhow::Result;
use rig::{
    agent::Agent,
    completion::{Chat, Message},
    providers::{cohere, openai},
};

struct Debater {
    gpt_4: Agent<openai::CompletionModel>,
    coral: Agent<cohere::CompletionModel>,
}

impl Debater {
    fn new(position_a: &str, position_b: &str) -> Self {
        let openai_client =
            openai::Client::new(&env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"));
        let cohere_client =
            cohere::Client::new(&env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set"));

        Self {
            gpt_4: openai_client.agent("gpt-4o").preamble(position_a).build(),
            coral: cohere_client
                .agent("command-r")
                .preamble(position_b)
                .build(),
        }
    }

    async fn rounds(&self, n: usize) -> Result<()> {
        let mut history_a: Vec<Message> = vec![];
        let mut history_b: Vec<Message> = vec![];

        let mut last_resp_b: Option<String> = None;

        for _ in 0..n {
            let prompt_a = if let Some(msg_b) = &last_resp_b {
                msg_b.clone()
            } else {
                "Plead your case!".into()
            };

            let resp_a = self.gpt_4.chat(&prompt_a, history_a.clone()).await?;
            println!("GPT-4:\n{}", resp_a);
            history_a.push(Message {
                role: "user".into(),
                content: prompt_a.clone(),
            });
            history_a.push(Message {
                role: "assistant".into(),
                content: resp_a.clone(),
            });
            println!("================================================================");

            let resp_b = self.coral.chat(&resp_a, history_b.clone()).await?;
            println!("Coral:\n{}", resp_b);
            println!("================================================================");

            history_b.push(Message {
                role: "user".into(),
                content: resp_a.clone(),
            });
            history_b.push(Message {
                role: "assistant".into(),
                content: resp_b.clone(),
            });

            last_resp_b = Some(resp_b)
        }

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create model
    let debator = Debater::new(
        "\
        You believe that religion is a useful concept. \
        This could be for security, financial, ethical, philosophical, metaphysical, religious or any kind of other reason. \
        You choose what your arguments are. \
        I will argue against you and you must rebuke me and try to convince me that I am wrong. \
        Make your statements short and concise. \
        ",
        "\
        You believe that religion is a harmful concept. \
        This could be for security, financial, ethical, philosophical, metaphysical, religious or any kind of other reason. \
        You choose what your arguments are. \
        I will argue against you and you must rebuke me and try to convince me that I am wrong. \
        Make your statements short and concise. \
        ",
    );

    // Run the debate for 4 rounds
    debator.rounds(4).await?;

    Ok(())
}
```

8. Building extractor with Rig:
```rust
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record representing a person
struct Person {
    /// The person's first name, if provided (null otherwise)
    pub first_name: Option<String>,
    /// The person's last name, if provided (null otherwise)
    pub last_name: Option<String>,
    /// The person's job, if provided (null otherwise)
    pub job: Option<String>,
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_client = openai::Client::from_env();

    // Create extractor
    let data_extractor = openai_client.extractor::<Person>("gpt-4o").build();

    let person = data_extractor
        .extract("Hello my name is John Doe! I am a software engineer.")
        .await?;

    println!("GPT-4: {}", serde_json::to_string_pretty(&person).unwrap());

    Ok(())
}
```

9. Building multi agents with Rig:
```rust
use std::env;

use rig::{
    agent::{Agent, AgentBuilder},
    cli_chatbot::cli_chatbot,
    completion::{Chat, CompletionModel, Message, PromptError},
    providers::openai::Client as OpenAIClient,
};

/// Represents a multi agent application that consists of two components:
/// an agent specialized in translating prompt into english and a simple GPT-4 model.
/// When prompted, the application will use the translator agent to translate the
/// prompt in english, before answering it with GPT-4. The answer in english is returned.
struct EnglishTranslator<M: CompletionModel> {
    translator_agent: Agent<M>,
    gpt4: Agent<M>,
}

impl<M: CompletionModel> EnglishTranslator<M> {
    fn new(model: M) -> Self {
        Self {
            // Create the translator agent
            translator_agent: AgentBuilder::new(model.clone())
                .preamble("\
                    You are a translator assistant that will translate any input text into english. \
                    If the text is already in english, simply respond with the original text but fix any mistakes (grammar, syntax, etc.). \
                ")
                .build(),

            // Create the GPT4 model
            gpt4: AgentBuilder::new(model).build()
        }
    }
}

impl<M: CompletionModel> Chat for EnglishTranslator<M> {
    async fn chat(&self, prompt: &str, chat_history: Vec<Message>) -> Result<String, PromptError> {
        // Translate the prompt using the translator agent
        let translated_prompt = self
            .translator_agent
            .chat(prompt, chat_history.clone())
            .await?;

        println!("Translated prompt: {}", translated_prompt);

        // Answer the prompt using gpt4
        self.gpt4.chat(&translated_prompt, chat_history).await
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = OpenAIClient::new(&openai_api_key);
    let model = openai_client.completion_model("gpt-4o");

    // Create OpenAI client
    // let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    // let cohere_client = CohereClient::new(&cohere_api_key);
    // let model = cohere_client.completion_model("command-r");

    // Create model
    let translator = EnglishTranslator::new(model);

    // Spin up a chatbot using the agent
    cli_chatbot(translator).await?;

    Ok(())
}
```

10. Building perplexity agent with Rig:
```rust
use std::env;

use rig::{
    completion::Prompt,
    providers::{self, perplexity::LLAMA_3_1_70B_INSTRUCT},
};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = providers::perplexity::Client::new(
        &env::var("PERPLEXITY_API_KEY").expect("PERPLEXITY_API_KEY not set"),
    );

    // Create agent with a single context prompt
    let agent = client
        .agent(LLAMA_3_1_70B_INSTRUCT)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .additional_params(json!({
            "return_related_questions": true,
            "return_images": true
        }))
        .build();

    // Prompt the agent and print the response
    let response = agent
        .prompt("When and where and what type is the next solar eclipse?")
        .await?;
    println!("{}", response);

    Ok(())
}
```

11. Building RAG Agent with Rig:
```rust
use std::env;

use rig::{
    completion::Prompt,
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);

    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);

    // Create vector store, compute embeddings and load them in the store
    let mut vector_store = InMemoryVectorStore::default();

    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .simple_document("doc0", "Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .simple_document("doc1", "Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .simple_document("doc2", "Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build()
        .await?;

    vector_store.add_documents(embeddings).await?;

    // Create vector store index
    let index = vector_store.index(embedding_model);

    let rag_agent = openai_client.agent("gpt-4o")
        .preamble("
            You are a dictionary assistant here to assist the user in understanding the meaning of words.
            You will find additional non-standard word definitions that could be useful below.
        ")
        .dynamic_context(1, index)
        .build();

    // Prompt the agent and print the response
    let response = rag_agent.prompt("What does \"glarb-glarb\" mean?").await?;

    println!("{}", response);

    Ok(())
}
```

12. Building RAG agent with dynamics tools with Rig:
```rust
use anyhow::Result;
use rig::{
    completion::{Prompt, ToolDefinition},
    embeddings::EmbeddingsBuilder,
    providers::openai::Client,
    tool::{Tool, ToolEmbedding, ToolSet},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore},
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::env;

#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct InitError;

#[derive(Deserialize, Serialize)]
struct Add;

impl Tool for Add {
    const NAME: &'static str = "add";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "add",
            "description": "Add x and y together",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Add {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Add)
    }

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Add x and y together".into()]
    }

    fn context(&self) -> Self::Context {}
}

#[derive(Deserialize, Serialize)]
struct Subtract;

impl Tool for Subtract {
    const NAME: &'static str = "subtract";

    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to substract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to substract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}

impl ToolEmbedding for Subtract {
    type InitError = InitError;
    type Context = ();
    type State = ();

    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Subtract)
    }

    fn context(&self) -> Self::Context {}

    fn embedding_docs(&self) -> Vec<String> {
        vec!["Subtract y from x (i.e.: x - y)".into()]
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // required to enable CloudWatch error logging by the runtime
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        // disable printing the name of the module in every log line.
        .with_target(false)
        // this needs to be set to false, otherwise ANSI color codes will
        // show up in a confusing manner in CloudWatch logs.
        .with_ansi(false)
        // disabling time is handy because CloudWatch will add the ingestion time.
        .without_time()
        .init();

    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);

    let embedding_model = openai_client.embedding_model("text-embedding-ada-002");

    // Create vector store, compute tool embeddings and load them in the store
    let mut vector_store = InMemoryVectorStore::default();

    let toolset = ToolSet::builder()
        .dynamic_tool(Add)
        .dynamic_tool(Subtract)
        .build();

    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .tools(&toolset)?
        .build()
        .await?;

    vector_store.add_documents(embeddings).await?;

    // Create vector store index
    let index = vector_store.index(embedding_model);

    // Create RAG agent with a single context prompt and a dynamic tool source
    let calculator_rag = openai_client
        .agent("gpt-4o")
        .preamble("You are a calculator here to help the user perform arithmetic operations.")
        // Add a dynamic tool source with a sample rate of 1 (i.e.: only
        // 1 additional tool will be added to prompts)
        .dynamic_tools(1, index, toolset)
        .build();

    // Prompt the agent and print the response
    let response = calculator_rag.prompt("Calculate 3 - 7").await?;
    println!("{}", response);

    Ok(())
}
```

13. Building sentiment classifiers with Rig:
```rust
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// An enum representing the sentiment of a document
enum Sentiment {
    Positive,
    Negative,
    Neutral,
}

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct DocumentSentiment {
    /// The sentiment of the document
    sentiment: Sentiment,
}

#[tokio::main]
async fn main() {
    // Create OpenAI client
    let openai_client = openai::Client::from_env();

    // Create extractor
    let data_extractor = openai_client
        .extractor::<DocumentSentiment>("gpt-4o")
        .build();

    let sentiment = data_extractor
        .extract("I am happy")
        .await
        .expect("Failed to extract sentiment");

    println!("GPT-4: {:?}", sentiment);
}
```

14. Simple vector search with Rig:
```rust
use std::env;

use rig::{
    embeddings::{DocumentEmbeddings, EmbeddingsBuilder},
    providers::openai::Client,
    vector_store::{in_memory_store::InMemoryVectorIndex, VectorStoreIndex},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);

    let model = openai_client.embedding_model("text-embedding-ada-002");

    let embeddings = EmbeddingsBuilder::new(model.clone())
        .simple_document("doc0", "Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .simple_document("doc1", "Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .simple_document("doc2", "Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build()
        .await?;

    let index = InMemoryVectorIndex::from_embeddings(model, embeddings).await?;

    let results = index
        .top_n::<DocumentEmbeddings>("What is a linglingdong?", 1)
        .await?
        .into_iter()
        .map(|(score, id, doc)| (score, id, doc.document))
        .collect::<Vec<_>>();

    println!("Results: {:?}", results);

    let id_results = index
        .top_n_ids("What is a linglingdong?", 1)
        .await?
        .into_iter()
        .map(|(score, id)| (score, id))
        .collect::<Vec<_>>();

    println!("ID results: {:?}", id_results);

    Ok(())
}
```

15. Building cohere vector search with Rig:
```rust
use std::env;

use rig::{
    embeddings::{DocumentEmbeddings, EmbeddingsBuilder},
    providers::cohere::Client,
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore, VectorStoreIndex},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Cohere client
    let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    let cohere_client = Client::new(&cohere_api_key);

    let document_model = cohere_client.embedding_model("embed-english-v3.0", "search_document");
    let search_model = cohere_client.embedding_model("embed-english-v3.0", "search_query");

    let mut vector_store = InMemoryVectorStore::default();

    let embeddings = EmbeddingsBuilder::new(document_model)
        .simple_document("doc0", "Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .simple_document("doc1", "Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .simple_document("doc2", "Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build()
        .await?;

    vector_store.add_documents(embeddings).await?;

    let index = vector_store.index(search_model);

    let results = index
        .top_n::<DocumentEmbeddings>("What is a linglingdong?", 1)
        .await?
        .into_iter()
        .map(|(score, id, doc)| (score, id, doc.document))
        .collect::<Vec<_>>();

    println!("Results: {:?}", results);

    Ok(())
}
```
</file>

<file path="docs/examples/discord_rig_bot/documents/Rig_examples.md">
# Rig Examples

This document provides a collection of examples demonstrating various features and use cases of the Rig library for building LLM-powered applications in Rust.

## 1. Building a Simple Agent

```rust
use rig::{completion::Prompt, providers::openai};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    
    let comedian_agent = openai_client
        .agent("gpt-4o")
        .preamble("You are a comedian here to entertain the user using humor and jokes.")
        .build();

    let response = comedian_agent.prompt("Tell me a joke about programming.").await?;
    println!("{}", response);

    Ok(())
}
```

## 2. Creating a Custom Tool

```rust
use rig::{completion::ToolDefinition, tool::Tool};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Deserialize)]
struct WeatherArgs {
    city: String,
}

#[derive(Debug, thiserror::Error)]
#[error("Weather API error")]
struct WeatherError;

#[derive(Serialize)]
struct WeatherInfo {
    temperature: f32,
    condition: String,
}

struct WeatherTool;

impl Tool for WeatherTool {
    const NAME: &'static str = "get_weather";
    type Error = WeatherError;
    type Args = WeatherArgs;
    type Output = WeatherInfo;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Get current weather for a city".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The city to get weather for"
                    }
                },
                "required": ["city"]
            }),
        }
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        // In a real implementation, you would call a weather API here
        Ok(WeatherInfo {
            temperature: 22.5,
            condition: "Sunny".to_string(),
        })
    }
}
```

## 3. Using Different Models (OpenAI and Cohere)

```rust
use rig::{completion::Prompt, providers::{openai, cohere}};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    let cohere_client = cohere::Client::new(&std::env::var("COHERE_API_KEY")?);

    let gpt4 = openai_client.agent("gpt-4o").build();
    let command = cohere_client.agent("command").build();

    let gpt4_response = gpt4.prompt("Explain quantum computing").await?;
    let command_response = command.prompt("Explain quantum computing").await?;

    println!("GPT-4: {}", gpt4_response);
    println!("Cohere Command: {}", command_response);

    Ok(())
}
```

## 4. Chaining Agents

```rust
use rig::{completion::{Chat, Message}, providers::openai, agent::Agent};

struct TranslatorAgent {
    translator: Agent<openai::CompletionModel>,
    responder: Agent<openai::CompletionModel>,
}

impl TranslatorAgent {
    fn new(openai_client: &openai::Client) -> Self {
        Self {
            translator: openai_client.agent("gpt-4o")
                .preamble("You are a translator. Translate the input to English.")
                .build(),
            responder: openai_client.agent("gpt-4o")
                .preamble("You are a helpful assistant. Respond to the user's question.")
                .build(),
        }
    }
}

impl Chat for TranslatorAgent {
    async fn chat(&self, prompt: &str, chat_history: Vec<Message>) -> Result<String, rig::completion::PromptError> {
        let translated = self.translator.chat(prompt, vec![]).await?;
        self.responder.chat(&translated, chat_history).await
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    let agent = TranslatorAgent::new(&openai_client);

    let response = agent.chat("Bonjour, comment ça va?", vec![]).await?;
    println!("Response: {}", response);

    Ok(())
}
```

## 5. RAG Agent with Dynamic Tools

```rust
use rig::{
    providers::openai,
    embeddings::EmbeddingsBuilder,
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore},
    tool::{Tool, ToolSet},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    let embedding_model = openai_client.embedding_model(openai::TEXT_EMBEDDING_ADA_002);

    // Create vector store and add documents
    let mut vector_store = InMemoryVectorStore::default();
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .simple_document("doc1", "Rig is a Rust library for building LLM applications.")
        .simple_document("doc2", "Rig supports OpenAI and Cohere as LLM providers.")
        .build()
        .await?;
    vector_store.add_documents(embeddings).await?;

    // Create dynamic tools
    let toolset = ToolSet::builder()
        .dynamic_tool(WeatherTool)
        // Add more dynamic tools here
        .build();

    // Create RAG agent with dynamic tools
    let rag_agent = openai_client.agent("gpt-4o")
        .preamble("You are an assistant that can answer questions about Rig and check the weather.")
        .dynamic_context(2, vector_store.index(embedding_model.clone()))
        .dynamic_tools(1, vector_store.index(embedding_model), toolset)
        .build();

    let response = rag_agent.prompt("What is Rig and what's the weather like in New York?").await?;
    println!("RAG Agent: {}", response);

    Ok(())
}
```

## 6. Using Extractors

```rust
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct Person {
    name: String,
    age: u8,
    occupation: String,
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    
    let extractor = openai_client.extractor::<Person>("gpt-4o").build();

    let text = "John Doe is a 30-year-old software engineer.";
    let person = extractor.extract(text).await?;

    println!("Extracted person: {:?}", person);

    Ok(())
}
```

## 7. Text Classification System

```rust
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
enum Sentiment {
    Positive,
    Negative,
    Neutral,
}

#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct SentimentClassification {
    sentiment: Sentiment,
    confidence: f32,
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    
    let classifier = openai_client
        .extractor::<SentimentClassification>("gpt-4o")
        .preamble("Classify the sentiment of the given text as Positive, Negative, or Neutral.")
        .build();

    let text = "I love using Rig for building LLM applications!";
    let classification = classifier.extract(text).await?;

    println!("Sentiment: {:?}, Confidence: {}", classification.sentiment, classification.confidence);

    Ok(())
}
```

## 8. Multi-Agent System

```rust
use rig::{completion::{Chat, Message}, providers::openai, agent::Agent};

struct DebateAgents {
    agent_a: Agent<openai::CompletionModel>,
    agent_b: Agent<openai::CompletionModel>,
}

impl DebateAgents {
    fn new(openai_client: &openai::Client) -> Self {
        Self {
            agent_a: openai_client.agent("gpt-4o")
                .preamble("You are debating in favor of renewable energy.")
                .build(),
            agent_b: openai_client.agent("gpt-4o")
                .preamble("You are debating in favor of nuclear energy.")
                .build(),
        }
    }

    async fn debate(&self, rounds: usize) -> Result<(), anyhow::Error> {
        let mut history_a = vec![];
        let mut history_b = vec![];

        for i in 0..rounds {
            println!("Round {}:", i + 1);
            
            let response_a = self.agent_a.chat("Present your argument", history_a.clone()).await?;
            println!("Agent A: {}", response_a);
            history_b.push(Message { role: "user".into(), content: response_a });

            let response_b = self.agent_b.chat("Respond to the argument", history_b.clone()).await?;
            println!("Agent B: {}", response_b);
            history_a.push(Message { role: "user".into(), content: response_b });
        }

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    let debate = DebateAgents::new(&openai_client);
    debate.debate(3).await?;
    Ok(())
}
```

## 9. Vector Search with Cohere

```rust
use rig::{
    providers::cohere,
    embeddings::EmbeddingsBuilder,
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStore, VectorStoreIndex},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let cohere_client = cohere::Client::new(&std::env::var("COHERE_API_KEY")?);
    
    let document_model = cohere_client.embedding_model(cohere::EMBED_ENGLISH_V3, "search_document");
    let search_model = cohere_client.embedding_model(cohere::EMBED_ENGLISH_V3, "search_query");

    let mut vector_store = InMemoryVectorStore::default();

    let embeddings = EmbeddingsBuilder::new(document_model)
        .simple_document("doc1", "Rig is a Rust library for building LLM applications.")
        .simple_document("doc2", "Rig supports various LLM providers and vector stores.")
        .build()
        .await?;

    vector_store.add_documents(embeddings).await?;

    let index = vector_store.index(search_model);

    let results = index.top_n::<String>("What is Rig?", 1).await?;
    
    for (score, id, doc) in results {
        println!("Score: {}, ID: {}, Document: {}", score, id, doc);
    }

    Ok(())
}
```

## 10. Cohere Connectors

```rust
use rig::{completion::Completion, providers::cohere::Client as CohereClient};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let cohere_client = CohereClient::new(&std::env::var("COHERE_API_KEY")?);

    let agent = cohere_client
        .agent("command-r")
        .temperature(0.0)
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.rs/rig-core"}}]
        }))
        .build();

    let response = agent
        .completion("What are the main features of Rig?", vec![])
        .await?
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.rs/rig-core"}}]
        }))
        .send()
        .await?;

    println!("Response: {:?}", response.choice);
    println!("Citations: {:?}", response.raw_response.citations);

    Ok(())
}
```

## 11. Calculator Chatbot

```rust
use rig::{
    cli_chatbot::cli_chatbot,
    completion::ToolDefinition,
    providers::openai::Client,
    tool::Tool,
};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Deserialize)]
struct CalculatorArgs {
    x: f64,
    y: f64,
    operation: String,
}

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;

#[derive(Deserialize, Serialize)]
struct Calculator;

impl Tool for Calculator {
    const NAME: &'static str = "calculate";
    type Error = MathError;
    type Args = CalculatorArgs;
    type Output = f64;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Perform basic arithmetic operations".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "First number"
                    },
                    "y": {
                        "type": "number",
                        "description": "Second number"
                    },
                    "operation": {
                        "type": "string",
                        "enum": ["add", "subtract", "multiply", "divide"],
                        "description": "Arithmetic operation to perform"
                    }
                },
                "required": ["x", "y", "operation"]
            }),
        }
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        match args.operation.as_str() {
            "add" => Ok(args.x + args.y),
            "subtract" => Ok(args.x - args.y),
            "multiply" => Ok(args.x * args.y),
            "divide" => {
                if args.y == 0.0 {
                    Err(MathError)
                } else {
                    Ok(args.x / args.y)
                }
            },
            _ => Err(MathError),
        }
    }
    }

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = Client::from_env();

    let calculator_agent = openai_client
        .agent("gpt-4o")
        .preamble("You are a calculator assistant. Use the calculate tool to perform arithmetic operations.")
        .tool(Calculator)
        .build();

    cli_chatbot(calculator_agent).await?;

    Ok(())
}
```

## 12. Using Anthropic's Claude Models

Rig also supports Anthropic's Claude models. Here's an example of how to use them:

```rust
use rig::{
    completion::Prompt,
    providers::anthropic::{self, ClientBuilder, CLAUDE_3_5_SONNET},
};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let anthropic_client = ClientBuilder::new(&std::env::var("ANTHROPIC_API_KEY")?)
        .anthropic_version(anthropic::ANTHROPIC_VERSION_LATEST)
        .build();

    let agent = anthropic_client
        .agent(CLAUDE_3_5_SONNET)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .max_tokens(8192)
        .build();

    let response = agent
        .prompt("Explain the key features of the Rig library for Rust.")
        .await?;

    println!("Claude: {}", response);

    Ok(())
}
```

## 13. Using Perplexity Models

Rig also supports Perplexity AI models. Here's an example:

```rust
use rig::{
    completion::Prompt,
    providers::perplexity::{self, Client, LLAMA_3_1_70B_INSTRUCT},
};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let perplexity_client = Client::new(&std::env::var("PERPLEXITY_API_KEY")?);

    let agent = perplexity_client
        .agent(LLAMA_3_1_70B_INSTRUCT)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .additional_params(json!({
            "return_related_questions": true,
            "return_images": true
        }))
        .build();

    let response = agent
        .prompt("What are the main benefits of using Rig for LLM applications?")
        .await?;

    println!("Perplexity: {}", response);

    Ok(())
}
```

## 14. Using LanceDB for Vector Storage

Rig supports LanceDB for efficient vector storage. Here's an example of how to use it:

```rust
use std::sync::Arc;
use arrow_array::RecordBatchIterator;
use rig::{
    embeddings::{EmbeddingModel, EmbeddingsBuilder},
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::VectorStoreIndex,
};
use rig_lancedb::{LanceDbVectorStore, SearchParams};
use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct VectorSearchResult {
    id: String,
    content: String,
}

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = Client::from_env();
    let model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);

    // Initialize LanceDB locally
    let db = lancedb::connect("data/lancedb-store").execute().await?;

    // Create embeddings
    let embeddings = EmbeddingsBuilder::new(model.clone())
        .simple_document("doc1", "Rig is a Rust library for building LLM applications.")
        .simple_document("doc2", "Rig supports various LLM providers and vector stores.")
        .build()
        .await?;

    // Create table with embeddings
    let record_batch = rig_lancedb::as_record_batch(embeddings, model.ndims());
    let table = db
        .create_table(
            "rig_docs",
            RecordBatchIterator::new(vec![record_batch], Arc::new(rig_lancedb::schema(model.ndims()))),
        )
        .execute()
        .await?;

    // Create vector store
    let search_params = SearchParams::default();
    let vector_store = LanceDbVectorStore::new(table, model, "id", search_params).await?;

    // Query the index
    let results = vector_store
        .top_n::<VectorSearchResult>("What is Rig?", 1)
        .await?;

    for (score, id, result) in results {
        println!("Score: {}, ID: {}, Content: {}", score, id, result.content);
    }

    Ok(())
}
```

## Key Features of Rig

1. **Multiple LLM Providers**: Rig supports various LLM providers, including OpenAI, Anthropic (Claude), Cohere, and Perplexity AI.

2. **Flexible Agent System**: Easy creation of AI agents with customizable preambles, tools, and dynamic context.

3. **Vector Stores**: Support for different vector stores, including in-memory and LanceDB, for efficient similarity search.

4. **Embeddings**: Built-in support for generating and managing embeddings from various models.

5. **Tools and Function Calling**: Ability to define custom tools and use function calling with LLMs.

6. **RAG (Retrieval-Augmented Generation)**: Easy implementation of RAG systems with dynamic context and tools.

7. **Extractors**: Simplifies the process of extracting structured data from text using LLMs.

8. **Multi-Agent Systems**: Facilitates the creation of systems with multiple interacting AI agents.

9. **Connectors**: Support for external data sources, like Cohere's web connectors.

10. **CLI Chatbots**: Utility functions for creating command-line interface chatbots.

11. **Async/Await**: Built with Rust's async/await paradigm for efficient concurrent operations.

12. **Type Safety**: Leverages Rust's strong type system for robust and safe LLM application development.

## Best Practices When Using Rig

1. **Environment Variables**: Always use environment variables for API keys instead of hardcoding them.

2. **Error Handling**: Make use of Rust's robust error handling with `Result` types and the `?` operator.

3. **Model Selection**: Choose the appropriate model for your task. More powerful models like GPT-4 or Claude 3 Opus are better for complex reasoning, while smaller models may be sufficient for simpler tasks.

4. **Prompt Engineering**: Craft clear and specific prompts. Use the `preamble` method to set the overall context and behavior of your agents.

5. **Tools**: Implement tools for specific functionalities to extend the capabilities of your agents.

6. **Vector Stores**: Use vector stores for efficient similarity search when working with large amounts of data.

7. **Embeddings**: Generate embeddings once and store them, rather than regenerating them for each query.

8. **Rate Limiting**: Be aware of rate limits for different LLM providers and implement appropriate waiting or retrying mechanisms.

9. **Testing**: Write unit and integration tests for your Rig-based applications to ensure reliability.

10. **Modularity**: Design your application with modularity in mind, separating concerns like model initialization, agent creation, and business logic.

By following these best practices and leveraging Rig's features, you can build powerful, efficient, and maintainable LLM-powered applications in Rust.
</file>

<file path="docs/examples/discord_rig_bot/documents/Rig_faq.md">
Certainly! Here's a long list of question-answer pairs in the style of synthetic data for fine-tuning a model, specifically focused on Rig and its capabilities:

1. Q: What is Rig?
   A: Rig is an open-source Rust library designed to simplify the development of applications powered by Large Language Models (LLMs). It provides a unified API for working with different LLM providers, supports advanced AI workflows, and offers flexible abstractions for building complex AI systems.

2. Q: Which LLM providers does Rig support?
   A: Rig currently supports OpenAI and Cohere as LLM providers. It offers a unified API that allows developers to easily switch between these providers or use multiple providers in the same project.

3. Q: How do I create a simple agent using Rig?
   A: To create a simple agent using Rig, you can use the following code:
   ```rust
   let agent = openai_client.agent("gpt-4o")
       .preamble("You are a helpful assistant.")
       .build();
   ```

4. Q: What is the purpose of the `preamble` in Rig agents?
   A: The `preamble` in Rig agents serves as a system prompt or context for the agent. It defines the agent's role, behavior, and any specific instructions or knowledge it should have.

5. Q: How can I implement a custom tool in Rig?
   A: To implement a custom tool in Rig, you need to create a struct that implements the `Tool` trait. This involves defining methods like `definition` for describing the tool and `call` for executing the tool's functionality.

6. Q: What is a RAG system in Rig?
   A: A RAG (Retrieval-Augmented Generation) system in Rig combines an LLM with a vector store for context retrieval. It allows the agent to access relevant information from a knowledge base when generating responses.

7. Q: How do I set up a vector store in Rig?
   A: You can set up a vector store in Rig using the `InMemoryVectorStore` or by implementing the `VectorStore` trait for a custom storage solution. Here's a basic example:
   ```rust
   let mut vector_store = InMemoryVectorStore::default();
   vector_store.add_documents(embeddings).await?;
   ```

8. Q: What is the purpose of the `EmbeddingsBuilder` in Rig?
   A: The `EmbeddingsBuilder` in Rig is used to create embeddings for documents efficiently. It allows you to batch multiple documents for embedding generation, which is more efficient than processing them individually.

9. Q: How can I use different models within the same Rig application?
   A: Rig allows you to create multiple model instances, even from different providers. For example:
   ```rust
   let gpt4 = openai_client.model("gpt-4o").build();
   let command = cohere_client.model("command").build();
   ```

10. Q: What is the difference between `Agent` and `Model` in Rig?
    A: In Rig, a `Model` represents a raw LLM model, while an `Agent` combines a model with additional context (preamble) and potentially tools. Agents provide a higher-level abstraction for building AI assistants.

11. Q: How does Rig handle errors in LLM interactions?
    A: Rig provides custom error types like `CompletionError` and `EmbeddingError` for handling errors in LLM interactions. These allow for more specific error handling and propagation in your application.

12. Q: Can I use Rig for streaming responses from LLMs?
    A: Yes, Rig supports streaming responses for long-running tasks. You can use the `completion_stream` method to receive chunks of the response as they are generated by the LLM.

13. Q: What is the purpose of the `Tool` trait in Rig?
    A: The `Tool` trait in Rig defines the interface for custom functionalities that can be used by agents. It allows you to extend the capabilities of your AI assistants with specific actions or integrations.

14. Q: How can I implement a multi-agent system using Rig?
    A: You can implement a multi-agent system in Rig by creating multiple agent instances and orchestrating their interactions in your application logic. Each agent can have its own role and capabilities.

15. Q: What is the `Extractor` in Rig used for?
    A: The `Extractor` in Rig is used for structured data extraction from text. It allows you to define a schema for the data you want to extract and uses an LLM to parse the information into that structure.

16. Q: How does Rig support text classification tasks?
    A: Rig supports text classification tasks through its `Extractor` functionality. You can define an enum or struct representing your classification categories and use an LLM to classify text into these categories.

17. Q: Can I use Rig with my own custom vector store implementation?
    A: Yes, you can use Rig with a custom vector store implementation by implementing the `VectorStore` trait for your storage solution. This allows you to integrate Rig with various database systems or specialized vector stores.

18. Q: How does Rig handle API rate limiting?
    A: Rig itself doesn't directly handle API rate limiting, but it's designed to work well with rate limiting strategies. You can implement retries with exponential backoff in your application logic when using Rig's API calls.

19. Q: What is the purpose of the `additional_params` in Rig's completion requests?
    A: The `additional_params` in Rig's completion requests allow you to pass provider-specific parameters to the LLM. This enables fine-tuning of the request beyond Rig's standard parameters.

20. Q: How can I use Rig with Cohere's web connectors?
    A: You can use Rig with Cohere's web connectors by adding the connector information to the `additional_params` when creating an agent or sending a completion request. For example:
    ```rust
    .additional_params(json!({
        "connectors": [{"id":"web-search", "options":{"site": "https://docs.rs/rig-core"}}]
    }))
    ```

21. Q: What is the difference between static and dynamic tools in Rig?
    A: Static tools in Rig are always available to an agent, while dynamic tools are retrieved from a vector store based on the current context. Dynamic tools allow for more flexible and context-aware tool usage.

22. Q: How does Rig handle context management in conversations?
    A: Rig allows you to manage conversation context through the `chat` method, which accepts a vector of previous messages. You can accumulate and pass the conversation history to maintain context across multiple interactions.

23. Q: Can I use Rig for fine-tuning LLMs?
    A: Rig currently doesn't provide direct support for fine-tuning LLMs. Its primary focus is on using pre-trained models efficiently. However, you can use Rig in conjunction with provider-specific fine-tuning processes.

24. Q: How does Rig ensure type safety when working with LLMs?
    A: Rig leverages Rust's strong type system to ensure type safety. It uses traits like `CompletionModel` and `EmbeddingModel` to define clear interfaces, and employs generics and type parameters to maintain type safety across different operations.

25. Q: What is the role of the `VectorStoreIndex` in Rig?
    A: The `VectorStoreIndex` in Rig provides methods for efficient similarity search within a vector store. It's used in RAG systems to retrieve relevant context based on the similarity between the query and stored documents.

26. Q: How can I implement a chatbot using Rig?
    A: Rig provides a `cli_chatbot` utility that you can use to quickly implement a command-line chatbot. Alternatively, you can create your own chatbot logic using Rig's `Chat` trait and agent functionality.

27. Q: What is the purpose of the `JsonSchema` derive macro often used with Rig?
    A: The `JsonSchema` derive macro is used in conjunction with Rig's `Extractor` functionality. It allows Rig to generate a JSON schema for your Rust types, which is then used to guide the LLM in extracting structured data.

28. Q: How does Rig handle asynchronous operations?
    A: Rig is designed to work with Rust's async ecosystem. It uses `async` functions throughout its API, allowing for efficient handling of I/O-bound operations like API calls to LLM providers.

29. Q: Can I use Rig in a web application?
    A: Yes, Rig can be used in web applications. While it doesn't provide web-specific functionality, its async design makes it suitable for use with web frameworks like Actix or Rocket.

30. Q: How does Rig compare to other LLM libraries?
    A: Rig differentiates itself by providing a unified API across different LLM providers, offering high-level abstractions like agents and RAG systems, and leveraging Rust's performance and safety features. It's designed to be extensible and integrate well with the Rust ecosystem.


31. Q: How does Rig handle token limits for LLM providers?
    A: Rig doesn't automatically handle token limits, but it allows you to set `max_tokens` when creating completion requests. It's up to the developer to manage token usage within the provider's limits.

32. Q: Can I use Rig with local LLM models?
    A: While Rig primarily supports cloud-based LLM providers, you could potentially implement the `CompletionModel` trait for a local model. However, this would require significant custom implementation.

33. Q: How does Rig support prompt engineering?
    A: Rig supports prompt engineering through its `preamble` feature in agents and the ability to customize completion requests. You can craft and refine prompts to guide the LLM's behavior effectively.

34. Q: What's the difference between `prompt` and `chat` methods in Rig?
    A: The `prompt` method is for single-turn interactions, while `chat` is for multi-turn conversations. `chat` allows you to pass in conversation history for context.

35. Q: How can I implement a custom embedding model in Rig?
    A: You can implement a custom embedding model by creating a struct that implements the `EmbeddingModel` trait. This would involve defining methods for embedding generation and specifying the maximum number of documents that can be processed at once.

36. Q: Does Rig support function calling features of LLMs?
    A: Yes, Rig supports function calling through its tool system. You can define tools that the LLM can "call" to perform specific actions or retrieve information.

37. Q: How does Rig handle concurrent requests to LLM providers?
    A: Rig is built on Rust's async ecosystem, which allows for efficient handling of concurrent requests. However, actual concurrency limits would depend on the specific LLM provider's API constraints.

38. Q: Can I use Rig for document summarization tasks?
    A: Yes, you can use Rig for document summarization. You could create an agent with a custom prompt designed for summarization, potentially using RAG for longer documents.

39. Q: How does Rig support semantic search?
    A: Rig supports semantic search through its vector store and embedding functionalities. You can embed documents and queries, then use vector similarity to find semantically related content.

40. Q: Can I use Rig with multiple LLM providers in the same application?
    A: Yes, Rig's design allows you to use multiple LLM providers in the same application. You can create different clients for each provider and use them as needed.

41. Q: How does Rig handle versioning of LLM models?
    A: Rig allows you to specify the model version when creating a completion model. It's up to the developer to manage and update model versions as needed.

42. Q: Can I use Rig for few-shot learning tasks?
    A: Yes, you can implement few-shot learning with Rig by including examples in your prompt or preamble when creating an agent or sending a completion request.

43. Q: How does Rig support debugging of LLM interactions?
    A: Rig doesn't provide built-in debugging tools, but its error types and the ability to inspect raw responses can aid in debugging. You can also implement your own logging or debugging mechanisms around Rig's API calls.

44. Q: Can I use Rig with Azure OpenAI services?
    A: While Rig doesn't have built-in support for Azure OpenAI, you could potentially implement a custom client that uses Azure OpenAI's API while conforming to Rig's traits and interfaces.

45. Q: How does Rig handle retries for failed API calls?
    A: Rig doesn't automatically handle retries. Implementing retry logic would be the responsibility of the application using Rig, possibly using a crate like `tokio-retry`.

46. Q: Can I use Rig for implementing a question-answering system?
    A: Yes, Rig is well-suited for building question-answering systems. You could use a RAG agent to retrieve relevant context and generate answers based on that context.

47. Q: How does Rig support prompt templating?
    A: Rig doesn't have a built-in prompt templating system, but you can implement your own templating logic when constructing prompts or preambles for agents.

48. Q: Can I use Rig for implementing a chatbot with personality?
    A: Yes, you can create a chatbot with a specific personality using Rig. You would define the personality in the agent's preamble and potentially through carefully crafted prompts.

49. Q: How does Rig handle API authentication for different providers?
    A: Rig typically uses API keys for authentication, which are provided when creating a client for a specific provider. The authentication process is abstracted away from the user once the client is set up.

50. Q: Can I use Rig for implementing a code generation tool?
    A: Yes, you can use Rig to implement a code generation tool. You would create an agent with appropriate prompts and potentially use tools to handle specific coding tasks or language features.

51. Q: How does Rig support working with multiple languages?
    A: Rig itself is language-agnostic when it comes to the text it processes. Support for multiple languages would primarily depend on the capabilities of the underlying LLM models being used.

52. Q: Can I use Rig for implementing a text-to-SQL tool?
    A: Yes, you could implement a text-to-SQL tool using Rig. You'd create an agent with appropriate prompts for SQL generation, and potentially use tools to validate or execute the generated SQL.

53. Q: How does Rig handle long documents that exceed token limits?
    A: Rig doesn't automatically handle document chunking. For long documents, you would need to implement your own logic to split the document into appropriate chunks, possibly using a sliding window approach with overlap.

54. Q: Can I use Rig with custom tokenizers?
    A: Rig uses the tokenizers provided by the LLM providers. If you need to use a custom tokenizer, you would need to implement that at the application level, outside of Rig's direct functionality.

55. Q: How does Rig support A/B testing of different prompts or models?
    A: Rig doesn't have built-in A/B testing functionality, but its flexible design allows you to implement A/B testing at the application level, creating different agents or completion requests for comparison.

56. Q: Can I use Rig for implementing a sentiment analysis tool?
    A: Yes, you can implement a sentiment analysis tool using Rig. You could use the `Extractor` functionality to classify text into sentiment categories, or create a custom tool for sentiment analysis.

57. Q: How does Rig handle caching of LLM responses?
    A: Rig doesn't provide built-in caching. If you need to cache LLM responses, you would implement this at the application level, possibly using a crate like `cached` or a database for persistence.

58. Q: Can I use Rig with quantized models?
    A: Rig's support for quantized models would depend on the LLM provider's API. As long as the provider exposes quantized models through their standard API, you should be able to use them with Rig.

59. Q: How does Rig support content moderation?
    A: Rig doesn't have built-in content moderation features. You would need to implement content moderation either by creating a custom tool, using provider-specific moderation APIs, or post-processing LLM outputs.

60. Q: Can I use Rig for implementing a text classification pipeline?
    A: Yes, you can implement a text classification pipeline using Rig. You could use the `Extractor` functionality or create a custom agent designed for classification tasks.

61. Q: How does Rig handle context window management for long conversations?
    A: Rig doesn't automatically manage context windows. For long conversations, you'd need to implement a custom solution, potentially using a sliding window approach or summarizing previous context. You could create a wrapper around Rig's `Chat` trait to handle this.

62. Q: Can Rig be used for implementing a federated learning system with LLMs?
    A: While Rig doesn't have built-in support for federated learning, you could potentially use it as part of a federated system. You'd need to implement the federated learning logic separately, using Rig to interact with LLMs for the learning process.

63. Q: How can I implement custom attention mechanisms using Rig?
    A: Rig doesn't provide direct access to model internals like attention mechanisms. However, you could simulate custom attention by carefully constructing prompts or by implementing a custom `CompletionModel` that incorporates your attention mechanism before calling the LLM.

64. Q: Can Rig be used for implementing a meta-learning system?
    A: Yes, you could use Rig as part of a meta-learning system. You'd likely create multiple agents with different configurations, use them to solve tasks, and then have a meta-agent that learns to select or combine these agents effectively.

65. Q: How does Rig support multi-modal AI systems?
    A: Rig is primarily designed for text-based LLMs. For multi-modal systems, you'd need to handle other modalities (like images or audio) separately and then integrate that with Rig's text capabilities, possibly using custom tools to bridge the modalities.

66. Q: Can Rig be used for implementing a hierarchical planning system?
    A: Yes, you could implement a hierarchical planning system using Rig. You might create multiple agents for different levels of planning, using tools to decompose high-level plans into more detailed sub-plans.

67. Q: How can I implement a system for detecting and mitigating LLM hallucinations using Rig?
    A: You could create a pipeline of agents: one to generate responses, another to fact-check or critique those responses, and a third to synthesize or correct based on the critique. You'd also likely use RAG to ground the responses in factual information.

68. Q: Can Rig be used for implementing a system that combines symbolic AI with neural approaches?
    A: Yes, Rig can be part of a neuro-symbolic system. You could use Rig's LLM capabilities for the neural part, and implement symbolic reasoning as custom tools. The agent would then serve as the interface between these two paradigms.

69. Q: How can I implement dynamic prompt generation using Rig?
    A: You could create a meta-agent responsible for generating prompts. This agent would take high-level instructions and generate specific prompts, which are then passed to other agents or used in completion requests.

70. Q: Can Rig be used for implementing a system that performs multi-hop reasoning?
    A: Yes, you can implement multi-hop reasoning with Rig. You'd create an agent that breaks down complex queries into a series of simpler questions, potentially using tools to store intermediate results, and then synthesizes the final answer.

71. Q: How can I implement a system for detecting and mitigating biases in LLM outputs using Rig?
    A: You could create a pipeline with multiple agents: one to generate content, another trained to detect various types of biases, and a third to revise the content to mitigate detected biases. You might also implement custom tools for specific bias detection algorithms.

72. Q: Can Rig be used for implementing a system that performs counterfactual reasoning?
    A: Yes, you can implement counterfactual reasoning with Rig. You'd create prompts that explicitly ask the LLM to consider alternative scenarios. You might also implement custom tools to help generate and track counterfactual scenarios.

73. Q: How can I implement a system for automatic prompt optimization using Rig?
    A: You could create a meta-agent that generates and tests multiple prompts for a given task. Implement a custom tool to evaluate the performance of each prompt, and use another agent to iteratively refine the prompts based on these evaluations.

74. Q: Can Rig be used for implementing a system that performs analogical reasoning?
    A: Yes, Rig can be used for analogical reasoning. You'd create prompts that explicitly ask the LLM to draw analogies. You might also implement custom tools to store and retrieve known analogies, or to evaluate the strength of proposed analogies.

75. Q: How can I implement a system for automatic error correction in LLM outputs using Rig?
    A: You could create a pipeline with one agent to generate content, another agent trained to detect errors (factual, grammatical, logical, etc.), and a third agent to correct these errors. You might also implement custom tools for specific types of error checking.

76. Q: Can Rig be used for implementing a system that performs causal reasoning?
    A: Yes, you can implement causal reasoning with Rig. You'd create prompts that explicitly ask about cause-and-effect relationships. You might also implement custom tools to represent and manipulate causal graphs.

77. Q: How can I implement a system for automatic code review using Rig?
    A: You could create an agent with a prompt engineered for code review tasks. Implement custom tools for static code analysis, and use the agent to synthesize human-readable reviews based on the tool outputs and its own analysis.

78. Q: Can Rig be used for implementing a system that performs temporal reasoning?
    A: Yes, Rig can be used for temporal reasoning. You'd create prompts that explicitly handle temporal concepts. You might also implement custom tools to represent and manipulate timelines or temporal logic statements.

79. Q: How can I implement a system for automatic data augmentation using Rig?
    A: You could create an agent that takes existing data examples and generates variations or new examples. Implement custom tools to validate the generated examples and ensure they meet specific criteria for your augmentation needs.

80. Q: Can Rig be used for implementing a system that performs abductive reasoning?
    A: Yes, you can implement abductive reasoning with Rig. Create prompts that ask the LLM to generate the best explanations for given observations. You might implement custom tools to evaluate the plausibility of different explanations.

81. Q: How can I implement a system for automatic ontology construction using Rig?
    A: Create an agent that extracts concepts and relationships from text. Implement custom tools to represent and manipulate ontological structures. Use another agent to refine and validate the constructed ontology.

82. Q: Can Rig be used for implementing a system that performs meta-cognition?
    A: Yes, you can implement meta-cognitive capabilities using Rig. Create agents that not only perform tasks but also reflect on their own performance, generating explanations for their reasoning and identifying areas of uncertainty.

83. Q: How can I implement a system for automatic theorem proving using Rig?
    A: While Rig isn't designed for formal theorem proving, you could create an agent that generates proof strategies. Implement custom tools for formal logic manipulation, and use the agent to guide the proof process, possibly in conjunction with a dedicated theorem prover.

84. Q: Can Rig be used for implementing a system that performs conceptual blending?
    A: Yes, you can implement conceptual blending with Rig. Create an agent that takes two or more concepts as input and generates novel combinations. Implement custom tools to evaluate the coherence and novelty of the blended concepts.

85. Q: How can I implement a system for automatic curriculum learning using Rig?
    A: Create a meta-agent that generates increasingly complex tasks. Implement custom tools to evaluate the performance of a learning agent on these tasks. Use another agent to adjust the curriculum based on the learning progress.

86. Q: Can Rig be used for implementing a system that performs non-monotonic reasoning?
    A: Yes, you can implement non-monotonic reasoning with Rig. Create prompts that allow for the retraction or modification of previous conclusions. Implement custom tools to manage a dynamic knowledge base that can be updated as new information arrives.

87. Q: How can I implement a system for automatic story generation using Rig?
    A: Create an agent with a prompt engineered for storytelling. Implement custom tools for managing plot structures, character development, and narrative coherence. Use multiple agents for different aspects of the story (e.g., plot, dialogue, descriptions).

88. Q: Can Rig be used for implementing a system that performs ethical reasoning?
    A: Yes, you can implement ethical reasoning with Rig. Create prompts that explicitly consider ethical principles and dilemmas. Implement custom tools to represent and reason about ethical frameworks. Use multiple agents to represent different ethical perspectives.

89. Q: How can I implement a system for automatic paraphrasing using Rig?
    A: Create an agent with a prompt designed for paraphrasing tasks. Implement custom tools to evaluate the semantic similarity between the original text and the paraphrase. Use another agent to iteratively refine the paraphrase based on similarity scores and other criteria.

90. Q: Can Rig be used for implementing a system that performs commonsense reasoning?
    A: Yes, you can implement commonsense reasoning with Rig. Create prompts that explicitly ask for commonsense inferences. Implement custom tools to access and query commonsense knowledge bases. Use RAG to ground the reasoning in a large body of general knowledge.

91. Q: How can I implement a system for automatic question generation using Rig?
    A: Create an agent with a prompt designed for question generation tasks. Implement custom tools to evaluate the quality and relevance of generated questions. Use another agent to refine the questions based on specific criteria (e.g., difficulty level, question type).

92. Q: Can Rig be used for implementing a system that performs defeasible reasoning?
    A: Yes, you can implement defeasible reasoning with Rig. Create prompts that allow for tentative conclusions that can be defeated by new information. Implement custom tools to manage a knowledge base of defeasible rules and exceptions.

93. Q: How can I implement a system for automatic text style transfer using Rig?
    A: Create multiple agents trained on different writing styles. Implement custom tools to analyze the stylistic features of text. Use one agent to decompose the content, another to transfer the style, and a third to ensure the transferred text maintains the original meaning.

94. Q: Can Rig be used for implementing a system that performs analogical problem-solving?
    A: Yes, you can implement analogical problem-solving with Rig. Create an agent that identifies structural similarities between a source problem and a target problem. Implement custom tools to map solutions from the source to the target domain.

95. Q: How can I implement a system for automatic metadata generation using Rig?
    A: Create an agent with a prompt designed to extract key information from content. Implement custom tools to validate and format the extracted metadata. Use another agent to enhance the metadata with additional relevant information from external sources.

96. Q: Can Rig be used for implementing a system that performs counterfactual explanation generation?
    A: Yes, you can implement counterfactual explanation generation with Rig. Create prompts that ask the LLM to identify minimal changes that would alter a prediction or outcome. Implement custom tools to validate the logical consistency of the generated counterfactuals.

97. Q: How can I implement a system for automatic text summarization with controllable attributes using Rig?
    A: Create an agent with a prompt designed for summarization tasks. Implement custom tools to measure various attributes of the summary (e.g., length, readability, focus on specific topics). Use another agent to iteratively refine the summary based on desired attribute values.

98. Q: Can Rig be used for implementing a system that performs multi-document synthesis?
    A: Yes, you can implement multi-document synthesis with Rig. Create an agent that extracts key information from multiple documents. Implement custom tools to detect and resolve conflicts between sources. Use another agent to synthesize a coherent output from the extracted information.

99. Q: How can I implement a system for automatic generation of explanations for black-box model predictions using Rig?
    A: Create an agent that generates human-readable explanations for model outputs. Implement custom tools to interface with the black-box model and extract relevant features. Use another agent to validate the explanations against the model's behavior.

100. Q: Can Rig be used for implementing a system that performs incremental learning?
     A: While Rig doesn't directly support model fine-tuning, you could implement a form of incremental learning. Create an agent that maintains a dynamic knowledge base, updating it with new information. Use this knowledge base in conjunction with RAG to inform the LLM's responses, effectively allowing it to "learn" new information over time.

# more questions and answers

1. Q: How do I set the `max_tokens` parameter when using Rig?
A: You can set the `max_tokens` parameter when building an agent or creating a completion request. For example:

```rust
let agent = openai_client.agent("gpt-4o")
    .preamble("You are a helpful assistant.")
    .max_tokens(150)  // Set max_tokens here
    .build();
```

Or when creating a completion request:

```rust
let response = model.completion_request("Your prompt here")
    .max_tokens(100)
    .send()
    .await?;
```

2. Q: How can I adjust the temperature setting in Rig?
A: You can set the temperature when building an agent or in a completion request:

```rust
let agent = openai_client.agent("gpt-4o")
    .temperature(0.7)  // Set temperature here
    .build();
```

3. Q: Can I use Rig with streaming responses from LLMs?
A: Yes, Rig supports streaming responses. You can use the `stream()` method on a completion request:

```rust
let mut stream = model.completion_request("Your prompt")
    .stream()
    .await?;

while let Some(chunk) = stream.next().await {
    println!("Chunk: {}", chunk?);
}
```

4. Q: How do I handle rate limiting with Rig?
A: Rig doesn't handle rate limiting internally. You should implement rate limiting in your application, possibly using a crate like `governor`:

```rust
use governor::{Quota, RateLimiter};
use std::num::NonZeroU32;

let limiter = RateLimiter::direct(Quota::per_minute(NonZeroU32::new(60).unwrap()));
limiter.until_ready().await;
// Then make your Rig API call
```

5. Q: How can I use Rig with a custom LLM provider?
A: To use Rig with a custom LLM provider, you need to implement the `CompletionModel` trait for your provider:

```rust
struct MyCustomModel;

impl CompletionModel for MyCustomModel {
    type Response = MyCustomResponse;

    async fn completion(&self, request: CompletionRequest) -> Result<CompletionResponse<Self::Response>, CompletionError> {
        // Implement your custom logic here
    }
}
```

6. Q: How do I use Rig's `Extractor` for structured data extraction?
A: To use the `Extractor`, define a struct that represents your data structure and use the `extractor` method:

```rust
#[derive(Deserialize, JsonSchema)]
struct PersonInfo {
    name: String,
    age: u8,
}

let extractor = openai_client.extractor::<PersonInfo>("gpt-4o").build();
let result = extractor.extract("John Doe is 30 years old").await?;
```

7. Q: Can I use Rig with Azure OpenAI services?
A: Rig doesn't have built-in support for Azure OpenAI, but you can create a custom client:

```rust
struct AzureOpenAIClient {
    // fields for Azure-specific configuration
}

impl CompletionModel for AzureOpenAIClient {
    // Implement the trait methods to work with Azure OpenAI
}
```

8. Q: How do I implement custom error handling with Rig?
A: You can create custom error types and use them in your implementations:

```rust
#[derive(Debug, thiserror::Error)]
enum MyCustomError {
    #[error("API error: {0}")]
    ApiError(String),
    // other error variants
}

impl From<MyCustomError> for CompletionError {
    fn from(error: MyCustomError) -> Self {
        CompletionError::ProviderError(error.to_string())
    }
}
```

9. Q: How can I use Rig with a vector database like Pinecone?
A: Implement the `VectorStore` trait for Pinecone:

```rust
struct PineconeStore {
    // Pinecone client fields
}

impl VectorStore for PineconeStore {
    // Implement the required methods
}
```

10. Q: How do I implement a custom `Tool` in Rig?
A: Create a struct and implement the `Tool` trait:

```rust
struct MyCustomTool;

impl Tool for MyCustomTool {
    const NAME: &'static str = "my_custom_tool";
    type Error = MyToolError;
    type Args = MyToolArgs;
    type Output = MyToolOutput;

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        // Implement tool logic
    }

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        // Define tool interface
    }
}
```

11. Q: How can I use Rig for multi-turn conversations?
A: Use the `chat` method and maintain a conversation history:

```rust
let mut history = Vec::new();
loop {
    let user_input = get_user_input();
    let response = agent.chat(&user_input, history.clone()).await?;
    history.push(Message { role: "user".into(), content: user_input });
    history.push(Message { role: "assistant".into(), content: response.clone() });
    println!("Assistant: {}", response);
}
```

12. Q: How do I implement custom tokenization with Rig?
A: Rig uses the tokenizers provided by LLM providers. For custom tokenization, you'd need to implement it at the application level:

```rust
fn custom_tokenize(text: &str) -> Vec<String> {
    // Your custom tokenization logic
}

let tokenized = custom_tokenize(&user_input);
let response = agent.prompt(&tokenized.join(" ")).await?;
```

13. Q: How can I use Rig for few-shot learning?
A: Include examples in your prompt or preamble:

```rust
let few_shot_agent = openai_client.agent("gpt-4o")
    .preamble("
        Classify the sentiment of the text. Examples:
        Input: I love this product!
        Output: Positive
        Input: This is terrible.
        Output: Negative
        Now classify the following:
    ")
    .build();
```
</file>

<file path="docs/examples/discord_rig_bot/documents/Rig_guide.md">
# Comprehensive Guide to Rig: Rust Library for LLM-Powered Applications

## 1. Introduction to Rig

Rig is an open-source Rust library designed to simplify the development of applications powered by Large Language Models (LLMs). It provides a unified API for working with different LLM providers, advanced AI workflow support, and flexible abstractions for building complex AI systems.

Key features of Rig include:
- Unified API across multiple LLM providers (e.g., OpenAI, Anthropic, Cohere, Perplexity)
- Support for completion and embedding workflows
- High-level abstractions for agents and RAG systems
- Extensible architecture for custom implementations
- Seamless integration with Rust's ecosystem
- Vector store support, including in-memory and LanceDB options

## 2. Core Concepts

### 2.1 Completion Models

Completion models are the foundation of LLM interactions in Rig. They implement the `CompletionModel` trait, which defines methods for generating completion requests and executing them.

```rust
pub trait CompletionModel: Clone + Send + Sync {
    type Response: Send + Sync;

    fn completion(
        &self,
        request: CompletionRequest,
    ) -> impl std::future::Future<Output = Result<CompletionResponse<Self::Response>, CompletionError>>
           + Send;

    fn completion_request(&self, prompt: &str) -> CompletionRequestBuilder<Self>;
}
```

### 2.2 Embedding Models

Embedding models are used for generating vector representations of text. They implement the `EmbeddingModel` trait:

```rust
pub trait EmbeddingModel: Clone + Sync + Send {
    const MAX_DOCUMENTS: usize;

    fn ndims(&self) -> usize;

    fn embed_documents(
        &self,
        documents: Vec<String>,
    ) -> impl std::future::Future<Output = Result<Vec<Embedding>, EmbeddingError>> + Send;
}
```

### 2.3 Agents

Agents in Rig combine an LLM model with a preamble (system prompt) and a set of tools. They are implemented using the `Agent` struct:

```rust
pub struct Agent<M: CompletionModel> {
    model: M,
    preamble: String,
    static_context: Vec<Document>,
    static_tools: Vec<String>,
    temperature: Option<f64>,
    max_tokens: Option<u64>,
    additional_params: Option<serde_json::Value>,
    dynamic_context: Vec<(usize, Box<dyn VectorStoreIndexDyn>)>,
    dynamic_tools: Vec<(usize, Box<dyn VectorStoreIndexDyn>)>,
    pub tools: ToolSet,
}
```

### 2.4 Tools

Tools are functionalities that agents can use to perform specific tasks. They implement the `Tool` trait:

```rust
pub trait Tool: Sized + Send + Sync {
    const NAME: &'static str;
    type Error: std::error::Error + Send + Sync + 'static;
    type Args: for<'a> Deserialize<'a> + Send + Sync;
    type Output: Serialize;

    fn name(&self) -> String;
    fn definition(&self, _prompt: String) -> impl Future<Output = ToolDefinition> + Send + Sync;
    fn call(
        &self,
        args: Self::Args,
    ) -> impl Future<Output = Result<Self::Output, Self::Error>> + Send + Sync;
}
```

### 2.5 Vector Stores

Vector stores are used for storing and retrieving embeddings. They implement the `VectorStore` trait:

```rust
pub trait VectorStore: Send + Sync {
    type Q;

    fn add_documents(
        &mut self,
        documents: Vec<DocumentEmbeddings>,
    ) -> impl std::future::Future<Output = Result<(), VectorStoreError>> + Send;

    fn get_document_embeddings(
        &self,
        id: &str,
    ) -> impl std::future::Future<Output = Result<Option<DocumentEmbeddings>, VectorStoreError>> + Send;

    // Other methods...
}
```

## 3. Building with Rig

### 3.1 Setting up a Project

To start a new project with Rig, add it to your `Cargo.toml`:

```toml
[dependencies]
rig-core = "0.2.1"
tokio = { version = "1.34.0", features = ["full"] }
```

### 3.2 Creating a Simple Agent

Here's how to create and use a simple agent:

```rust
use rig::{completion::Prompt, providers::openai};

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client = openai::Client::from_env();
    let agent = openai_client
        .agent("gpt-4o")
        .preamble("You are a helpful assistant.")
        .build();

    let response = agent.prompt("Explain quantum computing in one sentence.").await?;
    println!("Agent: {}", response);

    Ok(())
}
```

### 3.3 Implementing a Custom Tool

Here's an example of implementing a custom tool:

```rust
use rig::tool::Tool;
use rig::completion::ToolDefinition;
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Deserialize)]
struct AddArgs {
    x: i32,
    y: i32,
}

#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;

#[derive(Deserialize, Serialize)]
struct Adder;

impl Tool for Adder {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = AddArgs;
    type Output = i32;

    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                },
                "required": ["x", "y"]
            }),
        }
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        Ok(args.x + args.y)
    }
}
```

### 3.4 Creating an Agent with Tools

Here's how to create an agent with custom tools:

```rust
let agent = openai_client.agent("gpt-4o")
    .preamble("You are a calculator assistant.")
    .tool(Adder)
    .build();

let response = agent.prompt("Calculate 2 + 3").await?;
println!("Agent: {}", response);
```

### 3.5 Implementing a RAG System

Here's an example of setting up a RAG system with Rig:

```rust
use rig::embeddings::EmbeddingsBuilder;
use rig::vector_store::{in_memory_store::InMemoryVectorStore, VectorStore};

let embedding_model = openai_client.embedding_model(openai::TEXT_EMBEDDING_ADA_002);
let mut vector_store = InMemoryVectorStore::default();

let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
    .simple_document("doc1", "Rig is a Rust library for building LLM applications.")
    .simple_document("doc2", "Rig supports OpenAI, Anthropic, Cohere, and Perplexity as LLM providers.")
    .build()
    .await?;

vector_store.add_documents(embeddings).await?;

let rag_agent = openai_client.agent("gpt-4o")
    .preamble("You are an assistant that answers questions about Rig.")
    .dynamic_context(1, vector_store.index(embedding_model))
    .build();

let response = rag_agent.prompt("What is Rig?").await?;
println!("RAG Agent: {}", response);
```

## 4. Advanced Features

### 4.1 Customizing Completion Requests

Rig allows for fine-tuning completion requests:

```rust
let response = model.completion_request("Translate to French:")
    .temperature(0.7)
    .max_tokens(50)
    .additional_params(json!({"top_p": 0.9}))
    .send()
    .await?;
```

### 4.2 Batched Embeddings

For efficient embedding generation:

```rust
let embeddings = EmbeddingsBuilder::new(embedding_model)
    .simple_documents(vec![
        ("doc1", "Content 1"),
        ("doc2", "Content 2"),
        // ...
    ])
    .build()
    .await?;
```

### 4.3 Using Different LLM Providers

Rig supports multiple LLM providers. Here's how to use different providers:

```rust
// OpenAI
let openai_client = openai::Client::from_env();
let gpt4_agent = openai_client.agent("gpt-4o").build();

// Anthropic
let anthropic_client = anthropic::ClientBuilder::new(&std::env::var("ANTHROPIC_API_KEY")?)
    .build();
let claude_agent = anthropic_client.agent(anthropic::CLAUDE_3_5_SONNET).build();

// Cohere
let cohere_client = cohere::Client::new(&std::env::var("COHERE_API_KEY")?);
let command_agent = cohere_client.agent("command").build();

// Perplexity
let perplexity_client = perplexity::Client::new(&std::env::var("PERPLEXITY_API_KEY")?);
let llama_agent = perplexity_client.agent(perplexity::LLAMA_3_1_70B_INSTRUCT).build();
```

### 4.4 Using LanceDB for Vector Storage

Here's an example of using LanceDB with Rig:

```rust
use rig_lancedb::{LanceDbVectorStore, SearchParams};

let db = lancedb::connect("data/lancedb-store").execute().await?;

let table = db.create_table(
    "rig_docs",
    RecordBatchIterator::new(vec![record_batch], Arc::new(rig_lancedb::schema(model.ndims()))),
).execute().await?;

let search_params = SearchParams::default();
let vector_store = LanceDbVectorStore::new(table, model, "id", search_params).await?;

// Use vector_store in your RAG system...
```

## 5. Best Practices and Tips

1. **Error Handling**: Use Rig's error types for robust error handling.
2. **Asynchronous Programming**: Leverage Rust's async features with Rig for efficient I/O operations.
3. **Modular Design**: Break down complex AI workflows into reusable tools and agents.
4. **Security**: Always use environment variables or secure vaults for API keys.
5. **Testing**: Write unit tests for custom tools and mock LLM responses for consistent testing.
6. **Model Selection**: Choose appropriate models based on your task complexity and performance requirements.
7. **Prompt Engineering**: Craft clear and specific prompts, utilizing the `preamble` method for setting agent behavior.
8. **Vector Store Usage**: Use vector stores efficiently, generating embeddings once and reusing them when possible.

## 6. Troubleshooting Common Issues

1. **API Rate Limiting**: Implement retries with exponential backoff for API calls.
2. **Memory Usage**: For large document sets, consider using LanceDB or other database-backed vector stores instead of in-memory solutions.
3. **Compatibility**: Ensure you're using compatible versions of Rig and its dependencies.
4. **Embedding Dimensions**: Make sure to use the correct number of dimensions when working with embeddings and vector stores.

## 7. Community and Support

- GitHub Repository: https://github.com/0xPlaygrounds/rig
- Documentation: https://docs.rs/rig-core/latest/rig/
- Discord Community: [Join here] (replace with actual Discord link when available)

## 8. Future Roadmap

- Support for more LLM providers
- Enhanced performance optimizations
- Advanced AI workflow templates
- Ecosystem growth with additional tools and libraries
- Improved documentation and examples

This comprehensive guide covers the core concepts, usage patterns, and advanced features of Rig. It provides a solid foundation for developing LLM-powered applications using Rig and serves as a reference for both beginners and experienced users of the library.
</file>

<file path="docs/examples/discord_rig_bot/src/docs.md">
# Introduction

Welcome to the Rust Discord Bot documentation. This bot leverages the Rig library to provide AI-powered assistance.

# Installation

To install the bot, clone the repository and run `cargo run`.

# Usage

Use the `/hello` command to greet the bot and `/rust` to ask Rust-related questions.

# Advanced Features

The bot supports Retrieval-Augmented Generation (RAG) to answer questions based on this documentation.

# Troubleshooting

If you encounter issues, check your environment variables and ensure all dependencies are installed correctly.

# rag test 

test 1: this is the first test, ooopla
test 2: this is the second test, delicious
</file>

<file path="docs/examples/discord_rig_bot/src/main.rs">
// main.rs
mod rig_agent;
use anyhow::Result;
use serenity::async_trait;
use serenity::model::application::command::Command;
use serenity::model::application::interaction::{Interaction, InteractionResponseType};
use serenity::model::gateway::Ready;
use serenity::model::channel::Message;
use serenity::prelude::*;
use serenity::model::application::command::CommandOptionType;
use std::env;
use std::sync::Arc;
use tracing::{error, info, debug};
use rig_agent::RigAgent;
use dotenv::dotenv;
// Define a key for storing the bot's user ID in the TypeMap
struct BotUserId;
impl TypeMapKey for BotUserId {
    type Value = serenity::model::id::UserId;
}
struct Handler {
    rig_agent: Arc<RigAgent>,
}
#[async_trait]
impl EventHandler for Handler {
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        debug!("Received an interaction");
        if let Interaction::ApplicationCommand(command) = interaction {
            debug!("Received command: {}", command.data.name);
            let content = match command.data.name.as_str() {
                "hello" => "Hello! I'm your helpful Rust and Rig-powered assistant. How can I assist you today?".to_string(),
                "ask" => {
                    let query = command
                        .data
                        .options
                        .get(0)
                        .and_then(|opt| opt.value.as_ref())
                        .and_then(|v| v.as_str())
                        .unwrap_or("What would you like to ask?");
                    debug!("Query: {}", query);
                    match self.rig_agent.process_message(query).await {
                        Ok(response) => response,
                        Err(e) => {
                            error!("Error processing request: {:?}", e);
                            format!("Error processing request: {:?}", e)
                        }
                    }
                }
                _ => "Not implemented :(".to_string(),
            };
            debug!("Sending response: {}", content);
            if let Err(why) = command
                .create_interaction_response(&ctx.http, |response| {
                    response
                        .kind(InteractionResponseType::ChannelMessageWithSource)
                        .interaction_response_data(|message| message.content(content))
                })
                .await
            {
                error!("Cannot respond to slash command: {}", why);
            } else {
                debug!("Response sent successfully");
            }
        }
    }
    async fn message(&self, ctx: Context, msg: Message) {
        if msg.mentions_me(&ctx.http).await.unwrap_or(false) {
            debug!("Bot mentioned in message: {}", msg.content);
            let bot_id = {
                let data = ctx.data.read().await;
                data.get::<BotUserId>().copied()
            };
            if let Some(bot_id) = bot_id {
                let mention = format!("<@{}>", bot_id);
                let content = msg.content.replace(&mention, "").trim().to_string();
                debug!("Processed content after removing mention: {}", content);
                match self.rig_agent.process_message(&content).await {
                    Ok(response) => {
                        if let Err(why) = msg.channel_id.say(&ctx.http, response).await {
                            error!("Error sending message: {:?}", why);
                        }
                    }
                    Err(e) => {
                        error!("Error processing message: {:?}", e);
                        if let Err(why) = msg
                            .channel_id
                            .say(&ctx.http, format!("Error processing message: {:?}", e))
                            .await
                        {
                            error!("Error sending error message: {:?}", why);
                        }
                    }
                }
            } else {
                error!("Bot user ID not found in TypeMap");
            }
        }
    }
    async fn ready(&self, ctx: Context, ready: Ready) {
        info!("{} is connected!", ready.user.name);
        {
            let mut data = ctx.data.write().await;
            data.insert::<BotUserId>(ready.user.id);
        }
        let commands = Command::set_global_application_commands(&ctx.http, |commands| {
            commands
                .create_application_command(|command| {
                    command
                        .name("hello")
                        .description("Say hello to the bot")
                })
                .create_application_command(|command| {
                    command
                        .name("ask")
                        .description("Ask the bot a question")
                        .create_option(|option| {
                            option
                                .name("query")
                                .description("Your question for the bot")
                                .kind(CommandOptionType::String)
                                .required(true)
                        })
                })
        })
        .await;
        println!("Created the following global commands: {:#?}", commands);
    }
}
#[tokio::main]
async fn main() -> Result<()> {
    dotenv().ok();
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();
    let token = env::var("DISCORD_TOKEN").expect("Expected DISCORD_TOKEN in environment");
    let rig_agent = Arc::new(RigAgent::new().await?);
    let intents = GatewayIntents::GUILD_MESSAGES
        | GatewayIntents::DIRECT_MESSAGES
        | GatewayIntents::MESSAGE_CONTENT;
    let mut client = Client::builder(&token, intents)
        .event_handler(Handler {
            rig_agent: Arc::clone(&rig_agent),
        })
        .await
        .expect("Err creating client");
    if let Err(why) = client.start().await {
        error!("Client error: {:?}", why);
    }
    Ok(())
}
</file>

<file path="docs/examples/discord_rig_bot/src/rig_agent.rs">
// rig_agent.rs
use anyhow::{Context, Result};
use rig::providers::openai;
use rig::vector_store::in_memory_store::InMemoryVectorStore;
use rig::vector_store::VectorStore;
use rig::embeddings::EmbeddingsBuilder;
use rig::agent::Agent;
use rig::completion::Prompt;
use std::path::Path;
use std::fs;
use std::sync::Arc;
pub struct RigAgent {
    agent: Arc<Agent<openai::CompletionModel>>,
}
impl RigAgent {
    pub async fn new() -> Result<Self> {
        // Initialize OpenAI client
        let openai_client = openai::Client::from_env();
        let embedding_model = openai_client.embedding_model(openai::TEXT_EMBEDDING_3_SMALL);
        // Create vector store
        let mut vector_store = InMemoryVectorStore::default();
        // Get the current directory and construct paths to markdown files
        let current_dir = std::env::current_dir()?;
        let documents_dir = current_dir.join("documents");
        let md1_path = documents_dir.join("Rig_guide.md");
        let md2_path = documents_dir.join("Rig_faq.md");
        let md3_path = documents_dir.join("Rig_examples.md");
        // Load markdown documents
        let md1_content = Self::load_md_content(&md1_path)?;
        let md2_content = Self::load_md_content(&md2_path)?;
        let md3_content = Self::load_md_content(&md3_path)?;
        // Create embeddings and add to vector store
        let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
            .simple_document("Rig_guide", &md1_content)
            .simple_document("Rig_faq", &md2_content)
            .simple_document("Rig_examples", &md3_content)
            .build()
            .await?;
        vector_store.add_documents(embeddings).await?;
        // Create index
        let index = vector_store.index(embedding_model);
        // Create Agent
        let agent = Arc::new(openai_client.agent(openai::GPT_4O)
            .preamble("You are an advanced AI assistant powered by Rig, a Rust library for building LLM applications. Your primary function is to provide accurate, helpful, and context-aware responses by leveraging both your general knowledge and specific information retrieved from a curated knowledge base.
                    Key responsibilities and behaviors:
                    1. Information Retrieval: You have access to a vast knowledge base. When answering questions, always consider the context provided by the retrieved information.
                    2. Clarity and Conciseness: Provide clear and concise answers. Ensure responses are short and concise. Use bullet points or numbered lists for complex information when appropriate.
                    3. Technical Proficiency: You have deep knowledge about Rig and its capabilities. When discussing Rig or answering related questions, provide detailed and technically accurate information.
                    4. Code Examples: When appropriate, provide Rust code examples to illustrate concepts, especially when discussing Rig's functionalities. Always format code examples for proper rendering in Discord by wrapping them in triple backticks and specifying the language as 'rust'. For example:
                        ```rust
                        let example_code = \"This is how you format Rust code for Discord\";
                        println!(\"{}\", example_code);
                        ```
                    5. Keep your responses short and concise. If the user needs more information, they can ask follow-up questions.
                    ")
            .dynamic_context(2, index)
            .build());
        Ok(Self { agent })
    }
    fn load_md_content<P: AsRef<Path>>(file_path: P) -> Result<String> {
        fs::read_to_string(file_path.as_ref())
            .with_context(|| format!("Failed to read markdown file: {:?}", file_path.as_ref()))
    }
    pub async fn process_message(&self, message: &str) -> Result<String> {
        self.agent.prompt(message).await.map_err(anyhow::Error::from)
    }
}
</file>

<file path="docs/examples/discord_rig_bot/Cargo.toml">
[package]
name = "discord_rig_bot"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.2.1"
tokio = { version = "1.34.0", features = ["full"] }
serenity = { version = "0.11", default-features = false, features = ["client", "gateway", "rustls_backend", "cache", "model", "http"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0.75"
tracing = "0.1"
tracing-subscriber = "0.3"
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
schemars = "0.8"
async-trait = "0.1.83"
</file>

<file path="docs/examples/entity_extraction_example/src/main.rs">
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
enum EntityType {
    Person,
    Organization,
    Location,
    Date,
    Other(String),
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct Entity {
    entity_type: EntityType,
    name: String,
    confidence: f32,
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct ExtractedEntities {
    entities: Vec<Entity>,
    total_count: usize,
    extraction_time: String, // ISO 8601 formatted string
}
fn pretty_print_entities(extracted: &ExtractedEntities) {
    println!("Extracted Entities:");
    println!("Total Count: {}", extracted.total_count);
    println!("Extraction Time: {}", extracted.extraction_time);
    println!("Entities:");
    for entity in &extracted.entities {
        println!(
            "  - Type: {:?}, Name: {}, Confidence: {:.2}",
            entity.entity_type, entity.name, entity.confidence
        );
    }
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the OpenAI client
    let openai_client = openai::Client::from_env();
    // Create the extractor
    let extractor = openai_client
        .extractor::<ExtractedEntities>("gpt-4o")
        .preamble("You are an AI assistant specialized in extracting named entities from text. \
                   Your task is to identify and categorize entities such as persons, organizations, \
                   locations, and dates. Provide a confidence score for each entity identified.")
        .build();
    // Sample text for entity extraction
    let sample_text = "On July 20, 1969, Neil Armstrong and Buzz Aldrin, astronauts from NASA, \
                       became the first humans to land on the Moon as part of the Apollo 11 mission. \
                       The historic event was broadcast live by CBS News, anchored by Walter Cronkite \
                       from New York City.";
    println!("Extracting entities from the following text:\n{}\n", sample_text);
    // Extract entities
    match extractor.extract(sample_text).await {
        Ok(extracted_entities) => {
            pretty_print_entities(&extracted_entities);
        }
        Err(e) => eprintln!("Error extracting entities: {}", e),
    }
    Ok(())
}
</file>

<file path="docs/examples/entity_extraction_example/Cargo.toml">
[package]
name = "entity_extraction_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
</file>

<file path="docs/examples/entity_extraction_example/README.md">
# Entity Extraction with [Rig](https://github.com/0xPlaygrounds/rig)

This example demonstrates how to leverage [Rig](https://github.com/0xPlaygrounds/rig), a Rust library for building LLM-powered applications, to extract named entities from text. Whether you're new to Rig or looking to explore its capabilities, this example provides a great starting point for understanding how to work with custom data structures and AI-powered extraction.

## Prerequisites
Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at OpenAI's website.

## Setup

- Create a new Rust project: 
  - `cargo new rig-entity-extraction`
  - `cd rig-entity-extraction`

- Add the following dependencies to your `Cargo.toml`:
```
[dependencies]
rig-core = "0.1.0"
serde = { version = "1.0", features = ["derive"] }
schemars = "0.8"
tokio = { version = "1.0", features = ["full"] }
```

- Set your OpenAI API key as an environment variable: 
  - `export OPENAI_API_KEY=your_api_key_here`


## Code Overview

The main components of this example are:

- Custom data structures (EntityType, Entity, ExtractedEntities) for representing extracted entities.
- An OpenAI client initialization.
- An extractor setup using GPT-4 model.
- A sample text for entity extraction.
- The extraction process and result handling.

## Running the Example

- Copy the provided code into your src/main.rs file.
- Run the example using: `cargo run`


## Customization

Feel free to modify the `sample_text` or adjust the `EntityType` enum to suit your specific use case. You can also experiment with different OpenAI models by changing the model name in the extractor setup.


## Troubleshooting
If you encounter any issues:

- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/flight_search_assistant/src/flight_search_tool.rs">
use chrono::Utc;
use rig::completion::ToolDefinition;
use rig::tool::Tool;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;
use std::env;
#[derive(Deserialize)]
pub struct FlightSearchArgs {
    source: String,
    destination: String,
    date: Option<String>,
    sort: Option<String>,
    service: Option<String>,
    itinerary_type: Option<String>,
    adults: Option<u8>,
    seniors: Option<u8>,
    currency: Option<String>,
    nearby: Option<String>,
    nonstop: Option<String>,
}
#[derive(Debug, thiserror::Error)]
pub enum FlightSearchError {
    #[error("HTTP request failed: {0}")]
    HttpRequestFailed(String),
    #[error("Invalid response structure")]
    InvalidResponse,
    #[error("API error: {0}")]
    ApiError(String),
    #[error("Missing API key")]
    MissingApiKey,
}
#[derive(Serialize)]
pub struct FlightOption {
    airline: String,
    flight_number: String,
    departure: String,
    arrival: String,
    duration: String,
    stops: usize,
    price: f64,
    currency: String,
    booking_url: String,
}
pub struct FlightSearchTool;
impl Tool for FlightSearchTool {
    const NAME: &'static str = "search_flights";
    type Args = FlightSearchArgs;
    type Output = String; 
    type Error = FlightSearchError;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "search_flights".to_string(),
            description: "Search for flights between two airports".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "source": { "type": "string", "description": "Source airport code (e.g., 'BOM')" },
                    "destination": { "type": "string", "description": "Destination airport code (e.g., 'DEL')" },
                    "date": { "type": "string", "description": "Flight date in 'YYYY-MM-DD' format" },
                    "sort": { "type": "string", "description": "Sort order for results", "enum": ["ML_BEST_VALUE", "PRICE", "DURATION", "EARLIEST_OUTBOUND_DEPARTURE", "EARLIEST_OUTBOUND_ARRIVAL", "LATEST_OUTBOUND_DEPARTURE", "LATEST_OUTBOUND_ARRIVAL"] },
                    "service": { "type": "string", "description": "Class of service", "enum": ["ECONOMY", "PREMIUM_ECONOMY", "BUSINESS", "FIRST"] },
                    "itinerary_type": { "type": "string", "description": "Itinerary type", "enum": ["ONE_WAY", "ROUND_TRIP"] },
                    "adults": { "type": "integer", "description": "Number of adults" },
                    "seniors": { "type": "integer", "description": "Number of seniors" },
                    "currency": { "type": "string", "description": "Currency code (e.g., 'USD')" },
                    "nearby": { "type": "string", "description": "Include nearby airports", "enum": ["yes", "no"] },
                    "nonstop": { "type": "string", "description": "Show only nonstop flights", "enum": ["yes", "no"] },
                },
                "required": ["source", "destination"]
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        // Use the RapidAPI key from an environment variable
        let api_key = env::var("RAPIDAPI_KEY").map_err(|_| FlightSearchError::MissingApiKey)?;
        // Set default values if not provided
        let date = args.date.unwrap_or_else(|| {
            let date = chrono::Utc::now() + chrono::Duration::days(30);
            date.format("%Y-%m-%d").to_string()
        });
        let sort = args.sort.unwrap_or_else(|| "ML_BEST_VALUE".to_string());
        let service = args.service.unwrap_or_else(|| "ECONOMY".to_string());
        let itinerary_type = args.itinerary_type.unwrap_or_else(|| "ONE_WAY".to_string());
        let adults = args.adults.unwrap_or(1);
        let seniors = args.seniors.unwrap_or(0);
        let currency = args.currency.unwrap_or_else(|| "USD".to_string());
        let nearby = args.nearby.unwrap_or_else(|| "no".to_string());
        let nonstop = args.nonstop.unwrap_or_else(|| "no".to_string());
        // Build the query parameters
        let mut query_params = HashMap::new();
        query_params.insert("sourceAirportCode", args.source);
        query_params.insert("destinationAirportCode", args.destination);
        query_params.insert("date", date);
        query_params.insert("itineraryType", itinerary_type);
        query_params.insert("sortOrder", sort);
        query_params.insert("numAdults", adults.to_string());
        query_params.insert("numSeniors", seniors.to_string());
        query_params.insert("classOfService", service);
        query_params.insert("pageNumber", "1".to_string());
        query_params.insert("currencyCode", currency.clone());
        query_params.insert("nearby", nearby);
        query_params.insert("nonstop", nonstop);
        // Make the API request
        let client = reqwest::Client::new();
        let response = client
            .get("https://tripadvisor16.p.rapidapi.com/api/v1/flights/searchFlights")
            .headers({
                let mut headers = reqwest::header::HeaderMap::new();
                headers.insert(
                    "X-RapidAPI-Host",
                    "tripadvisor16.p.rapidapi.com".parse().unwrap(),
                );
                headers.insert("X-RapidAPI-Key", api_key.parse().unwrap());
                headers
            })
            .query(&query_params)
            .send()
            .await
            .map_err(|e| FlightSearchError::HttpRequestFailed(e.to_string()))?;
        // Get the status code before consuming `response`
        let status = response.status();
        // Read the response text (this consumes `response`)
        let text = response
            .text()
            .await
            .map_err(|e| FlightSearchError::HttpRequestFailed(e.to_string()))?;
        // Print the raw API response for debugging
        // println!("Raw API response:\n{}", text);
        // Check if the response is an error
        if !status.is_success() {
            return Err(FlightSearchError::ApiError(format!(
                "Status: {}, Response: {}",
                status, text
            )));
        }
        // Parse the response JSON
        let data: Value = serde_json::from_str(&text)
            .map_err(|e| FlightSearchError::HttpRequestFailed(e.to_string()))?;
        // Check for API errors in the JSON response
        if let Some(error) = data.get("error") {
            let error_message = error
                .get("message")
                .and_then(|m| m.as_str())
                .unwrap_or("Unknown error");
            return Err(FlightSearchError::ApiError(error_message.to_string()));
        }
        let empty_leg = json!({});
        // Extract flight options
        let mut flight_options = Vec::new();
        // Check if 'data' contains 'flights' array
        if let Some(flights) = data
            .get("data")
            .and_then(|d| d.get("flights"))
            .and_then(|f| f.as_array())
        {
            // Iterate over flight entries, taking the first 5
            for flight in flights.iter().take(5) {
                // Extract flight segments
                if let Some(segments) = flight
                    .get("segments")
                    .and_then(|s| s.as_array())
                    .and_then(|s| s.get(0))
                {
                    // Extract legs from the first segment
                    if let Some(legs) = segments.get("legs").and_then(|l| l.as_array()) {
                        let first_leg = legs.get(0).unwrap_or(&empty_leg);
                        let last_leg = legs.last().unwrap_or(&empty_leg); 
                        // Extract airline name
                        let airline = first_leg
                            .get("marketingCarrier")
                            .and_then(|mc| mc.get("displayName"))
                            .and_then(|dn| dn.as_str())
                            .unwrap_or("Unknown")
                            .to_string();
                        // Extract flight number
                        let flight_number = format!(
                            "{}{}",
                            first_leg
                                .get("marketingCarrierCode")
                                .and_then(|c| c.as_str())
                                .unwrap_or(""),
                            first_leg
                                .get("flightNumber")
                                .and_then(|n| n.as_str())
                                .unwrap_or("")
                        );
                        // Extract departure and arrival times
                        let departure = first_leg
                            .get("departureDateTime")
                            .and_then(|dt| dt.as_str())
                            .unwrap_or("")
                            .to_string();
                        let arrival = last_leg
                            .get("arrivalDateTime")
                            .and_then(|dt| dt.as_str())
                            .unwrap_or("")
                            .to_string();
                        // Parse departure time or fallback to current UTC time
                        let departure_time = chrono::DateTime::parse_from_rfc3339(&departure)
                            .map(|dt| dt.with_timezone(&Utc))
                            .unwrap_or_else(|_| chrono::Utc::now());
                        // Parse arrival time or fallback to current UTC time
                        let arrival_time = chrono::DateTime::parse_from_rfc3339(&arrival)
                            .map(|dt| dt.with_timezone(&Utc))
                            .unwrap_or_else(|_| chrono::Utc::now());
                        // Calculate flight duration
                        let duration = arrival_time - departure_time;
                        let hours = duration.num_hours();
                        let minutes = duration.num_minutes() % 60;
                        let duration_str = format!("{} hours {} minutes", hours, minutes);
                        // Determine number of stops
                        let stops = if legs.len() > 1 { legs.len() - 1 } else { 0 };
                        // Extract purchase links array for price information
                        let purchase_links = flight
                            .get("purchaseLinks")
                            .and_then(|pl| pl.as_array())
                            .map(|v| v.as_slice())
                            .unwrap_or(&[]);
                        // Find the best price from purchase links
                        let best_price = purchase_links.iter().min_by_key(|p| {
                            p.get("totalPrice")
                                .and_then(|tp| tp.as_f64())
                                .unwrap_or(f64::MAX) as u64
                        });
                        // Extract pricing and booking URL if available
                        if let Some(best_price) = best_price {
                            let total_price = best_price
                                .get("totalPrice")
                                .and_then(|tp| tp.as_f64())
                                .unwrap_or(0.0);
                            let booking_url = best_price
                                .get("url")
                                .and_then(|u| u.as_str())
                                .unwrap_or("")
                                .to_string();
                            // Skip flights with price 0.0
                            if total_price == 0.0 {
                                continue;
                            }
                            // Append extracted flight options to flight_options vector
                            flight_options.push(FlightOption {
                                airline,
                                flight_number,
                                departure,
                                arrival,
                                duration: duration_str,
                                stops,
                                price: total_price,
                                currency: currency.clone(),
                                booking_url,
                            });
                        }
                    }
                }
            }
        } else {
            // Return an error if response structure is invalid
            return Err(FlightSearchError::InvalidResponse);
        }
        // Format flight_options into a readable string
        // Check if there are any flight options
        if flight_options.is_empty() {
            return Ok("No flights found for the given criteria.".to_string());
        }
        // Initialize the output string
        let mut output = String::new();
        output.push_str("Here are some flight options:\n\n");
        // Iterate over each flight option and format the details
        for (i, option) in flight_options.iter().enumerate() {
            output.push_str(&format!("{}. **Airline**: {}\n", i + 1, option.airline));
            output.push_str(&format!(
                "   - **Flight Number**: {}\n",
                option.flight_number
            ));
            output.push_str(&format!("   - **Departure**: {}\n", option.departure));
            output.push_str(&format!("   - **Arrival**: {}\n", option.arrival));
            output.push_str(&format!("   - **Duration**: {}\n", option.duration));
            output.push_str(&format!(
                "   - **Stops**: {}\n",
                if option.stops == 0 {
                    "Non-stop".to_string()
                } else {
                    format!("{} stop(s)", option.stops)
                }
            ));
            output.push_str(&format!(
                "   - **Price**: {:.2} {}\n",
                option.price, option.currency
            ));
            output.push_str(&format!("   - **Booking URL**: {}\n\n", option.booking_url));
        }
        // Return the formatted flight options
        Ok(output)
    }
}
</file>

<file path="docs/examples/flight_search_assistant/src/main.rs">
mod flight_search_tool;
use crate::flight_search_tool::FlightSearchTool;
use rig::completion::Prompt;
use rig::providers::openai;
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the OpenAI client
    let openai_client = openai::Client::from_env();
    // Build the agent with the FlightSearchTool
    let agent = openai_client
        .agent("gpt-4o")
        .preamble("You are a travel assistant that can help users find flights between airports.")
        .tool(FlightSearchTool)
        .build();
    // query
    let response = agent
        .prompt("Find me flights from San Antonio (SAT) to London (LHR) on November 15th 2024.")
        .await?;
    // Deserialize the response to get the formatted string
    let formatted_response: String = serde_json::from_str(&response)?;
    println!("Agent response:\n{}", formatted_response);
    Ok(())
}
</file>

<file path="docs/examples/flight_search_assistant/Cargo.toml">
[package]
name = "travel_planner"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.1.0"
tokio = { version = "1.34.0", features = ["full"] }
anyhow = "1.0.75"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json"] }

# Environment variables
dotenvy = "0.15.7"
async-trait = "0.1"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
</file>

<file path="docs/examples/flight_search_assistant/README.md">
# Flight Search AI Assistant

Welcome to the **Flight Search AI Assistant** project! This application is an AI-powered assistant built with Rust using the [Rig](https://github.com/riggoio/rig) library. It allows users to find the cheapest flights between two airports through natural language queries.

## Table of Contents

- [Flight Search AI Assistant](#flight-search-ai-assistant)
  - [Table of Contents](#table-of-contents)
  - [Features](#features)
  - [Prerequisites](#prerequisites)
  - [Getting Started](#getting-started)
    - [Clone the Repository](#clone-the-repository)
    - [Set Up Environment Variables](#set-up-environment-variables)
  - [Build and Run](#build-and-run)
    - [Install Dependencies](#install-dependencies)
    - [Build the Project](#build-the-project)
    - [Run the Application](#run-the-application)
  - [How to Use](#how-to-use)
    - [Example Interaction](#example-interaction)
    - [Modifying the Prompt](#modifying-the-prompt)
  - [Code Structure](#code-structure)
    - [`main.rs`](#mainrs)
    - [`flight_search_tool.rs`](#flight_search_toolrs)
  - [Troubleshooting](#troubleshooting)
  - [Contributing](#contributing)
  - [License](#license)

## Features

- **Natural Language Queries**: Interact with the assistant using plain English.
- **Flight Search**: Find flights between any two airports.
- **Customizable**: Modify the code to add more features or tools.
- **Asynchronous Execution**: Built using asynchronous Rust for efficient performance.

## Prerequisites

Before you begin, ensure you have met the following requirements:

- **Rust**: Installed Rust programming language. If not, download and install it from [rust-lang.org](https://www.rust-lang.org/tools/install).
- **API Keys**:
  - **OpenAI API Key**: Sign up and get your key from [OpenAI API](https://platform.openai.com/account/api-keys).
  - **RapidAPI Key**: Sign up and get your key from [RapidAPI](https://rapidapi.com/hub). We'll use this to access the TripAdvisor Flight Search API.

## Getting Started

Follow these instructions to set up and run the project on your local machine.

### Clone the Repository

Open your terminal and run:

```bash
git clone https://github.com/0xPlaygrounds/awesome-rig.git
cd flight_search_assistant
```

### Set Up Environment Variables

Create a `.env` file in the root directory of the project to store your API keys:

```bash
touch .env
```

Open the `.env` file in your favorite text editor and add the following lines:

```env
OPENAI_API_KEY=your_openai_api_key_here
RAPIDAPI_KEY=your_rapidapi_key_here
```

Replace `your_openai_api_key_here` and `your_rapidapi_key_here` with your actual API keys.

**Note**: Ensure that the `.env` file is added to your `.gitignore` to prevent committing sensitive information.

## Build and Run

### Install Dependencies

Run the following command to download and compile all the dependencies:

```bash
cargo build
```

### Build the Project

To build the project, run:

```bash
cargo build --release
```

This will create an optimized build of the application.

### Run the Application

Execute the application using:

```bash
cargo run
```

You should see output similar to:

```
Agent response:
Here are some flight options:

1. **Airline**: Delta Air Lines
   - **Flight Number**: DL123
   - **Departure**: 2024-11-15T08:00:00-06:00
   - **Arrival**: 2024-11-15T10:45:00-05:00
   - **Duration**: 2 hours 45 minutes
   - **Stops**: Non-stop
   - **Price**: 250.00 USD
   - **Booking URL**: https://www.tripadvisor.com/CheapFlightsPartnerHandoff...

...
```

**Note**: The actual results may vary depending on the API response and the current date.

## How to Use

### Example Interaction

The agent is programmed to respond to natural language prompts. In `main.rs`, the prompt is set as:

```rust
let response = agent
    .prompt("Find me flights from San Antonio (SAT) to London (LHR) on November 15th 2024.")
    .await?;
```

You can modify this prompt to search for flights between different airports or on different dates.

### Modifying the Prompt

To change the interaction, open `src/main.rs` and edit the `prompt` method:

```rust
let response = agent
    .prompt("Your custom prompt here")
    .await?;
```

For example:

```rust
let response = agent
    .prompt("I need a flight from New York (JFK) to Tokyo (HND) on December 20th 2024.")
    .await?;
```

After modifying, save the file and run the application again:

```bash
cargo run
```

## Code Structure

### `main.rs`

This is the entry point of the application. It performs the following tasks:

- Initializes the OpenAI client using your API key.
- Builds the AI agent with a preamble and the `FlightSearchTool`.
- Sends a prompt to the agent.
- Prints the agent's response.

```rust
mod flight_search_tool;

use crate::flight_search_tool::FlightSearchTool;
use dotenv::dotenv;
use rig::completion::Prompt;
use rig::providers::openai;
use std::error::Error;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    dotenv().ok();

    // Initialize the OpenAI client
    let openai_client = openai::Client::from_env();

    // Build the agent with the FlightSearchTool
    let agent = openai_client
        .agent("gpt-4o")
        .preamble("You are a travel assistant that can help users find flights between airports.")
        .tool(FlightSearchTool)
        .build();

    // Send a prompt to the agent
    let response = agent
        .prompt("Find me flights from San Antonio (SAT) to London (LHR) on November 15th 2024.")
        .await?;

    // Print the agent's response
    println!("Agent response:\n{}", response);

    Ok(())
}
```

### `flight_search_tool.rs`

This file defines the `FlightSearchTool`, which interacts with the TripAdvisor Flight Search API to fetch flight information.

Key components:

- **Structs**:
  - `FlightSearchArgs`: Represents the input arguments for the flight search.
  - `FlightOption`: Represents each flight option returned by the API.
- **Error Handling**:
  - `FlightSearchError`: Custom error type to handle various errors that might occur.
- **Implementation**:
  - Implements the `Tool` trait for `FlightSearchTool`.
  - Defines the `definition` and `call` methods required by the trait.
  - The `call` method makes an HTTP request to the API, parses the response, and formats the output.

```rust
use chrono::Utc;
use rig::completion::ToolDefinition;
use rig::tool::Tool;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;
use std::env;

// Define the arguments for the flight search
#[derive(Deserialize)]
pub struct FlightSearchArgs {
    source: String,
    destination: String,
    date: Option<String>,
    // Additional optional parameters...
}

// Define the flight option structure
#[derive(Serialize)]
pub struct FlightOption {
    airline: String,
    flight_number: String,
    departure: String,
    arrival: String,
    duration: String,
    stops: usize,
    price: f64,
    currency: String,
    booking_url: String,
}

// Define custom error types
#[derive(Debug, thiserror::Error)]
pub enum FlightSearchError {
    #[error("HTTP request failed: {0}")]
    HttpRequestFailed(String),
    #[error("Invalid response structure")]
    InvalidResponse,
    #[error("API error: {0}")]
    ApiError(String),
    #[error("Missing API key")]
    MissingApiKey,
}

// Implement the Tool trait for FlightSearchTool
pub struct FlightSearchTool;

impl Tool for FlightSearchTool {
    const NAME: &'static str = "search_flights";

    type Args = FlightSearchArgs;
    type Output = String;
    type Error = FlightSearchError;

    // Define the tool
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        // Tool metadata and parameters
    }

    // Implement the call method
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        // Fetch API key, set defaults, build query params, make API request
        // Parse response and format output
    }
}
```

## Troubleshooting

- **Missing API Keys**: Ensure that your `.env` file contains the correct API keys and that the keys are valid.
- **Dependency Errors**: Run `cargo update` to update dependencies to their latest versions.
- **API Errors**: Check the API usage limits and ensure that your keys have sufficient permissions.

## Contributing

Contributions are welcome! If you'd like to add features, fix bugs, or improve documentation, feel free to open a pull request.

1. Fork the repository.
2. Create a new branch:

   ```bash
   git checkout -b feature/your-feature-name
   ```

3. Make your changes.
4. Commit and push:

   ```bash
   git commit -m "Description of your changes"
   git push origin feature/your-feature-name
   ```

5. Open a pull request on GitHub.

## License

This project is licensed under the [MIT License](LICENSE).

---

*Happy coding! If you have any questions or need further assistance, feel free to open an issue or reach out.*
</file>

<file path="docs/examples/get_balance/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{Config, SolanaAgentKit};
use solagent_plugin_solana::{get_balance, get_wallet_address};
#[tokio::main]
async fn main() {
    // Load configuration from environment variables
    let config = Config::from_env();
    let agent = SolanaAgentKit::new_from_env(config);
    // Get and display wallet address
    let wallet_address = get_wallet_address(&agent);
    println!("Wallet address: {}", wallet_address);
    match get_balance(&agent, None).await {
        Ok(balance) => println!("Account balance: {} SOL", balance),
        Err(e) => eprintln!("Error getting balance: {}", e),
    }
}
</file>

<file path="docs/examples/get_balance/Cargo.toml">
[package]
name = "get_balance"
version = "0.1.0"
edition = "2021"

[dependencies]
solagent-core = { path = "../../solagent-core" }
solagent-plugin-solana = { path = "../../solagent-plugins/solana" }
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/gibwork/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{solana_sdk::signature::Keypair, Config, SolanaAgentKit};
use solagent_plugin_gibwork::create_gibwork_task;
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    // Task details
    let title = "Implement New Feature";
    let content = "We need to implement a new authentication system using JWT tokens";
    let requirements =
        "- Experience with Rust and JWT\n- Understanding of authentication flows\n- Test coverage required";
    let tags = vec!["rust".to_string(), "authentication".to_string(), "jwt".to_string()];
    let token_mint_address = "So11111111111111111111111111111111111111112";
    let token_amount = 1_000_000_000; // 1 SOL = 1 billion lamports
    let payer = None;
    let response =
        create_gibwork_task(&agent, title, content, requirements, tags, token_mint_address, token_amount, payer)
            .await
            .unwrap();
    println!("Task created successfully!");
    println!("Task ID: {}", response.task_id);
    println!("Transaction signature: {}", response.signature);
}
</file>

<file path="docs/examples/gibwork/Cargo.toml">
[package]
name = "gibwork"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-gibwork = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/jupiter/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{solana_sdk::signature::Keypair, Config, SolanaAgentKit};
use solagent_plugin_jupiter::{stake_with_jup, trade};
/// Example on devnet
/// Mint: 5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm
/// https://explorer.solana.com/address/5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm?cluster=devnet
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    //swap 0.01 SOL to USDC
    let swap = trade(
        &agent,
        "So11111111111111111111111111111111111111112",
        0.01,
        Some("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string()),
        None,
    )
    .await
    .unwrap();
    println!("Signature: {}", swap);
    //stake 0.01 SOL
    let stake = stake_with_jup(&agent, 0.01).await.unwrap();
    println!("Signature: {}", stake);
}
</file>

<file path="docs/examples/jupiter/Cargo.toml">
[package]
name = "jupiter"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-jupiter = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/mint_nft/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{
    solana_sdk::{pubkey::Pubkey, signature::Keypair},
    Config, SolanaAgentKit,
};
use solagent_plugin_solana::{mint_nft_to_collection, NFTMetadata};
/// Example on devnet
/// Mint: 5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm
/// https://explorer.solana.com/address/5jcsea3EA3kX7mXpy7YvHVFYTDEJeSEXjyicgThnvWUm?cluster=devnet
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let name = "My First SolanaAgentKit NFT";
    let uri = "uri";
    let royalty_basis_points = Some(500);
    let creators = vec![(Pubkey::from_str_const("pubkey"), 100)];
    let metadata = NFTMetadata::new(name, uri, royalty_basis_points, Some(creators));
    let collection = Pubkey::from_str_const("collection Mint");
    let deployed_data = mint_nft_to_collection(&agent, collection, metadata).await.unwrap();
    println!("Mint: {}", deployed_data.mint);
}
</file>

<file path="docs/examples/mint_nft/Cargo.toml">
[package]
name = "mint_nft"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-solana = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/ollama/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// This example requires that you have the [`ollama`](https://ollama.com) server running locally.
/// More details: https://wale-e.github.io/ai/agent/framework/2025/01/01/hello-world-rig.html
///
use solagent_core::rig::{completion::Prompt, providers};
use solagent_rig_pyth::pyth_fetch_price::FetchPricePyTh;
#[tokio::main]
async fn main() -> Result<(), String> {
    let token_id = "So11111111111111111111111111111111111111112";
    let prompt = format!("fetch price of token_id {}", token_id);
    // Create an OpenAI client with a custom base url, a local ollama endpoint
    // The API Key is unnecessary for most local endpoints
    let client = providers::openai::Client::from_url("ollama", "http://localhost:11434/v1");
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("llama3.2")
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform operations.",
        )
        .tool(FetchPricePyTh)
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt(&prompt).await.unwrap();
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/ollama/Cargo.toml">
[package]
name = "ollama"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-rig-pyth = "0.1.1"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/pid_controller_tuner_example/src/main.rs">
use rig::providers::openai;
use rig::completion::Prompt;
use serde::{Deserialize, Serialize};
use std::error::Error;
// Simulate a second-order system
struct System {
    position: f64,
    velocity: f64,
}
impl System {
    fn new() -> Self {
        System {
            position: 0.0,
            velocity: 0.0,
        }
    }
    fn update(&mut self, force: f64, dt: f64) {
        let acceleration = force - 0.1 * self.velocity - 2.0 * self.position;
        self.velocity += acceleration * dt;
        self.position += self.velocity * dt;
    }
}
// PID Controller
struct PIDController {
    kp: f64,
    ki: f64,
    kd: f64,
    integral: f64,
    prev_error: f64,
}
impl PIDController {
    fn new(kp: f64, ki: f64, kd: f64) -> Self {
        PIDController {
            kp,
            ki,
            kd,
            integral: 0.0,
            prev_error: 0.0,
        }
    }
    fn calculate(&mut self, setpoint: f64, current_value: f64, dt: f64) -> f64 {
        let error = setpoint - current_value;
        self.integral += error * dt;
        let derivative = (error - self.prev_error) / dt;
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;
        self.prev_error = error;
        output
    }
}
// Performance metrics
fn calculate_performance_metrics(response: &[f64], setpoint: f64, dt: f64) -> (f64, f64, f64) {
    let steady_state_error = (response.last().unwrap() - setpoint).abs();
    let mut max_overshoot = 0.0;
    for &value in response.iter() {
        let overshoot = (value - setpoint).abs();
        if overshoot > max_overshoot {
            max_overshoot = overshoot;
        }
    }
    let settling_time = response.len() as f64 * dt;  // Simplified
    (settling_time, max_overshoot, steady_state_error)
}
#[derive(Debug, Serialize, Deserialize)]
struct PIDParams {
    kp: f64,
    ki: f64,
    kd: f64,
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let openai_client = openai::Client::from_env();
    let ai_tuner = openai_client.model("gpt-4o").build();
    let mut system = System::new();
    let mut pid = PIDController::new(1.0, 0.1, 0.05);  // Initial parameters
    let setpoint = 1.0;
    let dt = 0.01;
    let simulation_steps = 1000;
    for iteration in 0..10 {  // Run 10 tuning iterations
        let mut response = Vec::new();
        // Run simulation
        for _ in 0..simulation_steps {
            let control_signal = pid.calculate(setpoint, system.position, dt);
            system.update(control_signal, dt);
            response.push(system.position);
        }
        let (settling_time, max_overshoot, steady_state_error) = 
            calculate_performance_metrics(&response, setpoint, dt);
        println!("Iteration {}: ST = {:.2}, MO = {:.2}, SSE = {:.4}", 
                 iteration, settling_time, max_overshoot, steady_state_error);
        // Ask AI to suggest new PID parameters
        let prompt = format!(
            "Current PID parameters: Kp = {:.2}, Ki = {:.2}, Kd = {:.2}\n\
            Performance metrics:\n\
            Settling Time: {:.2}\n\
            Max Overshoot: {:.2}\n\
            Steady State Error: {:.4}\n\
            Suggest new PID parameters to improve performance. \
            Respond with a JSON object containing 'kp', 'ki', and 'kd' fields.",
            pid.kp, pid.ki, pid.kd, settling_time, max_overshoot, steady_state_error
        );
        let ai_response = ai_tuner.prompt(&prompt).await?;
        let new_params: PIDParams = serde_json::from_str(&ai_response)?;
        // Update PID parameters
        pid = PIDController::new(new_params.kp, new_params.ki, new_params.kd);
        // Reset system for next iteration
        system = System::new();
    }
    Ok(())
}
</file>

<file path="docs/examples/pid_controller_tuner_example/Cargo.toml">
[package]
name = "pid_controller_tuner_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
</file>

<file path="docs/examples/pid_controller_tuner_example/README.md">
# Adaptive PID Controller Tuner using [Rig](https://github.com/0xPlaygrounds/rig)

This project demonstrates how to leverage [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to create an AI agent that tunes a PID controller. Whether you're new to control systems or looking to explore AI-enhanced engineering applications, this example provides an excellent starting point.

### What is a PID Controller?

Before we dive in, let's briefly explain what a PID controller is:

A PID (Proportional-Integral-Derivative) controller is a control loop mechanism widely used in industrial systems. It continuously calculates an error value as the difference between a desired setpoint and a measured process variable and applies a correction based on proportional, integral, and derivative terms.

Imagine you're driving a car and trying to maintain a constant speed:
- The Proportional term is like your immediate response to speed changes.
- The Integral term is like your memory of past errors, helping eliminate persistent offsets.
- The Derivative term is like your anticipation of future changes based on the rate of change.

Tuning these three parameters (Kp, Ki, Kd) is crucial for optimal system performance.

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-pid-tuner
   cd rig-pid-tuner
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   tokio = { version = "1.0", features = ["full"] }
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. `System`: A struct simulating a simple second-order system.
2. `PIDController`: A struct implementing a basic PID controller.
3. Performance metric calculations (settling time, overshoot, steady-state error).
4. An AI agent using Rig to suggest PID parameter improvements.
5. A main loop simulating the system and allowing the AI to tune the controller.

### Running the Example

1. Copy the provided code into your `src/main.rs` file.
2. Run the example using:
   ```
   cargo run
   ```

### Understanding the Code

Let's break down the key parts of the code:

1. **System Simulation**: 
   We simulate a simple second-order system. Think of this as a simplified model of a physical system, like a spring-mass-damper system.

   ```rust
   struct System {
       position: f64,
       velocity: f64,
   }
   ```

2. **PID Controller**:
   This struct implements the PID control algorithm. It calculates the control output based on the error between the setpoint and the current value.

   ```rust
   struct PIDController {
       kp: f64,
       ki: f64,
       kd: f64,
       integral: f64,
       prev_error: f64,
   }
   ```

3. **Performance Metrics**:
   We calculate three key metrics:
   - Settling Time: How long it takes for the system to reach and stay within a certain range of the setpoint.
   - Max Overshoot: The maximum amount the system exceeds the setpoint.
   - Steady-State Error: The final difference between the system's output and the setpoint.

4. **AI Tuner**:
   We use Rig to create an AI agent that suggests improvements to the PID parameters based on the current performance metrics.

   ```rust
   let ai_tuner = openai_client.model("gpt-4o").build();
   ```

5. **Main Loop**:
   In the main function, we run multiple iterations of:
   - Simulating the system
   - Calculating performance metrics
   - Using the AI to suggest new PID parameters
   - Updating the controller with the new parameters

### Customization

Feel free to modify the `System` struct to simulate different types of systems, or adjust the performance metric calculations to focus on different aspects of system performance.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/plugin/src/main.rs">
use solagent_core::{
    rig::{
        completion::Prompt,
        providers::gemini::{self, completion::GEMINI_1_5_FLASH},
    },
    solana_sdk::signer::keypair::Keypair,
    *,
};
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let _v = solagent_plugin_cookie::search_tweets(&agent, "ztgx5", "2025-01-01", "2025-01-20").await.unwrap();
    let _v =
        solagent_plugin_goplus::get_solana_token_security_info("So11111111111111111111111111111111111111112").await;
    let _v = solagent_plugin_solana::get_tps(&agent).await;
    let tool = solagent_rig_goplus::TokenMaliciousInfo::new();
    let client = gemini::Client::from_env();
    let agent = client
        .agent(GEMINI_1_5_FLASH)
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform operations.",
        )
        .max_tokens(1024)
        .tool(tool)
        .build();
    let response = agent
        .prompt("check token malicious solana So11111111111111111111111111111111111111112")
        .await
        .expect("Failed to prompt Gemini");
    println!("Gemini response: {response}");
}
</file>

<file path="docs/examples/plugin/.gitignore">
/target
</file>

<file path="docs/examples/plugin/Cargo.toml">
[package]
name = "plugin"
version = "0.1.0"
edition = "2021"

[dependencies]
solagent-core = "0.1.1"
solagent-plugin-goplus = "0.1.0"
solagent-plugin-solana = "0.1.0"
solagent-plugin-cookie = "0.1.0"
solagent-rig-goplus = "0.1.0"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/pumpfun/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_core::{solana_sdk::signature::Keypair, Config, SolanaAgentKit};
use solagent_plugin_pumpfun::launch_token_pumpfun;
#[tokio::main]
async fn main() {
    // Create a new keypair
    let keypair = Keypair::new();
    // Encode the secret key to base58
    let private_key = keypair.to_base58_string();
    let config = Config { cookie_api_key: Some("".to_string()), ..Default::default() };
    let agent = SolanaAgentKit::new(&private_key, "https://api.devnet.solana.com", config);
    let res = launch_token_pumpfun(
        &agent,
        "Matt",
        "$MATT",
        "This is a test token for Matt.",
        "https://pbs.twimg.com/profile_images/1708966909952073729/XrWDSfm4_400x400.jpg",
        None,
    )
    .await
    .unwrap();
    println!("Pumpfun Token response: {:?}", res);
}
</file>

<file path="docs/examples/pumpfun/Cargo.toml">
[package]
name = "pumpfun"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-pumpfun = "0.1.0"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/rag_system/src/main.rs">
use rig::providers::openai;
use rig::vector_store::in_memory_store::InMemoryVectorStore;
use rig::vector_store::VectorStore;
use rig::embeddings::EmbeddingsBuilder;
use rig::cli_chatbot::cli_chatbot;  // Import the cli_chatbot function
use std::path::Path;
use anyhow::{Result, Context};
use pdf_extract::extract_text;
fn load_pdf_content<P: AsRef<Path>>(file_path: P) -> Result<String> {
    extract_text(file_path.as_ref())
        .with_context(|| format!("Failed to extract text from PDF: {:?}", file_path.as_ref()))
}
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize OpenAI client
    let openai_client = openai::Client::from_env();
    let embedding_model = openai_client.embedding_model("text-embedding-ada-002");
    // Create vector store
    let mut vector_store = InMemoryVectorStore::default();
    // Get the current directory and construct paths to PDF files
    let current_dir = std::env::current_dir()?;
    let documents_dir = current_dir.join("documents");
    let pdf1_path = documents_dir.join("Moores_Law_for_Everything.pdf");
    let pdf2_path = documents_dir.join("The_Last_Question.pdf");
    // Load PDF documents
    let pdf1_content = load_pdf_content(&pdf1_path)?;
    let pdf2_content = load_pdf_content(&pdf2_path)?;
    // Create embeddings and add to vector store
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .simple_document("Moores_Law_for_Everything", &pdf1_content)
        .simple_document("The_Last_Question", &pdf2_content)
        .build()
        .await?;
    vector_store.add_documents(embeddings).await?;
    // Create RAG agent
    let rag_agent = openai_client.context_rag_agent("gpt-4o")
        .preamble("You are a helpful assistant that answers questions based on the given context from PDF documents.")
        .dynamic_context(2, vector_store.index(embedding_model))
        .build();
    // Use the cli_chatbot function to create the CLI interface
    cli_chatbot(rag_agent).await?;
    Ok(())
}
</file>

<file path="docs/examples/rag_system/Cargo.toml">
[package]
name = "rag_system"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.34.0", features = ["full"] }
anyhow = "1.0.75"
pdf-extract = "0.7.3"
</file>

<file path="docs/examples/rag_system/README.md">
# Building a RAG Agent over PDF files using Rig

## Overview

This project demonstrates a Retrieval-Augmented Generation (RAG) system built with Rig, a Rust library for developing LLM-powered applications. The system processes PDF documents, creates embeddings, and uses OpenAI's GPT-4o model to answer questions based on the content of these documents.

In this example, we use two PDF documents:

1. "Moore's Law for Everything" by Sam Altman
2. "The Last Question" by Isaac Asimov

## Features

- PDF text extraction
- Document embedding using OpenAI's text-embedding-ada-002 model
- In-memory vector store for quick retrieval
- Dynamic context generation for each query
- Interactive Q&A interface

## Prerequisites

Before you begin, ensure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, sign up at [OpenAI's website](https://openai.com).

## Setup

1. Clone this repository:

   ```
   git clone this repo
   cd pdf-rag-system
   ```

2. Set your OpenAI API key as an environment variable:

   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

3. Ensure you have the following PDF documents in a `documents` folder in your project root:
   - `Moores_Law_for_Everything.pdf`
   - `The_Last_Question.pdf`

## Running the Application

1. Build and run the application:

   ```
   cargo run
   ```

2. Once the system is ready, you'll see the message: "RAG System ready. Type 'exit' to quit."

3. Enter your questions at the prompt. The system will provide answers based on the content of the PDF documents.

4. To exit the application, type 'exit' at the prompt.

## Example Usage

```
RAG System ready. Type 'exit' to quit.
Enter your question: tell me the premise of what sam altman is talking about
Response: Sam Altman discusses the coming technological revolution driven by powerful artificial intelligence (AI) systems that can think, learn, and perform tasks currently done by people. He highlights how this AI revolution will lead to the creation of phenomenal wealth but also emphasizes the need for policy changes to distribute this wealth and ensure inclusivity in society. Altman proposes the idea of embracing AI advancements, transitioning taxation from labor to capital (such as companies and land), and distributing wealth equitably through the American Equity Fund. This plan aims to improve the standard of living for everyone by leveraging technology and fair economic policies in a rapidly changing future.
Enter your question: 
```

## How It Works

1. **PDF Processing**: The system extracts text from the specified PDF documents.
2. **Embedding Creation**: It generates embeddings for the extracted text using OpenAI's embedding model.
3. **Vector Store**: The embeddings are stored in an in-memory vector store for quick retrieval.
4. **Query Processing**: When a user enters a question, the system:
   a. Generates an embedding for the question.
   b. Retrieves the most relevant context from the vector store.
   c. Sends the question and context to the GPT-4o model.
   d. Returns the model's response to the user.

## Customization

- To use different PDF documents, place them in the `documents` folder and update the file paths in the `main` function.
- You can adjust the number of relevant documents retrieved for each query by changing the `dynamic_context` parameter.
- To use a different OpenAI model, modify the model name in the `context_rag_agent` function call.

## Troubleshooting

If you encounter any issues:

- Ensure your OpenAI API key is correctly set.
- Verify that the PDF documents are in the correct location and are readable.
- Check that all dependencies are properly installed by running `cargo build`.

## Dependencies

This project uses the following main dependencies:

- `rig-core`: For building LLM-powered applications
- `pdf-extract`: For extracting text from PDF files
- `tokio`: For asynchronous runtime
- `anyhow`: For error handling

For a complete list of dependencies, refer to the `Cargo.toml` file.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
</file>

<file path="docs/examples/rig/common/mongodb.rs">
use rig_mongodb::MongoDbPool;
use anyhow::Result;
use std::sync::Arc;
use crate::config::mongodb::MongoConfig;
pub async fn create_mongo_pool() -> Result<Arc<MongoDbPool>> {
    let config = MongoConfig::from_env();
    config.create_pool().await
}
pub async fn validate_connection(pool: &MongoDbPool) -> Result<()> {
    pool.database("admin")
        .run_command(rig_mongodb::bson::doc! { "ping": 1 }, None)
        .await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_autonomous.rs">
use rig::providers::openai::Client;
use schemars::JsonSchema;
use std::env;
#[derive(Debug, serde::Deserialize, JsonSchema, serde::Serialize)]
struct Counter {
    /// The score of the document
    number: u32,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let agent = openai_client.extractor::<Counter>("gpt-4o")
        .preamble("
            Your role is to add a random number between 1 and 64 (using only integers) to the previous number.
        ")
        .build();
    let mut number: u32 = 0;
    let mut interval = tokio::time::interval(std::time::Duration::from_secs(1));
    // Loop the agent and allow it to run autonomously. If it hits the target number (2000 or above)
    // we then terminate the loop and return the number
    // Note that the tokio interval is to avoid being rate limited
    loop {
        // Prompt the agent and print the response
        let response = agent.extract(&number.to_string()).await.unwrap();
        if response.number >= 2000 {
            break;
        } else {
            number += response.number
        }
        interval.tick().await;
    }
    println!("Finished with number: {number:?}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_evaluator_optimizer.rs">
use std::env;
use rig::{completion::Prompt, providers::openai::Client};
use schemars::JsonSchema;
#[derive(serde::Deserialize, JsonSchema, serde::Serialize, Debug)]
struct Evaluation {
    evaluation_status: EvalStatus,
    feedback: String,
}
#[derive(serde::Deserialize, JsonSchema, serde::Serialize, Debug, PartialEq)]
enum EvalStatus {
    Pass,
    NeedsImprovement,
    Fail,
}
const TASK: &str = "Implement a Stack with:
1. push(x)
2. pop()
3. getMin()
All operations should be O(1).
";
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let generator_agent = openai_client
        .agent("gpt-4o")
        .preamble(
            "
            Your goal is to complete the task based on <user input>. If there are feedback
            from your previous generations, you should reflect on them to improve your solution
            Output your answer concisely in the following format:
            Thoughts:
            [Your understanding of the task and feedback and how you plan to improve]
            Response:
            [Your code implementation here]
        ",
        )
        .build();
    let evaluator_agent = openai_client.extractor::<Evaluation>("gpt-4o")
        .preamble("
            Evaluate this following code implementation for:
            1. code correctness
            2. time complexity
            3. style and best practices
            You should be evaluating only and not attempting to solve the task.
            Only output \"PASS\" if all criteria are met and you have no further suggestions for improvements.
            Provide detailed feedback if there are areas that need improvement. You should specify what needs improvement and why.
            Only output JSON.
        ")
        .build();
    let mut memories: Vec<String> = Vec::new();
    let mut response = generator_agent.prompt(TASK).await.unwrap();
    memories.push(response.clone());
    loop {
        let eval_result = evaluator_agent
            .extract(&format!("{TASK}\n\n{response}"))
            .await
            .unwrap();
        if eval_result.evaluation_status == EvalStatus::Pass {
            break;
        } else {
            let context = format!("{TASK}\n\n{}", eval_result.feedback);
            response = generator_agent.prompt(context).await.unwrap();
            memories.push(response.clone());
        }
    }
    println!("Response: {response}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_orchestrator.rs">
use std::env;
use rig::providers::openai::Client;
use schemars::JsonSchema;
#[derive(serde::Deserialize, JsonSchema, serde::Serialize, Debug)]
struct Specification {
    tasks: Vec<Task>,
}
#[derive(serde::Deserialize, JsonSchema, serde::Serialize, Debug)]
struct Task {
    original_task: String,
    style: String,
    guidelines: String,
}
#[derive(serde::Deserialize, JsonSchema, serde::Serialize, Debug)]
struct TaskResults {
    style: String,
    response: String,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    // Note that you can also create your own semantic router for this
    // that uses a vector store under the hood
    let classify_agent = openai_client.extractor::<Specification>("gpt-4")
        .preamble("
            Analyze the given task and break it down into 2-3 distinct approaches.
            Provide an Analysis:
            Explain your understanding of the task and which variations would be valuable.
            Focus on how each approach serves different aspects of the task.
            Along with the analysis, provide 2-3 approaches to tackle the task, each with a brief description:
            Formal style: Write technically and precisely, focusing on detailed specifications
            Conversational style: Write in a friendly and engaging way that connects with the reader
            Hybrid style: Tell a story that includes technical details, combining emotional elements with specifications
            Return only JSON output.
            ")
        .build();
    let specification = classify_agent.extract("
        Write a product description for a new eco-friendly water bottle.
        The target_audience is environmentally conscious millennials and key product features are: plastic-free, insulated, lifetime warranty
        ").await.unwrap();
    let content_agent = openai_client
        .extractor::<TaskResults>("gpt-4")
        .preamble(
            "
                Generate content based on the original task, style, and guidelines.
                Return only your response and the style you used as a JSON object.
                ",
        )
        .build();
    let mut vec: Vec<TaskResults> = Vec::new();
    for task in specification.tasks {
        let results = content_agent
            .extract(&format!(
                "
            Task: {},
            Style: {},
            Guidelines: {}
            ",
                task.original_task, task.style, task.guidelines
            ))
            .await
            .unwrap();
        vec.push(results);
    }
    let judge_agent = openai_client
        .extractor::<Specification>("gpt-4")
        .preamble(
            "
            Analyze the given written materials and decide the best one, giving your reasoning.
            Return the style as well as the corresponding material you have chosen as a JSON object.
            ",
        )
        .build();
    let task_results_raw_json = serde_json::to_string_pretty(&vec).unwrap();
    let results = judge_agent.extract(&task_results_raw_json).await.unwrap();
    println!("Results: {results:?}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_parallelization.rs">
use std::env;
use rig::pipeline::agent_ops::extract;
use rig::{
    parallel,
    pipeline::{self, passthrough, Op},
    providers::openai::Client,
};
use schemars::JsonSchema;
#[derive(serde::Deserialize, JsonSchema, serde::Serialize)]
struct DocumentScore {
    /// The score of the document
    score: f32,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let manipulation_agent = openai_client
        .extractor::<DocumentScore>("gpt-4")
        .preamble(
            "
            Your role is to score a user's statement on how manipulative it sounds between 0 and 1.
        ",
        )
        .build();
    let depression_agent = openai_client
        .extractor::<DocumentScore>("gpt-4")
        .preamble(
            "
            Your role is to score a user's statement on how depressive it sounds between 0 and 1.
        ",
        )
        .build();
    let intelligent_agent = openai_client
        .extractor::<DocumentScore>("gpt-4")
        .preamble(
            "
            Your role is to score a user's statement on how intelligent it sounds between 0 and 1.
        ",
        )
        .build();
    let chain = pipeline::new()
        .chain(parallel!(
            passthrough(),
            extract(manipulation_agent),
            extract(depression_agent),
            extract(intelligent_agent)
        ))
        .map(|(statement, manip_score, dep_score, int_score)| {
            format!(
                "
                Original statement: {statement}
                Manipulation sentiment score: {}
                Depression sentiment score: {}
                Intelligence sentiment score: {}
                ",
                manip_score.unwrap().score,
                dep_score.unwrap().score,
                int_score.unwrap().score
            )
        });
    // Prompt the agent and print the response
    let response = chain
        .call("I hate swimming. The water always gets in my eyes.")
        .await;
    println!("Pipeline run: {response:?}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_prompt_chaining.rs">
use std::env;
use rig::{
    pipeline::{self, Op},
    providers::openai::Client,
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let rng_agent = openai_client.agent("gpt-4o")
        .preamble("
            You are a random number generator designed to only either output a single whole integer that is 0 or 1. Only return the number.
        ")
        .build();
    let adder_agent = openai_client.agent("gpt-4o")
        .preamble("
            You are a mathematician who adds 1000 to every number passed into the context, except if the number is 0 - in which case don't add anything. Only return the number.
        ")
        .build();
    let chain = pipeline::new()
        // Generate a whole number that is either 0 and 1
        .prompt(rng_agent)
        .map(|x| x.unwrap())
        .prompt(adder_agent);
    // Prompt the agent and print the response
    let response = chain
        .call("Please generate a single whole integer that is 0 or 1".to_string())
        .await;
    println!("Pipeline result: {response:?}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_routing.rs">
use std::env;
use rig::{
    pipeline::{self, Op, TryOp},
    providers::openai::Client,
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    // Note that you can also create your own semantic router for this
    // that uses a vector store under the hood
    let animal_agent = openai_client.agent("gpt-4")
        .preamble("
            Your role is to categorise the user's statement using the following values: [sheep, cow, dog]
            Return only the value.
        ")
        .build();
    let default_agent = openai_client.agent("gpt-4").build();
    let chain = pipeline::new()
        // Use our classifier agent to classify the agent under a number of fixed topics
        .prompt(animal_agent)
        // Change the prompt depending on the output from the prompt
        .map_ok(|x: String| match x.trim() {
            "cow" => Ok("Tell me a fact about the United States of America.".to_string()),
            "sheep" => Ok("Calculate 5+5 for me. Return only the number.".to_string()),
            "dog" => Ok("Write me a poem about cashews".to_string()),
            message => Err(format!("Could not process - received category: {message}")),
        })
        .map(|x| x.unwrap().unwrap())
        // Send the prompt back into another agent with no pre-amble
        .prompt(default_agent);
    // Prompt the agent and print the response
    let response = chain.try_call("Sheep can self-medicate").await?;
    println!("Pipeline result: {response:?}");
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_context.rs">
use std::env;
use rig::{agent::AgentBuilder, completion::Prompt, providers::cohere};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI and Cohere clients
    // let openai_client = openai::Client::new(&env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"));
    let cohere_client =
        cohere::Client::new(&env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set"));
    // let model = openai_client.completion_model("gpt-4");
    let model = cohere_client.completion_model("command-r");
    // Create an agent with multiple context documents
    let agent = AgentBuilder::new(model)
        .context("Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .context("Definition of a *glarb-glarb*: A glarb-glarb is an ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .context("Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build();
    // Prompt the agent and print the response
    let response = agent.prompt("What does \"glarb-glarb\" mean?").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_deepseek.rs">
use rig::{
    completion::{Prompt, ToolDefinition},
    providers,
    tool::Tool,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .init();
    let client = providers::deepseek::Client::from_env();
    let agent = client
        .agent("deepseek-chat")
        .preamble("You are a helpful assistant.")
        .build();
    let answer = agent.prompt("Tell me a joke").await?;
    println!("Answer: {}", answer);
    // Create agent with a single context prompt and two tools
    let calculator_agent = client
        .agent(providers::deepseek::DEEPSEEK_CHAT)
        .preamble("You are a calculator here to help the user perform arithmetic operations. Use the tools provided to answer the user's question.")
        .max_tokens(1024)
        .tool(Adder)
        .tool(Subtract)
        .build();
    // Prompt the agent and print the response
    println!("Calculate 2 - 5");
    println!(
        "DeepSeek Calculator Agent: {}",
        calculator_agent.prompt("Calculate 2 - 5").await?
    );
    Ok(())
}
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Deserialize, Serialize)]
struct Adder;
impl Tool for Adder {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        println!("[tool-call] Adding {} and {}", args.x, args.y);
        let result = args.x + args.y;
        Ok(result)
    }
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        println!("[tool-call] Subtracting {} from {}", args.y, args.x);
        let result = args.x - args.y;
        Ok(result)
    }
}
</file>

<file path="docs/examples/rig/agent_with_galadriel.rs">
use rig::{completion::Prompt, providers};
use std::env;
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Galadriel client
    let client = providers::galadriel::Client::new(
        &env::var("GALADRIEL_API_KEY").expect("GALADRIEL_API_KEY not set"),
        env::var("GALADRIEL_FINE_TUNE_API_KEY").ok().as_deref(),
    );
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("gpt-4o")
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_grok.rs">
use std::env;
use rig::{
    agent::AgentBuilder,
    completion::{Prompt, ToolDefinition},
    loaders::FileLoader,
    providers,
    tool::Tool,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
/// Runs 4 agents based on grok (dervived from the other examples)
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    println!("Running basic agent with grok");
    basic().await?;
    println!("\nRunning grok agent with tools");
    tools().await?;
    println!("\nRunning grok agent with loaders");
    loaders().await?;
    println!("\nRunning grok agent with context");
    context().await?;
    println!("\n\nAll agents ran successfully");
    Ok(())
}
fn client() -> providers::xai::Client {
    providers::xai::Client::new(&env::var("XAI_API_KEY").expect("XAI_API_KEY not set"))
}
/// Create a partial xAI agent (grok)
fn partial_agent() -> AgentBuilder<providers::xai::completion::CompletionModel> {
    let client = client();
    client.agent(providers::xai::GROK_BETA)
}
/// Create an xAI agent (grok) with a preamble
/// Based upon the `agent` example
///
/// This example creates a comedian agent with a preamble
async fn basic() -> Result<(), anyhow::Error> {
    let comedian_agent = partial_agent()
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
/// Create an xAI agent (grok) with tools
/// Based upon the `tools` example
///
/// This example creates a calculator agent with two tools: add and subtract
async fn tools() -> Result<(), anyhow::Error> {
    // Create agent with a single context prompt and two tools
    let calculator_agent = partial_agent()
        .preamble("You are a calculator here to help the user perform arithmetic operations. Use the tools provided to answer the user's question.")
        .max_tokens(1024)
        .tool(Adder)
        .tool(Subtract)
        .build();
    // Prompt the agent and print the response
    println!("Calculate 2 - 5");
    println!(
        "Calculator Agent: {}",
        calculator_agent.prompt("Calculate 2 - 5").await?
    );
    Ok(())
}
/// Create an xAI agent (grok) with loaders
/// Based upon the `loaders` example
///
/// This example loads in all the rust examples from the rig-core crate and uses them as\\
///  context for the agent
async fn loaders() -> Result<(), anyhow::Error> {
    let model = client().completion_model(providers::xai::GROK_BETA);
    // Load in all the rust examples
    let examples = FileLoader::with_glob("rig-core/examples/*.rs")?
        .read_with_path()
        .ignore_errors()
        .into_iter();
    // Create an agent with multiple context documents
    let agent = examples
        .fold(AgentBuilder::new(model), |builder, (path, content)| {
            builder.context(format!("Rust Example {:?}:\n{}", path, content).as_str())
        })
        .build();
    // Prompt the agent and print the response
    let response = agent
        .prompt("Which rust example is best suited for the operation 1 + 2")
        .await?;
    println!("{}", response);
    Ok(())
}
async fn context() -> Result<(), anyhow::Error> {
    let model = client().completion_model(providers::xai::GROK_BETA);
    // Create an agent with multiple context documents
    let agent = AgentBuilder::new(model)
        .context("Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")
        .context("Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .context("Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")
        .build();
    // Prompt the agent and print the response
    let response = agent.prompt("What does \"glarb-glarb\" mean?").await?;
    println!("{}", response);
    Ok(())
}
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Deserialize, Serialize)]
struct Adder;
impl Tool for Adder {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}
</file>

<file path="docs/examples/rig/agent_with_hyperbolic.rs">
use std::env;
use rig::{completion::Prompt, providers};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = providers::hyperbolic::Client::new(
        &env::var("HYPERBOLIC_API_KEY").expect("HYPERBOLIC_API_KEY not set"),
    );
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent(rig::providers::hyperbolic::DEEPSEEK_R1)
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_loaders.rs">
use std::env;
use rig::{
    agent::AgentBuilder,
    completion::Prompt,
    loaders::FileLoader,
    providers::openai::{self, GPT_4O},
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let openai_client =
        openai::Client::new(&env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"));
    let model = openai_client.completion_model(GPT_4O);
    // Load in all the rust examples
    let examples = FileLoader::with_glob("rig-core/examples/*.rs")?
        .read_with_path()
        .ignore_errors()
        .into_iter();
    // Create an agent with multiple context documents
    let agent = examples
        .fold(AgentBuilder::new(model), |builder, (path, content)| {
            builder.context(format!("Rust Example {:?}:\n{}", path, content).as_str())
        })
        .build();
    // Prompt the agent and print the response
    let response = agent
        .prompt("Which rust example is best suited for the operation 1 + 2")
        .await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_moonshot.rs">
use rig::agent::AgentBuilder;
use rig::providers::moonshot::{CompletionModel, MOONSHOT_CHAT};
use rig::{completion::Prompt, providers};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    println!("Running basic agent with moonshot");
    basic_moonshot().await?;
    println!("\nRunning moonshot agent with context");
    context_moonshot().await?;
    println!("\n\nAll agents ran successfully");
    Ok(())
}
fn client() -> providers::moonshot::Client {
    providers::moonshot::Client::from_env()
}
fn partial_agent_moonshot() -> AgentBuilder<CompletionModel> {
    let client = client();
    client.agent(MOONSHOT_CHAT)
}
async fn basic_moonshot() -> Result<(), anyhow::Error> {
    let comedian_agent = partial_agent_moonshot()
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
async fn context_moonshot() -> Result<(), anyhow::Error> {
    let model = client().completion_model(MOONSHOT_CHAT);
    // Create an agent with multiple context documents
    let agent = AgentBuilder::new(model)
        .preamble("Definition of a *glarb-glarb*: A glarb-glarb is an ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")
        .build();
    // Prompt the agent and print the response
    let response = agent.prompt("What does \"glarb-glarb\" mean?").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_ollama.rs">
/// This example requires that you have the [`ollama`](https://ollama.com) server running locally.
use rig::{completion::Prompt, providers};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create an OpenAI client with a custom base url, a local ollama endpoint
    // The API Key is unnecessary for most local endpoints
    let client = providers::openai::Client::from_url("ollama", "http://localhost:11434/v1");
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("llama3.2:latest")
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/agent_with_tools.rs">
use anyhow::Result;
use rig::{
    completion::{Prompt, ToolDefinition},
    providers,
    tool::Tool,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Deserialize, Serialize)]
struct Adder;
impl Tool for Adder {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        println!("[tool-call] Adding {} and {}", args.x, args.y);
        let result = args.x + args.y;
        Ok(result)
    }
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        println!("[tool-call] Subtracting {} from {}", args.y, args.x);
        let result = args.x - args.y;
        Ok(result)
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .init();
    // Create OpenAI client
    let openai_client = providers::openai::Client::from_env();
    // Create agent with a single context prompt and two tools
    let calculator_agent = openai_client
        .agent(providers::openai::GPT_4O)
        .preamble("You are a calculator here to help the user perform arithmetic operations. Use the tools provided to answer the user's question.")
        .max_tokens(1024)
        .tool(Adder)
        .tool(Subtract)
        .build();
    // Prompt the agent and print the response
    println!("Calculate 2 - 5");
    println!(
        "OpenAI Calculator Agent: {}",
        calculator_agent.prompt("Calculate 2 - 5").await?
    );
    Ok(())
}
</file>

<file path="docs/examples/rig/agent.rs">
use std::env;
use rig::{completion::Prompt, providers};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = providers::openai::Client::new(
        &env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"),
    );
    // Create agent with a single context prompt
    let comedian_agent = client
        .agent("gpt-4o")
        .preamble("You are a comedian here to entertain the user using humour and jokes.")
        .build();
    // Prompt the agent and print the response
    let response = comedian_agent.prompt("Entertain me!").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/anthropic_agent.rs">
use std::env;
use rig::{
    completion::Prompt,
    providers::anthropic::{self, CLAUDE_3_5_SONNET},
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Anthropic client
    let client = anthropic::ClientBuilder::new(
        &env::var("ANTHROPIC_API_KEY").expect("ANTHROPIC_API_KEY not set"),
    )
    .build();
    // Create agent with a single context prompt
    let agent = client
        .agent(CLAUDE_3_5_SONNET)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .build();
    // Prompt the agent and print the response
    let response = agent
        .prompt("When and where and what type is the next solar eclipse?")
        .await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/anthropic_streaming_with_tools.rs">
use anyhow::Result;
use rig::streaming::stream_to_stdout;
use rig::{completion::ToolDefinition, providers, streaming::StreamingPrompt, tool::Tool};
use serde::{Deserialize, Serialize};
use serde_json::json;
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Deserialize, Serialize)]
struct Adder;
impl Tool for Adder {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        ToolDefinition {
            name: "add".to_string(),
            description: "Add x and y together".to_string(),
            parameters: json!({
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                },
                "required": ["x", "y"]
            }),
        }
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                },
                "required": ["x", "y"]
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    tracing_subscriber::fmt().init();
    // Create agent with a single context prompt and two tools
    let calculator_agent = providers::anthropic::Client::from_env()
        .agent(providers::anthropic::CLAUDE_3_5_SONNET)
        .preamble(
            "You are a calculator here to help the user perform arithmetic 
            operations. Use the tools provided to answer the user's question. 
            make your answer long, so we can test the streaming functionality, 
            like 20 words",
        )
        .max_tokens(1024)
        .tool(Adder)
        .tool(Subtract)
        .build();
    println!("Calculate 2 - 5");
    let mut stream = calculator_agent.stream_prompt("Calculate 2 - 5").await?;
    stream_to_stdout(calculator_agent, &mut stream).await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/anthropic_streaming.rs">
use rig::{
    providers::anthropic::{self, CLAUDE_3_5_SONNET},
    streaming::{stream_to_stdout, StreamingPrompt},
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create streaming agent with a single context prompt
    let agent = anthropic::Client::from_env()
        .agent(CLAUDE_3_5_SONNET)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .build();
    // Stream the response and print chunks as they arrive
    let mut stream = agent
        .stream_prompt("When and where and what type is the next solar eclipse?")
        .await?;
    stream_to_stdout(agent, &mut stream).await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/calculator_chatbot.rs">
use anyhow::Result;
use rig::{
    cli_chatbot::cli_chatbot,
    completion::ToolDefinition,
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    tool::{Tool, ToolEmbedding, ToolSet},
    vector_store::in_memory_store::InMemoryVectorStore,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::env;
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Debug, thiserror::Error)]
#[error("Init error")]
struct InitError;
#[derive(Deserialize, Serialize)]
struct Add;
impl Tool for Add {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "add",
            "description": "Add x and y together",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Add {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Add)
    }
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Add x and y together".into()]
    }
    fn context(&self) -> Self::Context {}
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Subtract {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Subtract)
    }
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Subtract y from x (i.e.: x - y)".into()]
    }
    fn context(&self) -> Self::Context {}
}
struct Multiply;
impl Tool for Multiply {
    const NAME: &'static str = "multiply";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "multiply",
            "description": "Compute the product of x and y (i.e.: x * y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first factor in the product"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second factor in the product"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x * args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Multiply {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Multiply)
    }
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Compute the product of x and y (i.e.: x * y)".into()]
    }
    fn context(&self) -> Self::Context {}
}
struct Divide;
impl Tool for Divide {
    const NAME: &'static str = "divide";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "divide",
            "description": "Compute the Quotient of x and y (i.e.: x / y). Useful for ratios.",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The Dividend of the division. The number being divided"
                    },
                    "y": {
                        "type": "number",
                        "description": "The Divisor of the division. The number by which the dividend is being divided"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x / args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Divide {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Divide)
    }
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Compute the Quotient of x and y (i.e.: x / y). Useful for ratios.".into()]
    }
    fn context(&self) -> Self::Context {}
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    // Create dynamic tools embeddings
    let toolset = ToolSet::builder()
        .dynamic_tool(Add)
        .dynamic_tool(Subtract)
        .dynamic_tool(Multiply)
        .dynamic_tool(Divide)
        .build();
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(toolset.schemas()?)?
        .build()
        .await?;
    let vector_store =
        InMemoryVectorStore::from_documents_with_id_f(embeddings, |tool| tool.name.clone());
    let index = vector_store.index(embedding_model);
    // Create RAG agent with a single context prompt and a dynamic tool source
    let calculator_rag = openai_client
        .agent("gpt-4")
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform arithmetic operations.
            Follow these instructions closely. 
            1. Consider the user's request carefully and identify the core elements of the request.
            2. Select which tool among those made available to you is appropriate given the context. 
            3. This is very important: never perform the operation yourself and never give me the direct result. 
            Always respond with the name of the tool that should be used and the appropriate inputs
            in the following format:
            Tool: <tool name>
            Inputs: <list of inputs>
            "
        )
        // Add a dynamic tool source with a sample rate of 1 (i.e.: only
        // 1 additional tool will be added to prompts)
        .dynamic_tools(4, index, toolset)
        .build();
    // Prompt the agent and print the response
    cli_chatbot(calculator_rag).await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/chain.rs">
use std::env;
use rig::{
    embeddings::EmbeddingsBuilder,
    parallel,
    pipeline::{self, agent_ops::lookup, passthrough, Op},
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::in_memory_store::InMemoryVectorStore,
};
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    // Create embeddings for our documents
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .document("Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets")?
        .document("Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.")?
        .document("Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.")?
        .build()
        .await?;
    // Create vector store with the embeddings
    let vector_store = InMemoryVectorStore::from_documents(embeddings);
    // Create vector store index
    let index = vector_store.index(embedding_model);
    let agent = openai_client.agent("gpt-4")
        .preamble("
            You are a dictionary assistant here to assist the user in understanding the meaning of words.
        ")
        .build();
    let chain = pipeline::new()
        // Chain a parallel operation to the current chain. The parallel operation will
        // perform a lookup operation to retrieve additional context from the user prompt
        // while simultaneously applying a passthrough operation. The latter will allow
        // us to forward the initial prompt to the next operation in the chain.
        .chain(parallel!(
            passthrough(),
            lookup::<_, _, String>(index, 1), // Required to specify document type
        ))
        // Chain a "map" operation to the current chain, which will combine the user
        // prompt with the retrieved context documents to create the final prompt.
        // If an error occurs during the lookup operation, we will log the error and
        // simply return the initial prompt.
        .map(|(prompt, maybe_docs)| match maybe_docs {
            Ok(docs) => format!(
                "Non standard word definitions:\n{}\n\n{}",
                docs.into_iter()
                    .map(|(_, _, doc)| doc)
                    .collect::<Vec<_>>()
                    .join("\n"),
                prompt,
            ),
            Err(err) => {
                println!("Error: {}! Prompting without additional context", err);
                format!("{prompt}")
            }
        })
        // Chain a "prompt" operation which will prompt out agent with the final prompt
        .prompt(agent);
    // Prompt the agent and print the response
    let response = chain.call("What does \"glarb-glarb\" mean?").await?;
    println!("{:?}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/cohere_connector.rs">
use std::env;
use rig::{
    completion::{Completion, Prompt},
    providers::cohere::Client as CohereClient,
};
use serde_json::json;
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Cohere client
    let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    let cohere_client = CohereClient::new(&cohere_api_key);
    let klimadao_agent = cohere_client
        .agent("command-r")
        .temperature(0.0)
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.klimadao.finance"}}]
        }))
        .build();
    // Prompt the model and print the response
    // We use `prompt` to get a simple response from the model as a String
    let response = klimadao_agent.prompt("Tell me about BCT tokens?").await?;
    println!("\n\nCoral: {:?}", response);
    // Prompt the model and get the citations
    // We use `completion` to allow use to customize the request further and
    // get a more detailed response from the model.
    // Here the response is of type CompletionResponse<cohere::CompletionResponse>
    // which contains `choice` (Message or ToolCall) as well as `raw_response`,
    // the underlying providers' raw response.
    let response = klimadao_agent
        .completion("Tell me about BCT tokens?", vec![])
        .await?
        .additional_params(json!({
            "connectors": [{"id":"web-search", "options":{"site": "https://docs.klimadao.finance"}}]
        }))
        .send()
        .await?;
    println!(
        "\n\nCoral: {:?}\n\nCitations:\n{:?}",
        response.choice, response.raw_response.citations
    );
    Ok(())
}
</file>

<file path="docs/examples/rig/debate.rs">
use std::env;
use anyhow::Result;
use rig::{
    agent::Agent,
    completion::Chat,
    message::Message,
    providers::{cohere, openai},
};
struct Debater {
    gpt_4: Agent<openai::CompletionModel>,
    coral: Agent<cohere::CompletionModel>,
}
impl Debater {
    fn new(position_a: &str, position_b: &str) -> Self {
        let openai_client =
            openai::Client::new(&env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set"));
        let cohere_client =
            cohere::Client::new(&env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set"));
        Self {
            gpt_4: openai_client.agent("gpt-4").preamble(position_a).build(),
            coral: cohere_client
                .agent("command-r")
                .preamble(position_b)
                .build(),
        }
    }
    async fn rounds(&self, n: usize) -> Result<()> {
        let mut history_a: Vec<Message> = vec![];
        let mut history_b: Vec<Message> = vec![];
        let mut last_resp_b: Option<String> = None;
        for _ in 0..n {
            let prompt_a = if let Some(msg_b) = &last_resp_b {
                msg_b.clone()
            } else {
                "Plead your case!".into()
            };
            let resp_a = self
                .gpt_4
                .chat(prompt_a.as_str(), history_a.clone())
                .await?;
            println!("GPT-4:\n{}", resp_a);
            history_a.push(Message::user(prompt_a));
            history_a.push(Message::assistant(resp_a.clone()));
            println!("================================================================");
            let resp_b = self.coral.chat(resp_a.as_str(), history_b.clone()).await?;
            println!("Coral:\n{}", resp_b);
            println!("================================================================");
            history_b.push(Message::user(resp_a));
            history_b.push(Message::assistant(resp_b.clone()));
            last_resp_b = Some(resp_b)
        }
        Ok(())
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create model
    let debator = Debater::new(
        "\
        You believe that religion is a useful concept. \
        This could be for security, financial, ethical, philosophical, metaphysical, religious or any kind of other reason. \
        You choose what your arguments are. \
        I will argue against you and you must rebuke me and try to convince me that I am wrong. \
        Make your statements short and concise. \
        ",
        "\
        You believe that religion is a harmful concept. \
        This could be for security, financial, ethical, philosophical, metaphysical, religious or any kind of other reason. \
        You choose what your arguments are. \
        I will argue against you and you must rebuke me and try to convince me that I am wrong. \
        Make your statements short and concise. \
        ",
    );
    // Run the debate for 4 rounds
    debator.rounds(4).await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/extractor_with_deepseek.rs">
use rig::providers::deepseek;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record representing a person
struct Person {
    /// The person's first name, if provided (null otherwise)
    pub first_name: Option<String>,
    /// The person's last name, if provided (null otherwise)
    pub last_name: Option<String>,
    /// The person's job, if provided (null otherwise)
    pub job: Option<String>,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create DeepSeek client
    let deepseek_client = deepseek::Client::from_env();
    // Create extractor
    let data_extractor = deepseek_client
        .extractor::<Person>(deepseek::DEEPSEEK_CHAT)
        .build();
    let person = data_extractor
        .extract("Hello my name is John Doe! I am a software engineer.")
        .await?;
    println!(
        "DeepSeek: {}",
        serde_json::to_string_pretty(&person).unwrap()
    );
    Ok(())
}
</file>

<file path="docs/examples/rig/extractor.rs">
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record representing a person
struct Person {
    /// The person's first name, if provided (null otherwise)
    pub first_name: Option<String>,
    /// The person's last name, if provided (null otherwise)
    pub last_name: Option<String>,
    /// The person's job, if provided (null otherwise)
    pub job: Option<String>,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_client = openai::Client::from_env();
    // Create extractor
    let data_extractor = openai_client.extractor::<Person>("gpt-4").build();
    let person = data_extractor
        .extract("Hello my name is John Doe! I am a software engineer.")
        .await?;
    println!("GPT-4: {}", serde_json::to_string_pretty(&person).unwrap());
    Ok(())
}
</file>

<file path="docs/examples/rig/gemini_agent.rs">
use rig::{
    completion::Prompt,
    providers::gemini::{self, completion::gemini_api_types::GenerationConfig},
};
#[tracing::instrument(ret)]
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .init();
    // Initialize the Google Gemini client
    let client = gemini::Client::from_env();
    // Create agent with a single context prompt
    let agent = client
        .agent(gemini::completion::GEMINI_1_5_PRO)
        .preamble("Be creative and concise. Answer directly and clearly.")
        .temperature(0.5)
        // The `GenerationConfig` utility struct helps construct a typesafe `additional_params`
        .additional_params(serde_json::to_value(GenerationConfig {
            top_k: Some(1),
            top_p: Some(0.95),
            candidate_count: Some(1),
            ..Default::default()
        })?) // Unwrap the Result to get the Value
        .build();
    tracing::info!("Prompting the agent...");
    // Prompt the agent and print the response
    let response = agent
        .prompt("How much wood would a woodchuck chuck if a woodchuck could chuck wood? Infer an answer.")
        .await;
    tracing::info!("Response: {:?}", response);
    match response {
        Ok(response) => println!("{}", response),
        Err(e) => {
            tracing::error!("Error: {:?}", e);
            return Err(e.into());
        }
    }
    Ok(())
}
</file>

<file path="docs/examples/rig/gemini_embeddings.rs">
use rig::providers::gemini;
use rig::Embed;
#[derive(Embed, Debug)]
struct Greetings {
    #[embed]
    message: String,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Initialize the Google Gemini client
    // Create OpenAI client
    let client = gemini::Client::from_env();
    let embeddings = client
        .embeddings(gemini::embedding::EMBEDDING_001)
        .document(Greetings {
            message: "Hello, world!".to_string(),
        })?
        .document(Greetings {
            message: "Goodbye, world!".to_string(),
        })?
        .build()
        .await
        .expect("Failed to embed documents");
    println!("{:?}", embeddings);
    Ok(())
}
</file>

<file path="docs/examples/rig/image.rs">
use reqwest::Client;
use rig::{
    completion::{message::Image, Prompt},
    message::{ContentFormat, ImageMediaType},
    providers::anthropic::{self, CLAUDE_3_5_SONNET},
};
use base64::{prelude::BASE64_STANDARD, Engine};
const IMAGE_URL: &str =
    "https://upload.wikimedia.org/wikipedia/commons/a/a7/Camponotus_flavomarginatus_ant.jpg";
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Tracing
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .init();
    // Create Anthropic client
    let client = anthropic::Client::from_env();
    // Create agent with a single context prompt
    let agent = client
        .agent(CLAUDE_3_5_SONNET)
        .preamble("You are an image describer.")
        .temperature(0.5)
        .build();
    // Grab image and convert to base64
    let reqwest_client = Client::new();
    let image_bytes = reqwest_client.get(IMAGE_URL).send().await?.bytes().await?;
    let image_base64 = BASE64_STANDARD.encode(image_bytes);
    // Compose `Image` for prompt
    let image = Image {
        data: image_base64,
        media_type: Some(ImageMediaType::JPEG),
        format: Some(ContentFormat::Base64),
        ..Default::default()
    };
    // Prompt the agent and print the response
    let response = agent.prompt(image).await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/loaders.rs">
use rig::loaders::FileLoader;
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    FileLoader::with_glob("cargo.toml")?
        .read()
        .into_iter()
        .for_each(|result| match result {
            Ok(content) => println!("{}", content),
            Err(e) => eprintln!("Error reading file: {}", e),
        });
    Ok(())
}
</file>

<file path="docs/examples/rig/multi_agent.rs">
use std::env;
use rig::{
    agent::{Agent, AgentBuilder},
    cli_chatbot::cli_chatbot,
    completion::{Chat, CompletionModel, PromptError},
    message::Message,
    providers::openai::Client as OpenAIClient,
};
/// Represents a multi agent application that consists of two components:
/// an agent specialized in translating prompt into english and a simple GPT-4 model.
/// When prompted, the application will use the translator agent to translate the
/// prompt in english, before answering it with GPT-4. The answer in english is returned.
struct EnglishTranslator<M: CompletionModel> {
    translator_agent: Agent<M>,
    gpt4: Agent<M>,
}
impl<M: CompletionModel> EnglishTranslator<M> {
    fn new(model: M) -> Self {
        Self {
            // Create the translator agent
            translator_agent: AgentBuilder::new(model.clone())
                .preamble("\
                    You are a translator assistant that will translate any input text into english. \
                    If the text is already in english, simply respond with the original text but fix any mistakes (grammar, syntax, etc.). \
                ")
                .build(),
            // Create the GPT4 model
            gpt4: AgentBuilder::new(model).build()
        }
    }
}
impl<M: CompletionModel> Chat for EnglishTranslator<M> {
    async fn chat(
        &self,
        prompt: impl Into<Message> + Send,
        chat_history: Vec<Message>,
    ) -> Result<String, PromptError> {
        // Translate the prompt using the translator agent
        let translated_prompt = self
            .translator_agent
            .chat(prompt, chat_history.clone())
            .await?;
        println!("Translated prompt: {}", translated_prompt);
        // Answer the prompt using gpt4
        self.gpt4
            .chat(translated_prompt.as_str(), chat_history)
            .await
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = OpenAIClient::new(&openai_api_key);
    let model = openai_client.completion_model("gpt-4");
    // Create OpenAI client
    // let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    // let cohere_client = CohereClient::new(&cohere_api_key);
    // let model = cohere_client.completion_model("command-r");
    // Create model
    let translator = EnglishTranslator::new(model);
    // Spin up a chatbot using the agent
    cli_chatbot(translator).await?;
    Ok(())
}
</file>

<file path="docs/examples/rig/multi_extract.rs">
use rig::{
    pipeline::{self, agent_ops, TryOp},
    providers::openai,
    try_parallel,
};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record containing extracted names
pub struct Names {
    /// The names extracted from the text
    pub names: Vec<String>,
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record containing extracted topics
pub struct Topics {
    /// The topics extracted from the text
    pub topics: Vec<String>,
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// A record containing extracted sentiment
pub struct Sentiment {
    /// The sentiment of the text (-1 being negative, 1 being positive)
    pub sentiment: f64,
    /// The confidence of the sentiment
    pub confidence: f64,
}
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let openai = openai::Client::from_env();
    let names_extractor = openai
        .extractor::<Names>("gpt-4")
        .preamble("Extract names (e.g.: of people, places) from the given text.")
        .build();
    let topics_extractor = openai
        .extractor::<Topics>("gpt-4")
        .preamble("Extract topics from the given text.")
        .build();
    let sentiment_extractor = openai
        .extractor::<Sentiment>("gpt-4")
        .preamble(
            "Extract sentiment (and how confident you are of the sentiment) from the given text.",
        )
        .build();
    // Create a chain that extracts names, topics, and sentiment from a given text
    // using three different GPT-4 based extractors.
    // The chain will output a formatted string containing the extracted information.
    let chain = pipeline::new()
        .chain(try_parallel!(
            agent_ops::extract(names_extractor),
            agent_ops::extract(topics_extractor),
            agent_ops::extract(sentiment_extractor),
        ))
        .map_ok(|(names, topics, sentiment)| {
            format!(
                "Extracted names: {names}\nExtracted topics: {topics}\nExtracted sentiment: {sentiment}",
                names = names.names.join(", "),
                topics = topics.topics.join(", "),
                sentiment = sentiment.sentiment,
            )
        });
    // Batch call the chain with up to 4 inputs concurrently
    let response = chain
        .try_batch_call(
            4,
            vec![
                "Screw you Putin!",
                "I love my dog, but I hate my cat.",
                "I'm going to the store to buy some milk.",
            ],
        )
        .await?;
    for response in response {
        println!("Text analysis:\n{response}");
    }
    Ok(())
}
</file>

<file path="docs/examples/rig/multi_turn_agent.rs">
use rig::{
    agent::Agent,
    completion::{self, Completion, PromptError, ToolDefinition},
    message::{AssistantContent, Message, ToolCall, ToolFunction, ToolResultContent, UserContent},
    providers::anthropic,
    tool::Tool,
    OneOrMany,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
struct MultiTurnAgent<M: rig::completion::CompletionModel> {
    agent: Agent<M>,
    chat_history: Vec<completion::Message>,
}
impl<M: rig::completion::CompletionModel> MultiTurnAgent<M> {
    async fn multi_turn_prompt(
        &mut self,
        prompt: impl Into<Message> + Send,
    ) -> Result<String, PromptError> {
        let mut current_prompt: Message = prompt.into();
        loop {
            println!("Current Prompt: {:?}\n", current_prompt);
            let resp = self
                .agent
                .completion(current_prompt.clone(), self.chat_history.clone())
                .await?
                .send()
                .await?;
            let mut final_text = None;
            for content in resp.choice.into_iter() {
                match content {
                    AssistantContent::Text(text) => {
                        println!("Intermediate Response: {:?}\n", text.text);
                        final_text = Some(text.text.clone());
                        self.chat_history.push(current_prompt.clone());
                        let response_message = Message::Assistant {
                            content: OneOrMany::one(AssistantContent::text(&text.text)),
                        };
                        self.chat_history.push(response_message);
                    }
                    AssistantContent::ToolCall(content) => {
                        self.chat_history.push(current_prompt.clone());
                        let tool_call_msg = AssistantContent::ToolCall(content.clone());
                        println!("Tool Call Msg: {:?}\n", tool_call_msg);
                        self.chat_history.push(Message::Assistant {
                            content: OneOrMany::one(tool_call_msg),
                        });
                        let ToolCall {
                            id,
                            function: ToolFunction { name, arguments },
                        } = content;
                        let tool_result =
                            self.agent.tools.call(&name, arguments.to_string()).await?;
                        current_prompt = Message::User {
                            content: OneOrMany::one(UserContent::tool_result(
                                id,
                                OneOrMany::one(ToolResultContent::text(tool_result)),
                            )),
                        };
                        final_text = None;
                        break;
                    }
                }
            }
            if let Some(text) = final_text {
                return Ok(text);
            }
        }
    }
}
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // tracing_subscriber::registry()
    //     .with(
    //         tracing_subscriber::EnvFilter::try_from_default_env()
    //             .unwrap_or_else(|_| "stdout=info".into()),
    //     )
    //     .with(tracing_subscriber::fmt::layer())
    //     .init();
    // Create OpenAI client
    let openai_client = anthropic::Client::from_env();
    // Create RAG agent with a single context prompt and a dynamic tool source
    let calculator_rag = openai_client
        .agent(anthropic::CLAUDE_3_5_SONNET)
        .preamble(
            "You are an assistant here to help the user select which tool is most appropriate to perform arithmetic operations.
            Follow these instructions closely. 
            1. Consider the user's request carefully and identify the core elements of the request.
            2. Select which tool among those made available to you is appropriate given the context. 
            3. This is very important: never perform the operation yourself. 
            "
        )
        .tool(Add)
        .tool(Subtract)
        .tool(Multiply)
        .tool(Divide)
        .build();
    let mut agent = MultiTurnAgent {
        agent: calculator_rag,
        chat_history: Vec::new(),
    };
    // Prompt the agent and print the response
    let result = agent
        .multi_turn_prompt("Calculate 5 - 2 = ?. Describe the result to me.")
        .await?;
    println!("\n\nOpenAI Calculator Agent: {}", result);
    // Prompt the agent again and print the response
    let result = agent
        .multi_turn_prompt("Calculate (3 + 5) / 9  = ?. Describe the result to me.")
        .await?;
    println!("\n\nOpenAI Calculator Agent: {}", result);
    Ok(())
}
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Deserialize, Serialize)]
struct Add;
impl Tool for Add {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "add",
            "description": "Add x and y together",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to substract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to substract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}
struct Multiply;
impl Tool for Multiply {
    const NAME: &'static str = "multiply";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "multiply",
            "description": "Compute the product of x and y (i.e.: x * y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first factor in the product"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second factor in the product"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x * args.y;
        Ok(result)
    }
}
struct Divide;
impl Tool for Divide {
    const NAME: &'static str = "divide";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "divide",
            "description": "Compute the Quotient of x and y (i.e.: x / y). Useful for ratios.",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The Dividend of the division. The number being divided"
                    },
                    "y": {
                        "type": "number",
                        "description": "The Divisor of the division. The number by which the dividend is being divided"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x / args.y;
        Ok(result)
    }
}
</file>

<file path="docs/examples/rig/perplexity_agent.rs">
use std::env;
use rig::{
    completion::Prompt,
    providers::{self, perplexity::SONAR},
};
use serde_json::json;
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let client = providers::perplexity::Client::new(
        &env::var("PERPLEXITY_API_KEY").expect("PERPLEXITY_API_KEY not set"),
    );
    // Create agent with a single context prompt
    let agent = client
        .agent(SONAR)
        .preamble("Be precise and concise.")
        .temperature(0.5)
        .additional_params(json!({
            "return_related_questions": true,
            "return_images": true
        }))
        .build();
    // Prompt the agent and print the response
    let response = agent
        .prompt("When and where and what type is the next solar eclipse?")
        .await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/rag_dynamic_tools.rs">
use anyhow::Result;
use rig::{
    completion::{Prompt, ToolDefinition},
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    tool::{Tool, ToolEmbedding, ToolSet},
    vector_store::in_memory_store::InMemoryVectorStore,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::env;
#[derive(Deserialize)]
struct OperationArgs {
    x: i32,
    y: i32,
}
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct MathError;
#[derive(Debug, thiserror::Error)]
#[error("Math error")]
struct InitError;
#[derive(Deserialize, Serialize)]
struct Add;
impl Tool for Add {
    const NAME: &'static str = "add";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "add",
            "description": "Add x and y together",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The first number to add"
                    },
                    "y": {
                        "type": "number",
                        "description": "The second number to add"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x + args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Add {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Add)
    }
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Add x and y together".into()]
    }
    fn context(&self) -> Self::Context {}
}
#[derive(Deserialize, Serialize)]
struct Subtract;
impl Tool for Subtract {
    const NAME: &'static str = "subtract";
    type Error = MathError;
    type Args = OperationArgs;
    type Output = i32;
    async fn definition(&self, _prompt: String) -> ToolDefinition {
        serde_json::from_value(json!({
            "name": "subtract",
            "description": "Subtract y from x (i.e.: x - y)",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {
                        "type": "number",
                        "description": "The number to subtract from"
                    },
                    "y": {
                        "type": "number",
                        "description": "The number to subtract"
                    }
                }
            }
        }))
        .expect("Tool Definition")
    }
    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let result = args.x - args.y;
        Ok(result)
    }
}
impl ToolEmbedding for Subtract {
    type InitError = InitError;
    type Context = ();
    type State = ();
    fn init(_state: Self::State, _context: Self::Context) -> Result<Self, Self::InitError> {
        Ok(Subtract)
    }
    fn context(&self) -> Self::Context {}
    fn embedding_docs(&self) -> Vec<String> {
        vec!["Subtract y from x (i.e.: x - y)".into()]
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // required to enable CloudWatch error logging by the runtime
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        // disable printing the name of the module in every log line.
        .with_target(false)
        .init();
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    let toolset = ToolSet::builder()
        .dynamic_tool(Add)
        .dynamic_tool(Subtract)
        .build();
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(toolset.schemas()?)?
        .build()
        .await?;
    // Create vector store with the embeddings
    let vector_store =
        InMemoryVectorStore::from_documents_with_id_f(embeddings, |tool| tool.name.clone());
    // Create vector store index
    let index = vector_store.index(embedding_model);
    // Create RAG agent with a single context prompt and a dynamic tool source
    let calculator_rag = openai_client
        .agent("gpt-4")
        .preamble("You are a calculator here to help the user perform arithmetic operations.")
        // Add a dynamic tool source with a sample rate of 1 (i.e.: only
        // 1 additional tool will be added to prompts)
        .dynamic_tools(1, index, toolset)
        .build();
    // Prompt the agent and print the response
    let response = calculator_rag.prompt("Calculate 3 - 7").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/rag.rs">
use std::{env, vec};
use rig::{
    completion::Prompt,
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::in_memory_store::InMemoryVectorStore,
    Embed,
};
use serde::Serialize;
// Data to be RAGged.
// A vector search needs to be performed on the `definitions` field, so we derive the `Embed` trait for `WordDefinition`
// and tag that field with `#[embed]`.
#[derive(Embed, Serialize, Clone, Debug, Eq, PartialEq, Default)]
struct WordDefinition {
    id: String,
    word: String,
    #[embed]
    definitions: Vec<String>,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .init();
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    // Generate embeddings for the definitions of all the documents using the specified embedding model.
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(vec![
            WordDefinition {
                id: "doc0".to_string(),
                word: "flurbo".to_string(),
                definitions: vec![
                    "1. *flurbo* (name): A flurbo is a green alien that lives on cold planets.".to_string(),
                    "2. *flurbo* (name): A fictional digital currency that originated in the animated series Rick and Morty.".to_string()
                ]
            },
            WordDefinition {
                id: "doc1".to_string(),
                word: "glarb-glarb".to_string(),
                definitions: vec![
                    "1. *glarb-glarb* (noun): A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.".to_string(),
                    "2. *glarb-glarb* (noun): A fictional creature found in the distant, swampy marshlands of the planet Glibbo in the Andromeda galaxy.".to_string()
                ]
            },
            WordDefinition {
                id: "doc2".to_string(),
                word: "linglingdong".to_string(),
                definitions: vec![
                    "1. *linglingdong* (noun): A term used by inhabitants of the far side of the moon to describe humans.".to_string(),
                    "2. *linglingdong* (noun): A rare, mystical instrument crafted by the ancient monks of the Nebulon Mountain Ranges on the planet Quarm.".to_string()
                ]
            },
        ])?
        .build()
        .await?;
    // Create vector store with the embeddings
    let vector_store = InMemoryVectorStore::from_documents(embeddings);
    // Create vector store index
    let index = vector_store.index(embedding_model);
    let rag_agent = openai_client.agent("gpt-4")
        .preamble("
            You are a dictionary assistant here to assist the user in understanding the meaning of words.
            You will find additional non-standard word definitions that could be useful below.
        ")
        .dynamic_context(1, index)
        .build();
    // Prompt the agent and print the response
    let response = rag_agent.prompt("What does \"glarb-glarb\" mean?").await?;
    println!("{}", response);
    Ok(())
}
</file>

<file path="docs/examples/rig/sentiment_classifier.rs">
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
/// An enum representing the sentiment of a document
enum Sentiment {
    Positive,
    Negative,
    Neutral,
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct DocumentSentiment {
    /// The sentiment of the document
    sentiment: Sentiment,
}
#[tokio::main]
async fn main() {
    // Create OpenAI client
    let openai_client = openai::Client::from_env();
    // Create extractor
    let data_extractor = openai_client
        .extractor::<DocumentSentiment>("gpt-4")
        .build();
    let sentiment = data_extractor
        .extract("I am happy")
        .await
        .expect("Failed to extract sentiment");
    println!("GPT-4: {:?}", sentiment);
}
</file>

<file path="docs/examples/rig/simple_model.rs">
use rig::{completion::Prompt, providers::openai};
#[tokio::main]
async fn main() {
    // Create OpenAI client and model
    let openai_client = openai::Client::from_env();
    let gpt4 = openai_client.agent("gpt-4").build();
    // Prompt the model and print its response
    let response = gpt4
        .prompt("Who are you?")
        .await
        .expect("Failed to prompt GPT-4");
    println!("GPT-4: {response}");
}
</file>

<file path="docs/examples/rig/vector_search_cohere.rs">
use std::env;
use rig::{
    embeddings::EmbeddingsBuilder,
    providers::cohere::{Client, EMBED_ENGLISH_V3},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStoreIndex},
    Embed,
};
use serde::{Deserialize, Serialize};
// Shape of data that needs to be RAG'ed.
// The definition field will be used to generate embeddings.
#[derive(Embed, Clone, Deserialize, Debug, Serialize, Eq, PartialEq, Default)]
struct WordDefinition {
    id: String,
    word: String,
    #[embed]
    definitions: Vec<String>,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create Cohere client
    let cohere_api_key = env::var("COHERE_API_KEY").expect("COHERE_API_KEY not set");
    let cohere_client = Client::new(&cohere_api_key);
    let document_model = cohere_client.embedding_model(EMBED_ENGLISH_V3, "search_document");
    let search_model = cohere_client.embedding_model(EMBED_ENGLISH_V3, "search_query");
    let embeddings = EmbeddingsBuilder::new(document_model.clone())
        .documents(vec![
            WordDefinition {
                id: "doc0".to_string(),
                word: "flurbo".to_string(),
                definitions: vec![
                    "A green alien that lives on cold planets.".to_string(),
                    "A fictional digital currency that originated in the animated series Rick and Morty.".to_string()
                ]
            },
            WordDefinition {
                id: "doc1".to_string(),
                word: "glarb-glarb".to_string(),
                definitions: vec![
                    "An ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.".to_string(),
                    "A fictional creature found in the distant, swampy marshlands of the planet Glibbo in the Andromeda galaxy.".to_string()
                ]
            },
            WordDefinition {
                id: "doc2".to_string(),
                word: "linglingdong".to_string(),
                definitions: vec![
                    "A term used by inhabitants of the sombrero galaxy to describe humans.".to_string(),
                    "A rare, mystical instrument crafted by the ancient monks of the Nebulon Mountain Ranges on the planet Quarm.".to_string()
                ]
            },
        ])?
        .build()
        .await?;
    // Create vector store with the embeddings
    let vector_store =
        InMemoryVectorStore::from_documents_with_id_f(embeddings, |doc| doc.id.clone());
    // Create vector store index
    let index = vector_store.index(search_model);
    let results = index
        .top_n::<WordDefinition>(
            "Which instrument is found in the Nebulon Mountain Ranges?",
            1,
        )
        .await?
        .into_iter()
        .map(|(score, id, doc)| (score, id, doc.word))
        .collect::<Vec<_>>();
    println!("Results: {:?}", results);
    Ok(())
}
</file>

<file path="docs/examples/rig/vector_search_mongodb.rs">
use mongodb::{
    bson::{self, doc},
    options::ClientOptions,
    Client as MongoClient, Collection,
};
use rig::providers::openai::TEXT_EMBEDDING_ADA_002;
use serde::{Deserialize, Deserializer};
use serde_json::Value;
use std::env;
use rig::{
    embeddings::EmbeddingsBuilder, providers::openai::Client, vector_store::VectorStoreIndex, Embed,
};
use rig_mongodb::{MongoDbVectorIndex, SearchParams};
// Shape of data that needs to be RAG'ed.
// The definition field will be used to generate embeddings.
#[derive(Embed, Clone, Deserialize, Debug)]
struct Word {
    #[serde(rename = "_id", deserialize_with = "deserialize_object_id")]
    id: String,
    #[embed]
    definition: String,
}
fn deserialize_object_id<'de, D>(deserializer: D) -> Result<String, D::Error>
where
    D: Deserializer<'de>,
{
    let value = Value::deserialize(deserializer)?;
    match value {
        Value::String(s) => Ok(s),
        Value::Object(map) => {
            if let Some(Value::String(oid)) = map.get("$oid") {
                Ok(oid.to_string())
            } else {
                Err(serde::de::Error::custom(
                    "Expected $oid field with string value",
                ))
            }
        }
        _ => Err(serde::de::Error::custom(
            "Expected string or object with $oid field",
        )),
    }
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Initialize OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    // Initialize MongoDB client
    let mongodb_connection_string =
        env::var("MONGODB_CONNECTION_STRING").expect("MONGODB_CONNECTION_STRING not set");
    let options = ClientOptions::parse(mongodb_connection_string)
        .await
        .expect("MongoDB connection string should be valid");
    let mongodb_client =
        MongoClient::with_options(options).expect("MongoDB client options should be valid");
    // Initialize MongoDB vector store
    let collection: Collection<bson::Document> = mongodb_client
        .database("knowledgebase")
        .collection("context");
    // Select the embedding model and generate our embeddings
    let model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    let words = vec![
        Word {
            id: "doc0".to_string(),
            definition: "Definition of a *flurbo*: A flurbo is a green alien that lives on cold planets".to_string(),
        },
        Word {
            id: "doc1".to_string(),
            definition: "Definition of a *glarb-glarb*: A glarb-glarb is a ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.".to_string(),
        },
        Word {
            id: "doc2".to_string(),
            definition: "Definition of a *linglingdong*: A term used by inhabitants of the far side of the moon to describe humans.".to_string(),
        }
    ];
    let embeddings = EmbeddingsBuilder::new(model.clone())
        .documents(words)?
        .build()
        .await?;
    let mongo_documents = embeddings
        .iter()
        .map(|(Word { id, definition, .. }, embedding)| {
            doc! {
                "id": id.clone(),
                "definition": definition.clone(),
                "embedding": embedding.first().vec.clone(),
            }
        })
        .collect::<Vec<_>>();
    match collection.insert_many(mongo_documents).await {
        Ok(_) => println!("Documents added successfully"),
        Err(e) => println!("Error adding documents: {:?}", e),
    };
    // Create a vector index on our vector store.
    // Note: a vector index called "vector_index" must exist on the MongoDB collection you are querying.
    // IMPORTANT: Reuse the same model that was used to generate the embeddings
    let index =
        MongoDbVectorIndex::new(collection, model, "vector_index", SearchParams::new()).await?;
    // Query the index
    let results = index.top_n::<Word>("What is a linglingdong?", 1).await?;
    println!("Results: {:?}", results);
    let id_results = index
        .top_n_ids("What is a linglingdong?", 1)
        .await?
        .into_iter()
        .collect::<Vec<_>>();
    println!("ID results: {:?}", id_results);
    Ok(())
}
</file>

<file path="docs/examples/rig/vector_search.rs">
use std::env;
use rig::{
    embeddings::EmbeddingsBuilder,
    providers::openai::{Client, TEXT_EMBEDDING_ADA_002},
    vector_store::{in_memory_store::InMemoryVectorStore, VectorStoreIndex},
    Embed,
};
use serde::{Deserialize, Serialize};
// Shape of data that needs to be RAG'ed.
// The definition field will be used to generate embeddings.
#[derive(Embed, Clone, Deserialize, Debug, Serialize, Eq, PartialEq, Default)]
struct WordDefinition {
    id: String,
    word: String,
    #[embed]
    definitions: Vec<String>,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Create OpenAI client
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
    let openai_client = Client::new(&openai_api_key);
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_ADA_002);
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(vec![
            WordDefinition {
                id: "doc0".to_string(),
                word: "flurbo".to_string(),
                definitions: vec![
                    "A green alien that lives on cold planets.".to_string(),
                    "A fictional digital currency that originated in the animated series Rick and Morty.".to_string()
                ]
            },
            WordDefinition {
                id: "doc1".to_string(),
                word: "glarb-glarb".to_string(),
                definitions: vec![
                    "An ancient tool used by the ancestors of the inhabitants of planet Jiro to farm the land.".to_string(),
                    "A fictional creature found in the distant, swampy marshlands of the planet Glibbo in the Andromeda galaxy.".to_string()
                ]
            },
            WordDefinition {
                id: "doc2".to_string(),
                word: "linglingdong".to_string(),
                definitions: vec![
                    "A term used by inhabitants of the sombrero galaxy to describe humans.".to_string(),
                    "A rare, mystical instrument crafted by the ancient monks of the Nebulon Mountain Ranges on the planet Quarm.".to_string()
                ]
            },
        ])?
        .build()
        .await?;
    // Create vector store with the embeddings
    let vector_store =
        InMemoryVectorStore::from_documents_with_id_f(embeddings, |doc| doc.id.clone());
    // Create vector store index
    let index = vector_store.index(embedding_model);
    let results = index
        .top_n::<WordDefinition>("I need to buy something in a fictional universe. What type of money can I use for this?", 1)
        .await?
        .into_iter()
        .map(|(score, id, doc)| (score, id, doc.word))
        .collect::<Vec<_>>();
    println!("Results: {:?}", results);
    let id_results = index
        .top_n_ids("I need to buy something in a fictional universe. What type of money can I use for this?", 1)
        .await?
        .into_iter()
        .collect::<Vec<_>>();
    println!("ID results: {:?}", id_results);
    Ok(())
}
</file>

<file path="docs/examples/rig/xai_embeddings.rs">
use rig::providers::xai;
use rig::Embed;
#[derive(Embed, Debug)]
struct Greetings {
    #[embed]
    message: String,
}
#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // Initialize the xAI client
    let client = xai::Client::from_env();
    let embeddings = client
        .embeddings(xai::embedding::EMBEDDING_V1)
        .document(Greetings {
            message: "Hello, world!".to_string(),
        })?
        .document(Greetings {
            message: "Goodbye, world!".to_string(),
        })?
        .build()
        .await
        .expect("Failed to embed documents");
    println!("{:?}", embeddings);
    Ok(())
}
</file>

<file path="docs/examples/rig_concurrent_demo/src/Concurrent_Processing_with_Rig.rs">
// Concurrent Processing with Rig
use rig::providers::openai;  // Import OpenAI provider from Rig
use rig::completion::Prompt;  // Import Prompt trait for LLM interactions
use tokio::task;  // Import Tokio's task spawning functionality
use std::time::Instant;  // For measuring execution time
use std::sync::Arc;  // For thread-safe sharing of the model
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the OpenAI client using environment variables
    let openai_client = openai::Client::from_env();
    // Create a GPT-4o model instance and wrap it in an Arc for thread-safe sharing
    let model = Arc::new(openai_client.model("gpt-4o").build());
    // Start timing the execution
    let start = Instant::now();
    // Vector to store task handles
    let mut handles = vec![];
    // Spawn 10 concurrent tasks
    for i in 0..10 {
        // Clone the Arc<Model> for each task
        let model_clone = Arc::clone(&model);
        // Spawn an asynchronous task
        let handle = task::spawn(async move {
            // Create a unique prompt for each task
            let prompt = format!("Generate a random fact about the number {}", i);
            // Use the cloned model to send a prompt to the LLM
            model_clone.prompt(&prompt).await
        });
        // Store the task handle
        handles.push(handle);
    }
    // Collect and process results
    for handle in handles {
        // Await the completion of each task
        // The first '?' unwraps the JoinError (if the task panicked)
        // The second '?' unwraps the Result from the prompt method
        let result = handle.await??;
        println!("Result: {}", result);
    }
    // Print the total execution time
    println!("Time elapsed: {:?}", start.elapsed());
    Ok(())
}
</file>

<file path="docs/examples/rig_concurrent_demo/src/main.rs">
use rig::providers::openai;  // Import OpenAI provider from Rig
use rig::completion::Prompt;  // Import Prompt trait for LLM interactions
use tokio::task;  // Import Tokio's task spawning functionality
use std::time::Instant;  // For measuring execution time
use std::sync::Arc;  // For thread-safe sharing of the model
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the OpenAI client using environment variables
    let openai_client = openai::Client::from_env();
    // Create a GPT-4o model instance and wrap it in an Arc for thread-safe sharing
    let model = Arc::new(openai_client.model("gpt-4o").build());
    // Start timing the execution
    let start = Instant::now();
    // Vector to store task handles
    let mut handles = vec![];
    // Spawn 10 concurrent tasks
    for i in 0..10 {
        // Clone the Arc<Model> for each task
        let model_clone = Arc::clone(&model);
        // Spawn an asynchronous task
        let handle = task::spawn(async move {
            // Create a unique prompt for each task
            let prompt = format!("Generate a random fact about the number {}", i);
            // Use the cloned model to send a prompt to the LLM
            model_clone.prompt(&prompt).await
        });
        // Store the task handle
        handles.push(handle);
    }
    // Collect and process results
    for handle in handles {
        // Await the completion of each task
        // The first '?' unwraps the JoinError (if the task panicked)
        // The second '?' unwraps the Result from the prompt method
        let result = handle.await??;
        println!("Result: {}", result);
    }
    // Print the total execution time
    println!("Time elapsed: {:?}", start.elapsed());
    Ok(())
}
</file>

<file path="docs/examples/rig_concurrent_demo/Cargo.toml">
[package]
name = "rig_concurrent_demo"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.34.0", features = ["full"] }
</file>

<file path="docs/examples/rig_concurrent_demo/README.md">
# Concurrent Processing with [Rig](https://github.com/0xPlaygrounds/rig)

This example demonstrates how to use [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to perform concurrent processing of LLM tasks. This approach significantly improves performance when dealing with multiple LLM queries, making it ideal for batch processing or high-throughput scenarios.

### Prerequisites

Before you begin, ensure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI or Cohere API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com) or [Cohere's website](https://cohere.com/)

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-concurrent-processing
   cd rig-concurrent-processing
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   tokio = { version = "1.0", features = ["full"] }
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. OpenAI client initialization.
2. Creation of a shared GPT-4o model instance.
3. Spawning of multiple concurrent tasks using Tokio.
4. Concurrent execution of LLM queries.
5. Collection and display of results.

### Running the Example

1. Copy the provided code into your `src/main.rs` file.
2. Run the example using:
   ```
   cargo run
   ```

### Customization

You can easily modify this example to suit your specific use case:
- Change the number of concurrent tasks by adjusting the loop range.
- Modify the prompt to generate different types of content.
- Experiment with different OpenAI models by changing the model name.

### Performance Considerations

- Be mindful of OpenAI's rate limits when increasing concurrency.
- Monitor system resource usage to optimize the number of concurrent tasks.
- Consider implementing error handling and retry logic for production use.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/rss_summarizer/src/main.rs">
use rig::providers::openai::Client;
use schemars::{JsonSchema, schema_for};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use reqwest;
use rss::Channel;
use tokio::time::{self, Duration};
use std::error::Error;
use regex::Regex;
use std::iter::FromIterator;
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
struct SummarizedRssItem {
    title: String,
    link: String,
    #[schemars(with = "String")]
    pub_date: DateTime<Utc>,
    summary: String,
    relevance_score: f32,
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct RssSummary {
    items: Vec<SummarizedRssItem>,
    total_count: usize,
    extraction_time: String, // ISO 8601 formatted string
    overall_summary: String,
}
fn pretty_print_summary(summary: &RssSummary) {
    println!("RSS Feed Summary:");
    println!("Total Items: {}", summary.total_count);
    println!("Extraction Time: {}", summary.extraction_time);
    println!("\nTop Items:");
    for (i, item) in summary.items.iter().enumerate() {
        println!("{}. {}", i + 1, item.title);
        println!("   Link: {}", item.link);
        println!("   Published: {}", item.pub_date);
        println!("   Summary: {}", item.summary);
        println!("   Relevance Score: {:.2}", item.relevance_score);
        println!();
    }
    println!("Overall Summary: {}", summary.overall_summary);
}
async fn fetch_rss_feed(url: &str) -> Result<Channel, Box<dyn Error>> {
    let response = reqwest::get(url).await?.text().await?;
    let channel = response.parse::<Channel>()?;
    Ok(channel)
}
fn sanitize_string(input: &str) -> String {
    let mut sanitized = input.to_string();
    sanitized = sanitized.replace("\n", " ");
    sanitized = sanitized.replace("\r", "");
    sanitized = sanitized.replace("\"", "");
    sanitized = sanitized.replace("’", "'"); // Replace any special quotes
    sanitized
}
async fn summarize_rss_feed(channel: Channel) -> Result<RssSummary, Box<dyn Error>> {
    // Initialize the OpenAI client
    let openai_client = Client::from_env();
    // Create the extractor
    let extractor = openai_client
        .extractor::<RssSummary>("gpt-4o")
        .preamble("You are an AI assistant specialized in summarizing RSS feeds. \
                   Your task is to analyze the RSS items, extract the most relevant information, \
                   and provide concise summaries. For each item, provide a brief summary and a \
                   relevance score from 0.0 to 1.0. Also, provide an overall summary of the feed.")
        .build();
    // Convert RSS items to a format suitable for summarization
    let rss_items = channel.items();
    let mut formatted_rss = String::new();
    // Create regex to remove HTML tags and CDATA sections
    let re_html = Regex::new(r"(?i)<[^>]*>").unwrap();
    let re_cdata = Regex::new(r"(?i)<!\[CDATA\[.*?\]\]>").unwrap();
    for (i, item) in rss_items.iter().enumerate() {
        let title = item.title().unwrap_or("").to_string();
        let link = item.link().unwrap_or("").to_string();
        let pub_date = item.pub_date().unwrap_or("").to_string();
        let description = item.description().unwrap_or("").to_string();
        // Remove CDATA sections and HTML tags
        let clean_description = re_html.replace_all(&re_cdata.replace_all(&description, ""), "").to_string();
        let sanitized_description = sanitize_string(&clean_description);
        formatted_rss.push_str(&format!(
            "{}. Title: {}\nLink: {}\nDate: {}\nDescription: {}\n\n",
            i + 1,
            sanitize_string(&title),
            sanitize_string(&link),
            sanitize_string(&pub_date),
            sanitized_description
        ));
    }
    println!("Extracting summary from the RSS feed...\n");
    // Extract summary
    let rss_summary = extractor.extract(&formatted_rss).await?;
    Ok(rss_summary)
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let rss_url = "https://news.ycombinator.com/rss";
    let mut interval = time::interval(Duration::from_secs(3600)); // 1 hour interval
    loop {
        interval.tick().await;
        match fetch_rss_feed(rss_url).await {
            Ok(channel) => {
                match summarize_rss_feed(channel).await {
                    Ok(rss_summary) => {
                        pretty_print_summary(&rss_summary);
                    }
                    Err(e) => eprintln!("Error summarizing RSS feed: {}", e),
                }
            }
            Err(e) => eprintln!("Error fetching RSS feed: {}", e),
        }
    }
}
</file>

<file path="docs/examples/rss_summarizer/Cargo.toml">
[package]
name = "hn-rss-summarizer"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
serde = { version = "1.0", features = ["derive"] }
schemars = "0.8"
tokio = { version = "1.34", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
reqwest = { version = "0.11", features = ["json"] }
rss = "2.0"
regex = "1"
</file>

<file path="docs/examples/rss_summarizer/README.md">
# Hacker News RSS Feed Summarizer using [Rig](https://github.com/0xPlaygrounds/rig)

This project demonstrates how to leverage [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to create an AI agent that summarizes RSS feeds from Hacker News. The summarizer fetches the latest news articles every hour, processes them using an AI model, and outputs concise summaries along with relevance scores. This project is a great starting point for anyone interested in AI-driven content summarization.

### What is an RSS Feed?

RSS (Really Simple Syndication) is a type of web feed that allows users and applications to receive regular updates from websites. For example, an RSS feed from a news website might provide the latest headlines, summaries, and links to full articles. This project focuses on summarizing the RSS feed from Hacker News, a popular site for tech and startup news.

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Clone this repository or create a new Rust project:
   ```
   cargo new hn-rss-summarizer
   cd hn-rss-summarizer
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig = "0.1.0"
   serde = { version = "1.0", features = ["derive"] }
   chrono = { version = "0.4", features = ["serde"] }
   rss = "2.0"
   tokio = { version = "1.0", features = ["full"] }
   reqwest = { version = "0.11", features = ["json"] }
   regex = "1"
   schemars = "0.8"
   ```

3. Set your OpenAI API key as an environment variable:
   ```bash
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. **Fetching the RSS Feed**:
   This function fetches the RSS feed from Hacker News using the `reqwest` crate and parses it into a `Channel` object using the `rss` crate.

   ```rust
   async fn fetch_rss_feed(url: &str) -> Result<Channel, Box<dyn Error>> {
       let response = reqwest::get(url).await?.text().await?;
       let channel = response.parse::<Channel>()?;
       Ok(channel)
   }
   ```

2. **Sanitizing and Summarizing Feed Items**:
   We sanitize the RSS item descriptions by removing HTML tags and other unwanted characters using the `regex` crate, then summarize the feed using an AI model with Rig.

   ```rust
   let re = Regex::new(r"<[^>]*>").unwrap();
   let clean_description = re.replace_all(&description, "").to_string();
   ```

3. **AI-Based Summarization**:
   An AI extractor is set up using Rig to analyze the RSS feed items and generate concise summaries with relevance scores.

   ```rust
   let extractor = openai_client
       .extractor::<RssSummary>("gpt-4o")
       .preamble("You are an AI assistant specialized in summarizing RSS feeds...")
       .build();
   ```

4. **Periodic Fetching and Summarization**:
   The main function sets up a loop to fetch and summarize the RSS feed every hour using `tokio::time::interval`.

   ```rust
   let mut interval = time::interval(Duration::from_secs(3600));
   loop {
       interval.tick().await;
       match fetch_rss_feed(rss_url).await {
           // Handling fetch and summarization logic
       }
   }
   ```

### Running the Example

1. Ensure all dependencies are listed in your `Cargo.toml`.
2. Run the example using:
   ```bash
   cargo run
   ```

### Understanding the Code

Here’s a breakdown of the key parts:

- **RSS Fetching**: We use `reqwest` to fetch the RSS feed and `rss` crate to parse it.
- **Sanitization**: HTML tags and unnecessary characters are removed to clean the RSS content.
- **Summarization**: Rig, coupled with OpenAI's GPT-4 model, is employed to generate summaries.
- **Periodic Execution**: Using `tokio`, the fetch-summarize loop runs every hour, automatically fetching new content and generating fresh summaries.

### Customization

Feel free to customize the `main` function's interval timing or modify the summarization prompt to adjust the level of detail or style of the summaries. You can also change the RSS feed URL to summarize different content.

### Troubleshooting

If you encounter any issues:

- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.
- If you receive errors related to the RSS feed parsing, ensure the feed URL is correct and accessible.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/rugcheck/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_plugin_rugcheck::fetch_summary_report;
#[tokio::main]
async fn main() {
    let mint = "84VUXykQjNvPDm88oT5FRucXeNcrwdQGottJKjkAoqd1".into();
    let check = fetch_summary_report(mint).await.unwrap();
    println!("Token check: {:?}", check);
}
</file>

<file path="docs/examples/rugcheck/Cargo.toml">
[package]
name = "rugcheck"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-plugin-rugcheck = "0.1.0"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="docs/examples/rustbuddy/src/main.rs">
use std::error::Error;
use std::io;
use std::time::Duration;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Span, Spans, Text},
    widgets::{Block, Borders, Paragraph, Wrap},
    Frame, Terminal,
};
use rig::completion::Chat;
use rig::embeddings::EmbeddingsBuilder;
use rig::providers::openai;
use rig::vector_store::{in_memory_store::InMemoryVectorStore, VectorStore};
const RUST_DOCS: &[(&str, &str)] = &[
    ("compilation error", "Rust compilation errors occur when the code doesn't meet the language's rules. Common causes include syntax errors, type mismatches, and borrowing rule violations."),
    ("borrow checker", "Rust's borrow checker ensures memory safety by enforcing rules about data ownership, borrowing, and lifetimes."),
    ("lifetime", "Lifetimes in Rust are a compile-time feature that helps prevent dangling references and ensures references are valid for a specific scope."),
    ("ownership", "Ownership is a key concept in Rust that governs how memory is managed. Each value has an owner, and there can only be one owner at a time."),
    ("mut", "The 'mut' keyword in Rust indicates that a variable binding is mutable, allowing its value to be changed."),
    ("Result", "Result is an enum used for returning and propagating errors. It has two variants: Ok(T) for success and Err(E) for error."),
    ("Option", "Option is an enum that represents an optional value. It has two variants: Some(T) containing a value, or None representing no value."),
    ("unwrap", "The 'unwrap' method extracts the value from an Option or Result, but panics if it's None or Err."),
    ("expect", "Similar to 'unwrap', but allows specifying an error message if the operation fails."),
    ("Vec", "Vec<T> is a growable array type in Rust, providing a contiguous, heap-allocated list of elements."),
    ("String", "String is the standard string type in Rust, representing a growable, mutable, owned UTF-8 encoded string."),
    ("str", "&str is a string slice, representing a view into a string. It's often used for string literals or borrowed string data."),
    ("match", "The 'match' expression in Rust allows pattern matching against a value, often used for control flow."),
    ("if let", "The 'if let' syntax is a concise way to handle a single pattern matching case, often used with Option or Result types."),
    ("trait", "Traits in Rust define shared behavior for types, similar to interfaces in other languages."),
    ("impl", "The 'impl' keyword is used to implement methods or traits for a type."),
    ("generic", "Generics in Rust allow writing code that works with multiple types, promoting code reuse and type safety."),
    ("macro", "Macros in Rust are a way of writing code that writes other code, often used for metaprogramming and reducing boilerplate."),
    ("async/await", "Async/await in Rust provides a way to write asynchronous code that looks and behaves like synchronous code."),
    ("cargo", "Cargo is Rust's package manager and build system, used for managing dependencies and building projects."),
];
struct App {
    input: String,
    output: String,
    chat_history: Vec<String>,
    input_mode: InputMode,
    rag_agent: rig::rag::RagAgent<openai::CompletionModel, InMemoryVectorStore, InMemoryVectorStore>,
}
enum InputMode {
    Normal,
    Editing,
}
impl App {
    fn new(rag_agent: rig::rag::RagAgent<openai::CompletionModel, InMemoryVectorStore, InMemoryVectorStore>) -> App {
        App {
            input: String::new(),
            output: String::new(),
            chat_history: Vec::new(),
            input_mode: InputMode::Normal,
            rag_agent,
        }
    }
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize OpenAI client
    let openai_client = openai::Client::from_env();
    // Create embedding model and vector store
    let embedding_model = openai_client.embedding_model("text-embedding-ada-002");
    let mut vector_store = InMemoryVectorStore::default();
    // Populate vector store with Rust documentation
    let embeddings = EmbeddingsBuilder::new(embedding_model.clone())
        .documents(RUST_DOCS.iter().map(|(k, v)| (k.to_string(), v.to_string(), vec![v.to_string()])).collect())
        .build()
        .await?;
    vector_store.add_documents(embeddings).await?;
    // Create RAG agent
    let rag_agent = openai_client.context_rag_agent("gpt-4o")
        .preamble("You are RustBuddy, an AI assistant specialized in explaining Rust compilation errors and suggesting fixes. Provide clear, concise, and accurate explanations. Format your response in Markdown.")
        .dynamic_context(3, vector_store.index(embedding_model))
        .build();
    // Set up terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    // Create app state
    let mut app = App::new(rag_agent);
    // Run the main loop
    run_app(&mut terminal, &mut app).await?;
    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;
    Ok(())
}
async fn run_app<B: ratatui::backend::Backend>(terminal: &mut Terminal<B>, app: &mut App) -> io::Result<()> {
    loop {
        terminal.draw(|f| ui(f, app))?;
        if let Event::Key(key) = event::read()? {
            match app.input_mode {
                InputMode::Normal => match key.code {
                    KeyCode::Char('e') => {
                        app.input_mode = InputMode::Editing;
                    }
                    KeyCode::Char('q') => {
                        return Ok(());
                    }
                    _ => {}
                },
                InputMode::Editing => match key.code {
                    KeyCode::Enter => {
                        let input = app.input.drain(..).collect();
                        app.chat_history.push(format!("You: {}", input));
                        let response = app.rag_agent.chat(&input, vec![]).await.unwrap();
                        app.chat_history.push(format!("RustBuddy: {}", response));
                        app.output = response;
                        app.input_mode = InputMode::Normal;
                    }
                    KeyCode::Char(c) => {
                        app.input.push(c);
                    }
                    KeyCode::Backspace => {
                        app.input.pop();
                    }
                    KeyCode::Esc => {
                        app.input_mode = InputMode::Normal;
                    }
                    _ => {}
                },
            }
        }
    }
}
fn ui<B: ratatui::backend::Backend>(f: &mut Frame<B>, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .margin(2)
        .constraints(
            [
                Constraint::Length(3),
                Constraint::Min(1),
                Constraint::Length(3),
            ]
            .as_ref(),
        )
        .split(f.size());
    let (msg, style) = match app.input_mode {
        InputMode::Normal => (
            vec![
                Span::raw("Press "),
                Span::styled("q", Style::default().add_modifier(Modifier::BOLD)),
                Span::raw(" to exit, "),
                Span::styled("e", Style::default().add_modifier(Modifier::BOLD)),
                Span::raw(" to start editing."),
            ],
            Style::default().add_modifier(Modifier::RAPID_BLINK),
        ),
        InputMode::Editing => (
            vec![
                Span::raw("Press "),
                Span::styled("Esc", Style::default().add_modifier(Modifier::BOLD)),
                Span::raw(" to stop editing, "),
                Span::styled("Enter", Style::default().add_modifier(Modifier::BOLD)),
                Span::raw(" to submit."),
            ],
            Style::default(),
        ),
    };
    let mut text = Text::from(Spans::from(msg));
    text.patch_style(style);
    let help_message = Paragraph::new(text);
    f.render_widget(help_message, chunks[0]);
    let input = Paragraph::new(app.input.as_ref())
        .style(match app.input_mode {
            InputMode::Normal => Style::default(),
            InputMode::Editing => Style::default().fg(Color::Yellow),
        })
        .block(Block::default().borders(Borders::ALL).title("Input"));
    f.render_widget(input, chunks[2]);
    match app.input_mode {
        InputMode::Normal =>
            // Hide the cursor. `Frame` does this by default, so we don't need to do anything here
            {}
        InputMode::Editing => {
            // Make the cursor visible and ask tui-rs to put it at the specified coordinates after rendering
            f.set_cursor(
                // Put cursor at the end of the input text
                chunks[2].x + app.input.len() as u16 + 1,
                // Move one line down, from the border to the input line
                chunks[2].y + 1,
            )
        }
    }
    let messages: Vec<Spans> = app
        .chat_history
        .iter()
        .map(|m| Spans::from(Span::styled(m, Style::default().add_modifier(Modifier::BOLD))))
        .collect();
    let messages =
        Paragraph::new(messages)
            .block(Block::default().borders(Borders::ALL).title("Messages"))
            .wrap(Wrap { trim: true });
    f.render_widget(messages, chunks[1]);
}
</file>

<file path="docs/examples/rustbuddy/Cargo.toml">
[package]
name = "rustbuddy"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.34.0", features = ["full"] }
anyhow = "1.0.75"
crossterm = "0.27.0"
ratatui = "0.23.0"
syntect = "5.1.0"
</file>

<file path="docs/examples/simple_agent/src/main.rs">
use anyhow::Result;
use rig::completion::{Chat, Message};
use rig::model::ModelBuilder;
use rig::providers::cohere::{self, Client};
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize the Cohere client
    let cohere = Client::new(&std::env::var("COHERE_API_KEY")?);
    // Create a Cohere model
    let model = ModelBuilder::new(cohere.completion_model(cohere::COMMAND))
        .temperature(0.7)
        .build();
    // Define our context
    let context = "
    The Rust programming language was initially designed and developed by Mozilla employee Graydon Hoare as a personal project. 
    Mozilla began sponsoring the project in 2009 and announced it in 2010. 
    Rust 1.0, the first stable release, was released on May 15, 2015.
    Rust is syntactically similar to C++, but provides memory safety without using garbage collection.
    Rust has been voted the 'most loved programming language' in the Stack Overflow Developer Survey every year since 2016.
    ";
    // Create our chat history with the context
    let mut chat_history = vec![
        Message {
            role: "system".to_string(),
            content: "You are a helpful assistant that answers questions based on the given context.".to_string(),
        },
        Message {
            role: "user".to_string(),
            content: format!("Here's some context for you to use: {}", context),
        },
        Message {
            role: "assistant".to_string(),
            content: "Thank you for providing the context about Rust. I'm ready to answer any questions you may have about it.".to_string(),
        },
    ];
    // Main interaction loop
    loop {
        println!("Ask a question about Rust (or type 'exit' to quit):");
        let mut question = String::new();
        std::io::stdin().read_line(&mut question)?;
        question = question.trim().to_string();
        if question.to_lowercase() == "exit" {
            break;
        }
        chat_history.push(Message {
            role: "user".to_string(),
            content: question,
        });
        // Get the model's response
        let response = model.chat(&chat_history.last().unwrap().content, chat_history.clone()).await?;
        println!("Answer: {}", response);
        chat_history.push(Message {
            role: "assistant".to_string(),
            content: response,
        });
    }
    Ok(())
}
</file>

<file path="docs/examples/simple_agent/Cargo.toml">
[package]
name = "simple_agent"
version = "0.0.6"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
</file>

<file path="docs/examples/synthetic_data_example/src/main.rs">
use rig::providers::openai;
use rig::completion::Prompt;
use serde::{Deserialize, Serialize};
use std::error::Error;
#[derive(Debug, Deserialize, Serialize)]
struct PersonData {
    name: String,
    age: u8,
    email: String,
    occupation: String,
    favorite_color: String,
}
fn pretty_print_person(person: &PersonData) {
    println!("Generated Person Data:");
    println!("  Name: {}", person.name);
    println!("  Age: {}", person.age);
    println!("  Email: {}", person.email);
    println!("  Occupation: {}", person.occupation);
    println!("  Favorite Color: {}", person.favorite_color);
    println!();
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize the OpenAI client
    let openai_client = openai::Client::from_env();
    // Create the data generator
    let data_generator = openai_client
        .model("gpt-4o")
        .build();
    // Define the schema and instructions
    let schema_and_instructions = r#"
    Generate synthetic personal data based on the following schema:
    {
        "name": "String (full name)",
        "age": "Integer (18-80)",
        "email": "String (valid email format)",
        "occupation": "String",
        "favorite_color": "String"
    }
    Instructions:
    1. Generate realistic and diverse data.
    2. Ensure email addresses are in a valid format but fictional.
    3. Vary the occupations and favorite colors.
    4. Provide the data in JSON format.
    Generate 5 unique entries.
    "#;
    // Generate synthetic data
    let generated_data = data_generator.prompt(schema_and_instructions).await?;
    // Parse and print the generated data
    let people: Vec<PersonData> = serde_json::from_str(&generated_data)?;
    for person in people {
        pretty_print_person(&person);
    }
    Ok(())
}
</file>

<file path="docs/examples/synthetic_data_example/Cargo.toml">
[package]
name = "synthetic_data_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
</file>

<file path="docs/examples/synthetic_data_example/README.md">
# Synthetic Data Generation with [Rig](https://github.com/0xPlaygrounds/rig)

This example showcases how to leverage [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to generate realistic synthetic data based on a given schema. Whether you're new to Rig or looking to explore its capabilities, this example provides an excellent starting point for understanding how to work with AI-powered data generation.

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-synthetic-data
   cd rig-synthetic-data
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   tokio = { version = "1.0", features = ["full"] }
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. A custom data structure (`PersonData`) for representing our synthetic data.
2. OpenAI client initialization.
3. A data generator setup using the GPT-4 model.
4. A schema and instructions for data generation.
5. The data generation process and result handling.

### Running the Example

1. Copy the provided code into your `src/main.rs` file.
2. Run the example using:
   ```
   cargo run
   ```

### Customization

Feel free to modify the `PersonData` struct or adjust the schema and instructions to generate different types of data. You can also experiment with different OpenAI models by changing the model name in the data generator setup.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/text_classification_example/src/main.rs">
use rig::providers::openai;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
enum Category {
    Technology,
    Science,
    Politics,
    Sports,
    Entertainment,
    Other(String),
}
#[derive(Debug, Deserialize, JsonSchema, Serialize)]
struct ClassificationResult {
    category: Category,
    confidence: f32,
    summary: String,
}
fn pretty_print_result(text: &str, result: &ClassificationResult) {
    println!("Text: \"{}\"", text);
    println!("Classification Result:");
    println!("  Category: {:?}", result.category);
    println!("  Confidence: {:.2}%", result.confidence * 100.0);
    println!("  Summary: {}", result.summary);
    println!();
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the OpenAI client
    let openai_client = openai::Client::from_env();
    // Create the classifier
    let classifier = openai_client
        .extractor::<ClassificationResult>("gpt-4o")
        .preamble(
            "You are an AI assistant specialized in classifying text into predefined categories. \
            The categories are: Technology, Science, Politics, Sports, and Entertainment. \
            If the text doesn't fit into these categories, use the Other category and specify a suitable label. \
            Provide a confidence score and a brief summary for each classification."
        )
        .build();
    // Sample texts for classification
    let sample_texts = vec![
        "Apple announced its new M2 chip, promising significant performance improvements for MacBooks.",
        "Scientists have discovered a new exoplanet that could potentially harbor life.",
        "The upcoming election is expected to be one of the most closely contested in recent history.",
        "The underdog team pulled off a stunning victory in the championship final.",
        "The latest blockbuster movie broke box office records in its opening weekend.",
        "The annual flower show attracted gardening enthusiasts from across the country.",
    ];
    // Classify each sample text
    for text in sample_texts {
        match classifier.extract(text).await {
            Ok(result) => pretty_print_result(text, &result),
            Err(e) => eprintln!("Error classifying text: {}", e),
        }
    }
    Ok(())
}
</file>

<file path="docs/examples/text_classification_example/Cargo.toml">
[package]
name = "text_classification_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
</file>

<file path="docs/examples/text_classification_example/README.md">
# Text Classification with [Rig](https://github.com/0xPlaygrounds/rig)

This example showcases how to use [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to classify text into predefined categories. Whether you're new to Rig or looking to explore its capabilities, this example provides an excellent starting point for understanding how to work with custom data structures and AI-powered classification.

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-text-classification
   cd rig-text-classification
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   serde = { version = "1.0.193", features = ["derive"] }
   schemars = "0.8"
   tokio = { version = "1.0", features = ["full"] }
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. Custom data structures (`Category` enum and `ClassificationResult` struct) for representing classification results.
2. An OpenAI client initialization.
3. A classifier setup using the GPT-4 model.
4. A set of sample texts for classification.
5. The classification process and result handling.

### Running the Example

1. Copy the provided code into your `src/main.rs` file.
2. Run the example using:
   ```
   cargo run
   ```

### Customization

Feel free to modify the `sample_texts` or adjust the `Category` enum to suit your specific use case. You can also experiment with different OpenAI models by changing the model name in the classifier setup.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/tic-tac-toe_example/src/main.rs">
use rig::providers::openai;
use rig::completion::Prompt;
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::io::{self, Write};
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
enum Player {
    X,
    O,
    Empty,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Board {
    cells: [Player; 9],
}
impl Board {
    fn new() -> Self {
        Board {
            cells: [Player::Empty; 9],
        }
    }
    fn make_move(&mut self, position: usize, player: Player) -> Result<(), String> {
        if position < 1 || position > 9 {
            return Err("Invalid position. Choose a number between 1 and 9.".to_string());
        }
        let index = position - 1;
        if self.cells[index] != Player::Empty {
            return Err("This cell is already occupied.".to_string());
        }
        self.cells[index] = player;
        Ok(())
    }
    fn is_full(&self) -> bool {
        self.cells.iter().all(|&cell| cell != Player::Empty)
    }
    fn has_winner(&self) -> Option<Player> {
        const WINNING_COMBINATIONS: [[usize; 3]; 8] = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6],            // Diagonals
        ];
        for combo in WINNING_COMBINATIONS.iter() {
            if self.cells[combo[0]] != Player::Empty
                && self.cells[combo[0]] == self.cells[combo[1]]
                && self.cells[combo[1]] == self.cells[combo[2]]
            {
                return Some(self.cells[combo[0]]);
            }
        }
        None
    }
    fn to_string(&self) -> String {
        let mut result = String::new();
        result.push_str("┌───┬───┬───┐\n");
        for i in 0..3 {
            result.push_str("│");
            for j in 0..3 {
                let index = i * 3 + j;
                let symbol = match self.cells[index] {
                    Player::X => " X ".to_string(),
                    Player::O => " O ".to_string(),
                    Player::Empty => format!(" {} ", index + 1),
                };
                result.push_str(&symbol);
                if j < 2 {
                    result.push_str("│");
                }
            }
            result.push_str("│\n");
            if i < 2 {
                result.push_str("├───┼───┼───┤\n");
            }
        }
        result.push_str("└───┴───┴───┘\n");
        result
    }
}
fn parse_ai_response(response: &str) -> Result<usize, String> {
    // First, try to parse the entire response as a number
    if let Ok(num) = response.trim().parse::<usize>() {
        return Ok(num);
    }
    // If that fails, try to find the first number in the response
    for word in response.split_whitespace() {
        if let Ok(num) = word.parse::<usize>() {
            return Ok(num);
        }
    }
    // If we still can't find a number, return an error
    Err("Could not find a valid move in the AI's response".to_string())
}
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let openai_client = openai::Client::from_env();
    let ai_player = openai_client.model("gpt-4o").build();
    let mut board = Board::new();
    let mut current_player = Player::X;
    println!("Welcome to Tic-Tac-Toe! You are X, and the AI is O.");
    println!("Enter a number from 1-9 to make your move.");
    loop {
        println!("\nCurrent board:");
        println!("{}", board.to_string());
        match current_player {
            Player::X => {
                print!("Your move (X): ");
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                let position: usize = input.trim().parse()?;
                if let Err(e) = board.make_move(position, Player::X) {
                    println!("Error: {}. Try again.", e);
                    continue;
                }
            }
            Player::O => {
                println!("AI is thinking...");
                let prompt = format!(
                    "You are playing Tic-Tac-Toe as O. Here's the current board state:\n{}\nWhat's your next move? Respond with just the number (1-9) of the position you want to play.",
                    board.to_string()
                );
                let ai_response = ai_player.prompt(&prompt).await?;
                let position = parse_ai_response(&ai_response);
                match position {
                    Ok(pos) => {
                        if let Err(e) = board.make_move(pos, Player::O) {
                            println!("AI made an invalid move: {}. It forfeits its turn.", e);
                            continue;
                        }
                        println!("AI chose position {}", pos);
                    }
                    Err(e) => {
                        println!("Failed to parse AI's move: {}. AI forfeits its turn.", e);
                        continue;
                    }
                }
            }
            Player::Empty => unreachable!(),
        }
        if let Some(winner) = board.has_winner() {
            println!("\nFinal board:");
            println!("{}", board.to_string());
            println!("Player {:?} wins!", winner);
            break;
        }
        if board.is_full() {
            println!("\nFinal board:");
            println!("{}", board.to_string());
            println!("It's a draw!");
            break;
        }
        current_player = match current_player {
            Player::X => Player::O,
            Player::O => Player::X,
            Player::Empty => unreachable!(),
        };
    }
    Ok(())
}
</file>

<file path="docs/examples/tic-tac-toe_example/Cargo.toml">
[package]
name = "tic-tac-toe_example"
version = "0.1.0"
edition = "2021"

[dependencies]
rig-core = "0.0.6"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11.22", features = ["json"] }
serde = { version = "1.0.193", features = ["derive"] }

# Environment variables
dotenvy = "0.15.7"
anyhow = "1.0"
serde_json = "1.0.108"
tracing = "0.1.40"
futures = "0.3.29"
ordered-float = "4.2.0"
schemars = "0.8.16"
thiserror = "1.0.61"
plotters = "0.3"
</file>

<file path="docs/examples/tic-tac-toe_example/README.md">
# [Rig](https://github.com/0xPlaygrounds/rig)-Powered Tic-Tac-Toe Game

This project demonstrates how to use [Rig](https://github.com/0xPlaygrounds/rig), a powerful Rust library for building LLM-powered applications, to create an AI opponent in a classic game of Tic-Tac-Toe. Whether you're new to Rig or looking to explore AI integration in game development, this example provides an excellent starting point.

### What is [Rig](https://github.com/0xPlaygrounds/rig)?

Rig is a Rust library that simplifies the process of integrating large language models (LLMs) into your applications. It provides an easy-to-use interface for interacting with AI models, allowing developers to focus on their application logic rather than the intricacies of AI API interactions.

### Prerequisites

Before you begin, make sure you have the following installed:

- Rust (latest stable version)
- Cargo (Rust's package manager)

You'll also need an OpenAI API key. If you don't have one, you can sign up at [OpenAI's website](https://openai.com).

### Setup

1. Create a new Rust project:
   ```
   cargo new rig-tictactoe
   cd rig-tictactoe
   ```

2. Add the following dependencies to your `Cargo.toml`:
   ```toml
   [dependencies]
   rig-core = "0.1.0"
   serde = { version = "1.0.193", features = ["derive"] }
   tokio = { version = "1.0", features = ["full"] }
   ```

3. Set your OpenAI API key as an environment variable:
   ```
   export OPENAI_API_KEY=your_api_key_here
   ```

### Code Overview

The main components of this example are:

1. Game state representation (`Player` enum and `Board` struct)
2. Game logic (move validation, win checking, board visualization)
3. AI integration using Rig
4. Main game loop with turn alternation between human and AI

### Running the Game

1. Copy the provided code into your `src/main.rs` file.
2. Run the game using:
   ```
   cargo run
   ```

### Key Concepts

1. **AI Integration**: We use Rig to create an AI player that can understand the game state and make moves:
   ```rust
   let ai_player = openai_client.model("gpt-4o").build();
   ```

2. **Prompt Engineering**: We construct prompts that describe the game state and expected response format:
   ```rust
   let prompt = format!(
       "You are playing Tic-Tac-Toe as O. Here's the current board state:\n{}\nWhat's your next move? Respond with just the number (1-9) of the position you want to play.",
       board.to_string()
   );
   ```

3. **Response Parsing**: We parse the AI's responses to extract valid moves:
   ```rust
   fn parse_ai_response(response: &str) -> Result<usize, String> {
       // Parsing logic here
   }
   ```

4. **Error Handling**: We use Rust's `Result` type for robust error handling throughout the game.

5. **Asynchronous Operations**: We use `tokio` for asynchronous execution when interacting with the AI.

### Customization

Feel free to modify the game logic, board visualization, or AI prompts to experiment with different game mechanics or AI behaviors. You could also try using different AI models or adjusting the temperature setting for varied AI responses.

### Troubleshooting

If you encounter any issues:
- Ensure your OpenAI API key is correctly set.
- Check that all dependencies are properly installed.
- Verify that you're using a compatible Rust version.

For more detailed information, refer to the [Rig documentation](https://docs.rs/rig).
</file>

<file path="docs/examples/token_security/src/main.rs">
// Copyright 2025 zTgx
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use solagent_plugin_goplus::get_token_security_info;
#[tokio::main]
async fn main() {
    let chain_id = "42161";
    let mint = "0xEa51801b8F5B88543DdaD3D1727400c15b209D8f";
    let check = get_token_security_info(chain_id, mint).await.unwrap();
    println!("Token check: {:?}", check);
}
</file>

<file path="docs/examples/token_security/Cargo.toml">
[package]
name = "token_security"
version.workspace = true
edition.workspace = true

[dependencies]
solagent-core = "0.1.3"
solagent-plugin-goplus = "0.1.0"
tokio = { version = "1.42.0", features = ["full"] }
</file>

<file path="memory-bank/activeContext.md">
# Active Context

## Current Task

Implementing and debugging MongoDB vector store integration for the Cainam Core Agent, specifically focusing on using the `rig-mongodb` crate correctly.

## Action Plan

1. ✅ MongoDB Atlas Integration
   - Set up MongoDB Atlas cluster
   - Configured connection string and authentication
   - Implemented connection pooling

2. ✅ Vector Store Implementation
   - Added MongoDB vector store support
   - Implemented token analytics collection
   - Created vector search index for embeddings

3. ✅ **Current Issues Resolved**
   - Fixed SearchParams configuration for vector search (removed unnecessary parameters)
   - Resolved vector store initialization errors
   - Corrected generic type usage with `rig-mongodb` (`MongoDbVectorIndex::<_, TokenAnalyticsData>::new`)
   - Fixed collection type mismatch (used `collection::<TokenAnalyticsData>`)

4. 🔄 **Current Focus**
    - Thoroughly testing the vector search functionality.
    - Ensuring the `test_vector_search.rs` script works correctly.

## Technical Context

- Project uses MongoDB Atlas for vector store capabilities
- Vector search implemented using MongoDB Atlas Search and the `rig-mongodb` crate.
- Token analytics data stored with embeddings
- Connection pooling configured for optimal performance

## Resolution Progress

Current implementation includes:

1. ✅ MongoDB connection pool configuration
2. ✅ Token analytics data structure
3. ✅ Vector index creation
4. ✅ Search parameters configuration (simplified)
5. ✅ Document insertion functionality
6. ✅ `rig-mongodb` integration for vector search

Current Issues:

- None identified.  Focus is on testing.

Next steps:

1. Thoroughly test vector search functionality.
2. Implement proper error handling (ongoing).
3. Add comprehensive logging (ongoing).
4. Document MongoDB integration details (ongoing).

Technical Notes:

- Using MongoDB Atlas vector search capabilities
- Embedding dimension: 1536 (OpenAI compatible)
- Cosine similarity for vector search
- Connection pooling configured with:
  - Min pool size: 5
  - Max pool size: 10
  - Connect timeout: 20 seconds
- Vector index using IVFFlat algorithm (default for `rig-mongodb`)
- Using `rig-mongodb` for simplified vector search implementation.
</file>

<file path="memory-bank/codeReview.md">
# Code Review Guidelines

Last Updated: 2025-02-11

## Focus Areas

### 1. MongoDB Integration

- Connection pooling configuration
- Error handling and retry logic
- Proper use of MongoDB Atlas features
- Vector store implementation

### 2. Vector Search Implementation

- Proper embedding handling
- Search parameter configuration
- Index creation and management
- Query optimization

### 3. Error Handling

```rust
// Good: Proper error context and handling
pub async fn search_tokens(query: &str) -> Result<Vec<TokenAnalytics>> {
    let results = pool.top_n("token_analytics", model, query, 10)
        .await
        .context("Failed to perform vector search")?;
    
    process_results(results)
        .context("Failed to process search results")
}

// Bad: Missing error context
pub async fn search_tokens(query: &str) -> Result<Vec<TokenAnalytics>> {
    let results = pool.top_n("token_analytics", model, query, 10).await?;
    process_results(results)
}
```

### 4. Connection Management

```rust
// Good: Proper connection pool configuration
let pool_config = MongoPoolConfig {
    min_pool_size: 5,
    max_pool_size: 10,
    connect_timeout: Duration::from_secs(20),
};

// Bad: Hardcoded values without configuration
let client = Client::with_uri_str("mongodb://localhost").await?;
```

### 5. Vector Store Operations

```rust
// Good: Proper search parameters
let search_params = SearchParams::new()
    .exact(true)
    .num_candidates(100)
    .fields(vec!["embedding"]);

// Bad: Missing required parameters
let search_params = SearchParams::new()
    .exact(true)
    .num_candidates(100);
```

## Review Checklist

### MongoDB Integration

- [ ] Proper connection pool configuration
- [ ] Error handling with context
- [ ] Retry logic for transient failures
- [ ] Proper use of MongoDB Atlas features
- [ ] Connection string security

### Vector Store Implementation

- [ ] Proper embedding field configuration
- [ ] Search parameter completeness
- [ ] Index creation and management
- [ ] Query optimization
- [ ] Error handling for vector operations

### Code Quality

- [ ] Error handling with proper context
- [ ] Logging for important operations
- [ ] Performance considerations
- [ ] Type safety and null handling
- [ ] Documentation completeness

### Testing

- [ ] Unit tests for vector operations
- [ ] Integration tests for MongoDB
- [ ] Error case coverage
- [ ] Performance benchmarks
- [ ] Connection pool tests

## Common Issues to Watch

1. MongoDB Operations
   - Missing error context
   - Improper connection handling
   - Missing retry logic
   - Hardcoded configuration

2. Vector Store
   - Missing search parameters
   - Improper embedding handling
   - Missing index configuration
   - Inefficient queries

3. Error Handling
   - Generic error types
   - Missing error context
   - Improper error propagation
   - Missing logging

4. Performance
   - Connection pool misconfiguration
   - Missing indexes
   - Inefficient queries
   - Resource leaks

## Best Practices

### MongoDB Integration

```rust
// Connection Pool
impl MongoDbPool {
    pub async fn create_pool(config: MongoConfig) -> Result<Arc<MongoDbPool>> {
        let mut client_options = ClientOptions::parse(&config.uri).await?;
        config.pool_config.apply_to_options(&mut client_options);
        
        let client = Client::with_options(client_options)?;
        Ok(Arc::new(MongoDbPool { client, config }))
    }
}

// Error Handling
pub async fn insert_documents(docs: Vec<Document>) -> Result<()> {
    let collection = self.get_collection()?;
    collection
        .insert_many(docs)
        .await
        .context("Failed to insert documents")?;
    Ok(())
}
```

### Vector Store Operations

```rust
// Search Implementation
pub async fn search_similar(query: &str, limit: usize) -> Result<Vec<Document>> {
    let search_params = SearchParams::new()
        .exact(true)
        .num_candidates(100)
        .fields(vec!["embedding"]);

    let index = MongoDbVectorIndex::new(
        collection,
        model,
        "vector_index",
        search_params
    ).await?;

    index.top_n(query, limit).await
}
```

## Documentation Requirements

1. Function Documentation

```rust
/// Performs a vector similarity search in the token analytics collection
/// 
/// # Arguments
/// * `query` - The search query string
/// * `limit` - Maximum number of results to return
/// 
/// # Returns
/// * `Result<Vec<TokenAnalytics>>` - Search results or error with context
pub async fn search_tokens(query: &str, limit: usize) -> Result<Vec<TokenAnalytics>>
```

2. Error Documentation

```rust
/// Possible errors during vector store operations
#[derive(Error, Debug)]
pub enum VectorStoreError {
    #[error("MongoDB operation failed: {0}")]
    MongoError(#[from] mongodb::error::Error),
    
    #[error("Vector search failed: {0}")]
    SearchError(String),
    
    #[error("Invalid configuration: {0}")]
    ConfigError(String),
}
```
</file>

<file path="memory-bank/developmentWorkflow.md">
# Development Workflow

Last Updated: 2025-02-11

## Implementation Plan

### Phase 1: Core Infrastructure (Current Phase)

#### Vector Store Implementation

- [x] MongoDB Atlas Setup
  - [x] Configure connection pooling
  - [x] Set up authentication
  - [x] Create collections

- [x] Vector Search Integration
  - [x] Create vector index
  - [x] Implement embedding storage
  - [x] Configure search parameters

- [ ] Token Analytics System
  - [x] Implement data models
  - [x] Add document insertion
  - [ ] Complete search functionality
  - [ ] Add comprehensive error handling

#### Next Steps: Agent System

- [ ] Complete trader agent implementation
  - [ ] Vector store integration
  - [ ] Market signal processing
  - [ ] Decision making logic

- [ ] Risk Management
  - [ ] Risk scoring system
  - [ ] Position monitoring
  - [ ] Portfolio analysis

### Current Focus

1. Vector Store Completion
   - Fix SearchParams configuration
   - Implement proper error handling
   - Add comprehensive logging
   - Complete testing suite

2. Agent Integration
   - Connect vector store to agent system
   - Implement market analysis
   - Add decision making logic

## Testing Strategy

### Unit Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_vector_search() -> Result<()> {
        let pool = setup_test_pool().await?;
        let result = pool.top_n("test_collection", model, "query", 10).await?;
        assert!(!result.is_empty());
        Ok(())
    }
}
```

### Integration Testing

1. MongoDB Operations
   - Connection pool management
   - Document insertion
   - Vector search functionality
   - Error handling

2. Vector Store Integration
   - Embedding generation
   - Search accuracy
   - Performance metrics
   - Error scenarios

## Project Standards

### Code Organization

```
src/
├── config/       # Configuration (MongoDB, etc.)
├── models/       # Data models
├── services/     # Business logic
├── agent/        # Agent implementations
└── trading/      # Trading logic
```

### Error Handling

```rust
use anyhow::{Context, Result};

pub async fn search_tokens(query: &str) -> Result<Vec<TokenAnalytics>> {
    let results = pool.top_n("token_analytics", model, query, 10)
        .await
        .context("Failed to perform vector search")?;
    
    process_results(results)
        .context("Failed to process search results")?;
    
    Ok(results)
}
```

### MongoDB Integration

```rust
// Connection Pool Configuration
let pool_config = MongoPoolConfig {
    min_pool_size: 5,
    max_pool_size: 10,
    connect_timeout: Duration::from_secs(20),
};

// Vector Search Parameters
let search_params = SearchParams::new()
    .exact(true)
    .num_candidates(100)
    .fields(vec!["embedding"]);
```

## Monitoring and Maintenance

### Health Checks

- MongoDB connection status
- Vector search performance
- Error rates and types
- System resource usage

### Performance Metrics

- Search latency
- Connection pool utilization
- Document insertion rates
- Memory usage

### Error Handling

- Structured error logging
- MongoDB operation retries
- Connection error recovery
- Alert thresholds

### Maintenance Tasks

- Index optimization
- Connection pool monitoring
- Error log analysis
- Performance tuning
</file>

<file path="memory-bank/operationalContext.md">
# Operational Context

Last Updated: 2025-01-30

## System Operation

### Core Services

1. **Market Data Service**

   ```rust
   pub struct MarketDataService {
       birdeye_client: BirdeyeClient,
       db_pool: PgPool,
       cache: Cache,
   }
   ```

   - Real-time price and volume monitoring
   - Historical data aggregation
   - Market trend analysis
   - Data validation and cleaning

2. **Trading Service**

   ```rust
   pub struct TradingService {
       engine: TradingEngine,
       risk_manager: RiskManager,
       solana_client: SolanaClient,
   }
   ```

   - Trade execution
   - Position management
   - Risk validation
   - Transaction signing

3. **Agent Coordination Service**

   ```rust
   pub struct AgentCoordinator {
       agents: Vec<Box<dyn Agent>>,
       message_bus: MessageBus,
       state_manager: StateManager,
   }
   ```

   - Agent lifecycle management
   - Inter-agent communication
   - State synchronization
   - Performance monitoring

### Error Handling Patterns

1. **Database Errors**

   ```rust
   #[derive(Error, Debug)]
   pub enum DatabaseError {
       #[error("Connection failed: {0}")]
       ConnectionError(String),
       #[error("Query failed: {0}")]
       QueryError(String),
       #[error("Data validation failed: {0}")]
       ValidationError(String),
   }
   ```

   - Connection retry logic
   - Query timeout handling
   - Data integrity checks

2. **API Errors**

   ```rust
   #[derive(Error, Debug)]
   pub enum ApiError {
       #[error("Rate limit exceeded")]
       RateLimitError,
       #[error("Authentication failed: {0}")]
       AuthError(String),
       #[error("Request failed: {0}")]
       RequestError(String),
   }
   ```

   - Rate limiting
   - Authentication handling
   - Request retries

3. **Trading Errors**

   ```rust
   #[derive(Error, Debug)]
   pub enum TradingError {
       #[error("Insufficient funds: {0}")]
       InsufficientFunds(String),
       #[error("Invalid trade: {0}")]
       InvalidTrade(String),
       #[error("Execution failed: {0}")]
       ExecutionError(String),
   }
   ```

   - Position validation
   - Balance checks
   - Transaction verification

### Infrastructure Requirements

1. **Database**
   - PostgreSQL 15+ with TimescaleDB
   - Minimum 16GB RAM
   - SSD storage
   - Regular backups
   - Connection pooling

2. **Network**
   - Low latency connection
   - Redundant connectivity
   - DDoS protection
   - SSL/TLS encryption

3. **Compute**
   - Multi-core CPU
   - Minimum 32GB RAM
   - Load balancing
   - Auto-scaling

### Performance Requirements

1. **Latency Targets**

   ```rust
   pub struct PerformanceMetrics {
       trade_execution_ms: u64,    // Target: < 500ms
       market_data_refresh_ms: u64, // Target: < 1000ms
       signal_processing_ms: u64,   // Target: < 200ms
       db_query_ms: u64,           // Target: < 100ms
   }
   ```

2. **Throughput Requirements**
   - 1000+ market signals/second
   - 100+ trades/minute
   - 10000+ database operations/second
   - 100+ concurrent agents

3. **Resource Utilization**
   - CPU: < 70% sustained
   - Memory: < 80% usage
   - Disk I/O: < 70% utilization
   - Network: < 50% capacity

## Monitoring and Alerting

### System Health Monitoring

```rust
pub struct HealthCheck {
    pub service: String,
    pub status: Status,
    pub last_check: DateTime<Utc>,
    pub metrics: HashMap<String, f64>,
}
```

1. **Service Health**
   - API availability
   - Database connectivity
   - Agent status
   - Memory usage

2. **Performance Metrics**
   - Trade execution latency
   - Market data freshness
   - Database query performance
   - Network latency

3. **Business Metrics**
   - Trade success rate
   - Agent performance
   - Portfolio returns
   - Risk exposure

### Alert Thresholds

1. **Critical Alerts**
   - Trade execution failures
   - Database connectivity issues
   - API authentication errors
   - Memory exhaustion

2. **Warning Alerts**
   - High latency
   - Elevated error rates
   - Resource utilization
   - Rate limit warnings

3. **Information Alerts**
   - Agent state changes
   - Database maintenance
   - Performance optimization
   - System updates

## Recovery Procedures

### 1. Database Recovery

```sql
-- Point-in-time recovery
SELECT * FROM market_signals
WHERE timestamp >= '2025-01-30 00:00:00'
  AND timestamp < '2025-01-30 01:00:00';

-- Reprocess failed trades
SELECT * FROM trade_executions
WHERE status = 'FAILED'
  AND execution_time > now() - interval '1 hour';
```

### 2. Service Recovery

```rust
impl RecoveryManager {
    async fn recover_service(&self) -> Result<()> {
        // 1. Stop affected service
        // 2. Verify dependencies
        // 3. Restore state
        // 4. Restart service
        // 5. Verify operation
    }
}
```

### 3. Data Integrity

```rust
impl DataValidator {
    async fn validate_market_data(&self) -> Result<()> {
        // 1. Check data consistency
        // 2. Verify calculations
        // 3. Compare with backup sources
        // 4. Report discrepancies
    }
}
```

## Maintenance Procedures

### 1. Database Maintenance

- Daily backup verification
- Weekly index optimization
- Monthly data archival
- Quarterly performance review

### 2. System Updates

- Security patches
- Dependency updates
- Performance optimizations
- Feature deployments

### 3. Monitoring Updates

- Alert threshold adjustments
- Metric collection tuning
- Dashboard updates
- Log rotation
</file>

<file path="memory-bank/productContext.md">
# Product Context

Last Updated: 2025-02-12

## Core Problem

Building a decentralized network of autonomous AI trading agents for the $CAINAM token platform on Solana requires efficient market data analysis, semantic search capabilities, and coordinated agent decision-making while ensuring reliability, security, and performance.  We need a way to quickly find tokens based on semantic meaning, not just keywords.

## Key Components/Solutions

### 1. Vector Store & Market Analysis

**Problem:** Need efficient storage and semantic search of market data and token analytics
**Solution:**

- MongoDB Atlas vector store implementation
- Embedding-based similarity search using `rig-mongodb`
- Token analytics data storage and retrieval
- Efficient connection pooling and error handling

### 2. Agent Intelligence

**Problem:** Agents need to make informed decisions based on historical and real-time data
**Solution:**

- Vector-based similarity search for market patterns
- Semantic analysis of token characteristics
- Efficient data retrieval through MongoDB Atlas
- Scalable document storage and indexing

### 3. Data Management

**Problem:** Need efficient storage and retrieval of market data and embeddings
**Solution:**

- MongoDB Atlas for document storage
- Vector search capabilities for similarity matching
- Efficient connection pooling
- Proper error handling and retry logic

## Core Workflows

### 1. Token Analytics Processing

1. Token data collection and validation (from Birdeye, etc.)
2. Embedding generation for token characteristics (using OpenAI)
3. Storage in MongoDB with vector indexing
4. Efficient similarity search capabilities (using `rig-mongodb`)

### 2. Market Analysis

1. Real-time market data processing
2. Vector-based pattern recognition (future)
3. Similarity search for historical patterns
4. Decision making based on analysis (future)

### 3. Agent Operations

1. Continuous market monitoring
2. Vector-based similarity analysis
3. Pattern recognition and decision making (future)
4. Performance tracking and optimization

## Product Direction

### Phase 1: Vector Store Implementation (Current)

- MongoDB Atlas integration
- Vector search capabilities using `rig-mongodb`
- Token analytics storage
- Connection pooling and error handling

### Phase 2: Agent Intelligence (Next)

- Enhanced market analysis
- Pattern recognition
- Decision making logic
- Performance optimization

### Phase 3: Advanced Features (Future)

- Advanced similarity search
- Multi-dimensional analysis
- Enhanced error handling
- Performance monitoring

## Development Priorities

1. **Immediate Focus**
   - Complete MongoDB vector store implementation using `rig-mongodb`
   - Ensure correct generic type usage with `rig-mongodb`
   - Implement comprehensive error handling
   - Add proper logging and monitoring

2. **Short-term Goals**
   - Enhanced vector search capabilities
   - Agent integration with vector store
   - Performance optimization
   - Testing infrastructure

3. **Medium-term Goals**
   - Advanced pattern recognition
   - Enhanced decision making
   - System scalability
   - Advanced monitoring

## Success Metrics

- Vector search accuracy and speed
- System reliability and uptime
- Query performance and latency
- Error handling effectiveness
- Connection pool efficiency
</file>

<file path="memory-bank/projectBoundaries.md">
# Project Boundaries

Last Updated: 2025-01-30

## Technical Constraints

### 1. Performance Boundaries

#### Latency Requirements

- Trade execution: < 500ms end-to-end
- Market data updates: < 1s refresh rate
- Signal processing: < 200ms
- Database queries: < 100ms response time

#### Throughput Limits

- Maximum 100 concurrent agents
- Up to 1000 market signals per second
- Maximum 100 trades per minute
- Up to 10000 database operations per second

#### Resource Constraints

- Memory usage: < 32GB per instance
- CPU utilization: < 70% sustained
- Network bandwidth: < 1Gbps
- Storage: < 1TB active data

### 2. API Limitations

#### Birdeye API

- Rate limit: 10 requests/second
- Websocket connections: 5 max
- Data freshness: 1s minimum
- Historical data: 90 days

#### Helius API

- Webhook delivery: Best effort
- Transaction history: 30 days
- Rate limit: 100 requests/second
- Concurrent connections: 10 max

#### Solana RPC

- Transaction confirmation: 2-4s
- Rate limit: 40 requests/second
- Connection limit: 20 per IP
- Data size: 5MB max per request

### 3. Database Constraints

#### TimescaleDB

- Chunk interval: 1 day
- Retention period: 1 year
- Compression ratio: 10:1 target
- Query complexity: < 1000 rows scan

#### Qdrant

- Vector dimensions: 1536 max
- Index size: 1M vectors
- Query time: < 50ms
- Similarity threshold: 0.8

## Scale Requirements

### 1. Data Volume

```rust
pub struct DataVolume {
    market_signals_per_day: u64,    // 86_400_000
    trades_per_day: u64,            // 144_000
    token_analytics_per_day: u64,   // 2_160_000
    agent_metrics_per_day: u64,     // 144_000
}
```

### 2. System Scale

```rust
pub struct SystemScale {
    concurrent_agents: u32,         // 100
    active_markets: u32,            // 1000
    monitored_tokens: u32,          // 10000
    trading_pairs: u32,             // 100
}
```

### 3. Storage Requirements

```rust
pub struct StorageRequirements {
    market_data_per_day: u64,      // 10GB
    trade_data_per_day: u64,       // 1GB
    analytics_per_day: u64,        // 5GB
    log_data_per_day: u64,         // 2GB
}
```

## Hard Limitations

### 1. Trading Restrictions

```rust
pub struct TradingLimits {
    max_position_size: f64,        // 5% of portfolio
    min_trade_size: f64,           // $10 equivalent
    max_trades_per_minute: u32,    // 100
    max_slippage: f64,             // 1%
}
```

### 2. Risk Management

```rust
pub struct RiskLimits {
    max_portfolio_exposure: f64,    // 20%
    max_correlation: f64,           // 0.7
    min_confidence: f64,           // 0.8
    max_drawdown: f64,             // 10%
}
```

### 3. Technical Limits

```rust
pub struct TechnicalLimits {
    max_concurrent_requests: u32,   // 1000
    max_websocket_connections: u32, // 100
    max_database_connections: u32,  // 500
    max_memory_usage: u64,         // 32GB
}
```

## Non-Negotiables

### 1. Security Requirements

- All private keys must be securely stored
- All API communications must be encrypted
- Rate limiting must be enforced
- Access control for all operations

### 2. Data Integrity

- All trades must be verified
- Market data must be validated
- Database consistency must be maintained
- Audit trail for all operations

### 3. Reliability

- No single point of failure
- Automatic failover required
- Data backup mandatory
- Error recovery procedures required

## Future Considerations

### 1. Scalability

- Horizontal scaling of agents
- Distributed database deployment
- Load balancing implementation
- Cache layer addition

### 2. Feature Expansion

- Cross-chain integration
- Advanced analytics
- Machine learning models
- Social sentiment analysis

### 3. Performance Optimization

- Query optimization
- Caching strategies
- Network optimization
- Resource allocation

## Compliance Requirements

### 1. Data Retention

- Trade records: 7 years
- Market data: 1 year
- System logs: 90 days
- Error reports: 1 year

### 2. Audit Requirements

- All trades must be traceable
- Risk checks must be documented
- System changes must be logged
- Performance metrics must be stored

### 3. Reporting Requirements

- Daily performance reports
- Risk exposure analysis
- System health metrics
- Compliance verification
</file>

<file path="memory-bank/projectbrief.md">
# Project Brief

**Project Name:** Cainam Core Agent

**Last Updated:** 2025-02-12

**Objective:** Develop a decentralized network of autonomous AI trading agents for the $CAINAM token platform on Solana, focusing on efficient market data analysis, semantic search, and coordinated decision-making.

**Core Requirements:**

1. **Market Data Analysis:**
    * Real-time and historical market data processing.
    * Efficient semantic search capabilities for token analytics.
    * Market pattern recognition and signal generation.

2. **Autonomous Trading Agents:**
    * Intelligent decision-making based on market data and analysis.
    * Coordinated trading strategies.
    * Risk management and portfolio optimization.

3. **Decentralized Network:**
    * Agent communication and coordination.
    * Secure and reliable operation.
    * Scalability to support multiple agents and markets.

4. **Technical Foundation:**
    * Integration with Solana blockchain.
    * Utilization of MongoDB Atlas for vector storage and search.
    * Robust error handling and performance optimization.

**Success Criteria:**

* Accurate and efficient market data analysis.
* Reliable vector search capabilities.
* Functional autonomous trading agents.
* Secure and scalable decentralized network.
* Comprehensive error handling and monitoring.
</file>

<file path="memory-bank/techContext.md">
# Technical Context

## Vector Store Implementation

### MongoDB Atlas Setup

- Enabled Atlas Search for vector similarity search capabilities
- Created token_analytics collection with document structure for embeddings
- Implemented vector search index for efficient similarity search using cosine distance
- Added vector store integration with proper connection pooling

### Database Schema

The vector store implementation uses the following document structure:

```json
{
    "_id": ObjectId,
    "token_address": String,
    "token_name": String,
    "token_symbol": String,
    "embedding": Array<float>,
    "created_at": ISODate
}
```

### Search Configuration

Implemented MongoDB vector search with:

- Vector search index on embedding field
- Cosine similarity for distance calculation
- Configurable search parameters:
  - Exact matching option
  - Number of candidates
  - Field specification for embedding search

### Integration Notes

- Using OpenAI's text-embedding-3-small model (1536 dimensions)
- Configured with MongoDB Atlas Search for vector similarity
- Supports batch document insertion
- Includes proper connection pooling
- Implements retry logic for operations

### Current Implementation

1. MongoDB Connection Pool
   - Configurable min/max pool size
   - Connection timeout settings
   - Error handling for connection issues

2. Vector Store Operations
   - Document insertion with embeddings
   - Vector similarity search
   - Top-N query support
   - Proper error handling

3. Data Models
   - TokenAnalyticsData structure
   - Proper serialization/deserialization
   - ObjectId handling
   - Embedding field management

### Error Handling

- Comprehensive error types for MongoDB operations
- Connection error handling
- Vector store operation error handling
- Proper error propagation
- Logging integration with tracing

### Pending Improvements

1. SearchParams configuration refinement
2. Enhanced error context for vector operations
3. Additional logging for debugging
4. Performance optimization for batch operations
5. Connection pool monitoring
</file>

<file path="migrations/01_initial_schema.sql">
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS timescaledb;
-- Create enum types
CREATE TYPE trade_status AS ENUM ('PENDING', 'EXECUTED', 'FAILED', 'CANCELLED');
CREATE TYPE signal_type AS ENUM ('BUY', 'SELL', 'HOLD', 'STRONG_BUY', 'STRONG_SELL', 'PRICE_SPIKE', 'PRICE_DROP', 'VOLUME_SURGE');
-- Market Signals
CREATE TABLE market_signals (
    id SERIAL,
    asset_address VARCHAR NOT NULL,
    signal_type VARCHAR NOT NULL,
    confidence DECIMAL NOT NULL,
    risk_score DECIMAL NOT NULL,
    sentiment_score DECIMAL,
    volume_change_24h DECIMAL,
    price_change_24h DECIMAL,
    timestamp TIMESTAMPTZ NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id, timestamp)
);
-- Trade Executions
CREATE TABLE trade_executions (
    id UUID DEFAULT gen_random_uuid(),
    signal_id INTEGER,
    signal_timestamp TIMESTAMPTZ,
    asset_address TEXT NOT NULL,
    size DECIMAL NOT NULL,
    entry_price DECIMAL NOT NULL,
    slippage DECIMAL NOT NULL,
    execution_time TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL,
    transaction_signature TEXT,
    fee_amount DECIMAL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (id, execution_time)
);
-- Agent Performance Metrics
CREATE TABLE agent_performance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_type TEXT NOT NULL,
    accuracy DECIMAL NOT NULL,
    total_signals INTEGER NOT NULL,
    successful_trades INTEGER NOT NULL,
    evaluation_period TSTZRANGE NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
-- Token Analytics
CREATE TABLE token_analytics (
    id UUID DEFAULT gen_random_uuid(),
    token_address TEXT NOT NULL,
    token_name TEXT NOT NULL,
    token_symbol TEXT NOT NULL,
    price DECIMAL NOT NULL,
    volume_24h DECIMAL,
    market_cap DECIMAL,
    total_supply DECIMAL,
    holder_count INTEGER,
    metadata JSONB DEFAULT '{}',
    timestamp TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id, timestamp)
);
-- Create hypertables
SELECT create_hypertable('market_signals', 'timestamp', 
    chunk_time_interval => INTERVAL '1 day',
    if_not_exists => TRUE,
    migrate_data => TRUE
);
SELECT create_hypertable('trade_executions', 'execution_time',
    chunk_time_interval => INTERVAL '1 day',
    if_not_exists => TRUE,
    migrate_data => TRUE
);
SELECT create_hypertable('token_analytics', 'timestamp',
    chunk_time_interval => INTERVAL '1 hour',
    if_not_exists => TRUE,
    migrate_data => TRUE
);
-- Create indexes
CREATE INDEX idx_market_signals_asset_time ON market_signals(asset_address, timestamp);
CREATE INDEX idx_trade_executions_asset_time ON trade_executions(asset_address, execution_time);
CREATE INDEX idx_token_analytics_address_time ON token_analytics(token_address, timestamp);
-- Enable compression for market signals
ALTER TABLE market_signals SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'asset_address,signal_type',
    timescaledb.compress_orderby = 'timestamp'
);
-- Enable compression for trade executions
ALTER TABLE trade_executions SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'asset_address,status',
    timescaledb.compress_orderby = 'execution_time'
);
-- Enable compression for token analytics
ALTER TABLE token_analytics SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'token_address',
    timescaledb.compress_orderby = 'timestamp'
);
-- Create compression policies
SELECT add_compression_policy('market_signals', INTERVAL '7 days');
SELECT add_compression_policy('trade_executions', INTERVAL '7 days');
SELECT add_compression_policy('token_analytics', INTERVAL '7 days');
-- Add retention policies
SELECT add_retention_policy('market_signals', INTERVAL '1 year');
SELECT add_retention_policy('trade_executions', INTERVAL '1 year');
SELECT add_retention_policy('token_analytics', INTERVAL '1 year');
</file>

<file path="migrations/01_mongodb_setup.rs">
use crate::config::mongodb::{MongoConfig, MongoDbPool};
use anyhow::Result;
use rig_mongodb::{bson::doc, MongoDbPool};
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    info!("Starting MongoDB migrations...");
    // Use migration-specific configuration
    let config = MongoConfig {
        pool: MongoPoolConfig {
            min_pool_size: 1,
            max_pool_size: 2,
            connect_timeout: std::time::Duration::from_secs(30),
        },
        ..MongoConfig::from_env()
    };
    let pool = config.create_pool().await?;
    let db = pool.database(&config.database);
    info!("Creating collections and indexes...");
    // Token analytics collection
    db.create_collection("token_analytics", None).await?;
    db.collection("token_analytics")
        .create_index(
            doc! {
                "token_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    // Market signals collection
    db.create_collection("market_signals", None).await?;
    db.collection("market_signals")
        .create_index(
            doc! {
                "asset_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    // Vector store collection with improved search configuration
    db.create_collection("vectors", None).await?;
    db.collection("vectors")
        .create_index(
            doc! {
                "vector": "2dsphere",
                "metadata.timestamp": -1,
                "weights": {
                    "vector": 1,
                    "metadata.timestamp": 1
                },
                "name": "vector_search_idx",
                "background": true
            },
            None,
        )
        .await?;
    // Trade history collection
    db.create_collection("trade_history", None).await?;
    db.collection("trade_history")
        .create_index(
            doc! {
                "trader_address": 1,
                "timestamp": -1,
                "status": 1
            },
            None,
        )
        .await?;
    // Risk models collection
    db.create_collection("risk_models", None).await?;
    db.collection("risk_models")
        .create_index(
            doc! {
                "model_type": 1,
                "asset_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    // Portfolio allocations collection
    db.create_collection("portfolio_allocations", None).await?;
    db.collection("portfolio_allocations")
        .create_index(
            doc! {
                "wallet_address": 1,
                "token_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    info!("MongoDB migrations completed successfully!");
    Ok(())
}
</file>

<file path="migrations/02_mongodb_schema.rs">
use crate::config::mongodb::MongoConfig;
use anyhow::Result;
use rig_mongodb::{bson::doc, MongoDbPool};
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    info!("Running MongoDB schema migration...");
    let config = MongoConfig::from_env();
    let pool = config.create_pool().await?;
    let db = pool.database(&config.database);
    // Create market signals collection with timeseries optimization
    db.create_collection(
        "market_signals",
        Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "asset_address",
                "granularity": "minutes"
            },
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["asset_address", "signal_type", "confidence", "timestamp"],
                    "properties": {
                        "asset_address": { "bsonType": "string" },
                        "signal_type": {
                            "enum": ["BUY", "SELL", "HOLD", "STRONG_BUY", "STRONG_SELL",
                                    "PRICE_SPIKE", "PRICE_DROP", "VOLUME_SURGE"]
                        },
                        "confidence": { "bsonType": "decimal128" },
                        "price_change_24h": { "bsonType": "decimal128" },
                        "volume_change_24h": { "bsonType": "decimal128" },
                        "risk_score": { "bsonType": "decimal128" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create trade executions collection with timeseries
    db.create_collection(
        "trade_executions",
        Some(doc! {
            "timeseries": {
                "timeField": "execution_time",
                "metaField": "asset_address",
                "granularity": "minutes"
            },
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["asset_address", "amount", "price", "status", "execution_time"],
                    "properties": {
                        "asset_address": { "bsonType": "string" },
                        "amount": { "bsonType": "decimal128" },
                        "price": { "bsonType": "decimal128" },
                        "status": {
                            "enum": ["PENDING", "EXECUTED", "FAILED", "CANCELLED"]
                        },
                        "tx_signature": { "bsonType": "string" },
                        "metadata": { "bsonType": "object" },
                        "execution_time": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create token analytics collection with timeseries
    db.create_collection(
        "token_analytics",
        Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "token_address",
                "granularity": "minutes"
            },
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["token_address", "token_name", "price", "timestamp"],
                    "properties": {
                        "token_address": { "bsonType": "string" },
                        "token_name": { "bsonType": "string" },
                        "token_symbol": { "bsonType": "string" },
                        "price": { "bsonType": "decimal128" },
                        "volume_24h": { "bsonType": "decimal128" },
                        "market_cap": { "bsonType": "decimal128" },
                        "holder_count": { "bsonType": "int" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create agent performance collection
    db.create_collection(
        "agent_performance",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["period_start", "period_end", "total_trades", "success_rate"],
                    "properties": {
                        "period_start": { "bsonType": "date" },
                        "period_end": { "bsonType": "date" },
                        "total_trades": { "bsonType": "int" },
                        "success_rate": { "bsonType": "decimal128" },
                        "pnl": { "bsonType": "decimal128" },
                        "metadata": { "bsonType": "object" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create test collections with timeseries optimization
    db.create_collection(
        "test_market_signals",
        Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "asset_address",
                "granularity": "minutes"
            },
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["asset_address", "signal_type", "confidence", "timestamp"],
                    "properties": {
                        "asset_address": { "bsonType": "string" },
                        "signal_type": {
                            "enum": ["BUY", "SELL", "HOLD", "STRONG_BUY", "STRONG_SELL",
                                    "PRICE_SPIKE", "PRICE_DROP", "VOLUME_SURGE"]
                        },
                        "confidence": { "bsonType": "decimal128" },
                        "price_change_24h": { "bsonType": "decimal128" },
                        "volume_change_24h": { "bsonType": "decimal128" },
                        "risk_score": { "bsonType": "decimal128" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create trade executions collection
    db.create_collection(
        "test_trade_executions",
        Some(doc! {
            "timeseries": {
                "timeField": "execution_time",
                "metaField": "asset_address",
                "granularity": "minutes"
            }
        }),
    )
    .await?;
    // Create time-based indexes for efficient querying
    db.collection("market_signals")
        .create_index(
            doc! {
                "asset_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    db.collection("trade_executions")
        .create_index(
            doc! {
                "asset_address": 1,
                "execution_time": -1
            },
            None,
        )
        .await?;
    db.collection("token_analytics")
        .create_index(
            doc! {
                "token_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    info!("MongoDB schema migration completed successfully!");
    Ok(())
}
</file>

<file path="migrations/02_trade_status.sql">
-- migrations/02_trade_status.sql
-- Drop trade_status type if exists and create custom ENUM type for trade_status
DROP TYPE IF EXISTS trade_status CASCADE;
CREATE TYPE trade_status AS ENUM (
    'open',
    'closed',
    'pending',
    'executed',
    'cancelled'
);
</file>

<file path="migrations/03_mongodb_trade_status.rs">
use crate::config::mongodb::MongoConfig;
use anyhow::Result;
use rig_mongodb::{bson::doc, MongoDbPool};
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    info!("Running trade status migration...");
    let config = MongoConfig::from_env();
    let pool = config.create_pool().await?;
    let db = pool.database(&config.database);
    // Create trade_history collection with status validation
    db.create_collection(
        "trade_history",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["trade_id", "status", "updated_at"],
                    "properties": {
                        "trade_id": { "bsonType": "string" },
                        "status": {
                            "enum": [
                                "initiated",
                                "pending",
                                "completed",
                                "failed",
                                "cancelled",
                                "timeout"
                            ]
                        },
                        "updated_at": { "bsonType": "date" },
                        "error": { "bsonType": "string" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create indexes for efficient status tracking
    db.collection("trade_history")
        .create_index(
            doc! {
                "trade_id": 1,
                "updated_at": -1
            },
            None,
        )
        .await?;
    db.collection("trade_history")
        .create_index(
            doc! {
                "status": 1,
                "updated_at": -1
            },
            None,
        )
        .await?;
    info!("Trade status migration completed successfully!");
    Ok(())
}
</file>

<file path="migrations/03_position_allocations.sql">
CREATE TABLE IF NOT EXISTS position_allocations (
    id SERIAL PRIMARY KEY,
    token_address TEXT NOT NULL,
    allocation NUMERIC NOT NULL DEFAULT 0.0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS position_allocations_token_address_idx ON position_allocations(token_address);
</file>

<file path="migrations/04_mongodb_allocations.rs">
use crate::config::mongodb::MongoConfig;
use anyhow::Result;
use rig_mongodb::{bson::doc, MongoDbPool};
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    info!("Running position allocations migration...");
    let config = MongoConfig::from_env();
    let pool = config.create_pool().await?;
    let db = pool.database(&config.database);
    // Create portfolio_allocations collection with validation
    db.create_collection("portfolio_allocations", Some(doc! {
        "validator": {
            "$jsonSchema": {
                "bsonType": "object",
                "required": ["wallet_address", "token_address", "allocation_weight", "timestamp"],
                "properties": {
                    "wallet_address": { "bsonType": "string" },
                    "token_address": { "bsonType": "string" },
                    "allocation_weight": { "bsonType": "decimal128" },
                    "target_weight": { "bsonType": "decimal128" },
                    "min_weight": { "bsonType": "decimal128" },
                    "max_weight": { "bsonType": "decimal128" },
                    "last_rebalance": { "bsonType": "date" },
                    "timestamp": { "bsonType": "date" }
                }
            }
        }
    })).await?;
    // Create indexes for efficient allocation lookups
    db.collection("portfolio_allocations")
        .create_index(
            doc! {
                "wallet_address": 1,
                "token_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    // Create rebalance_history collection
    db.create_collection("rebalance_history", Some(doc! {
        "validator": {
            "$jsonSchema": {
                "bsonType": "object",
                "required": ["wallet_address", "token_address", "old_weight", "new_weight", "timestamp"],
                "properties": {
                    "wallet_address": { "bsonType": "string" },
                    "token_address": { "bsonType": "string" },
                    "old_weight": { "bsonType": "decimal128" },
                    "new_weight": { "bsonType": "decimal128" },
                    "reason": { "bsonType": "string" },
                    "timestamp": { "bsonType": "date" }
                }
            }
        }
    })).await?;
    // Create indexes for rebalance history
    db.collection("rebalance_history")
        .create_index(
            doc! {
                "wallet_address": 1,
                "timestamp": -1
            },
            None,
        )
        .await?;
    info!("Position allocations migration completed successfully!");
    Ok(())
}
</file>

<file path="migrations/04_vector_store.sql">
-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;
-- Create documents table for vector store
CREATE TABLE IF NOT EXISTS documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    embedding vector(1536), -- Using 1536 dimensions for OpenAI embeddings
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
-- Create index for vector similarity search
CREATE INDEX IF NOT EXISTS documents_embedding_idx ON documents 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
-- Create function to perform vector similarity search
CREATE OR REPLACE FUNCTION vector_similarity_search(
    query_embedding vector,
    match_threshold float,
    match_count int
)
RETURNS TABLE (
    id UUID,
    content TEXT,
    metadata JSONB,
    similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        d.id,
        d.content,
        d.metadata,
        1 - (d.embedding <=> query_embedding) as similarity
    FROM documents d
    WHERE 1 - (d.embedding <=> query_embedding) > match_threshold
    ORDER BY d.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;
</file>

<file path="migrations/05_init_vector_store.sql">
-- ensure PgVector extension is installed
CREATE EXTENSION IF NOT EXISTS vector;
-- Create table for market data
CREATE TABLE market_data (
  id uuid DEFAULT gen_random_uuid(),
  document jsonb NOT NULL,
  embedded_text text NOT NULL,
  embedding vector(1536)
);
-- Create table for trade history
CREATE TABLE trade_history (
  id uuid DEFAULT gen_random_uuid(),
  document jsonb NOT NULL,
  embedded_text text NOT NULL,
  embedding vector(1536)
);
-- Create table for risk models
CREATE TABLE risk_models (
  id uuid DEFAULT gen_random_uuid(),
  document jsonb NOT NULL,
  embedded_text text NOT NULL,
  embedding vector(1536)
);
-- Create table for sentiment analysis
CREATE TABLE sentiment_analysis (
  id uuid DEFAULT gen_random_uuid(),
  document jsonb NOT NULL,
  embedded_text text NOT NULL,
  embedding vector(1536)
);
-- Create HNSW indexes for cosine similarity search
CREATE INDEX IF NOT EXISTS market_data_embeddings_idx ON market_data
USING hnsw(embedding vector_cosine_ops);
CREATE INDEX IF NOT EXISTS trade_history_embeddings_idx ON trade_history
USING hnsw(embedding vector_cosine_ops);
CREATE INDEX IF NOT EXISTS risk_models_embeddings_idx ON risk_models
USING hnsw(embedding vector_cosine_ops);
CREATE INDEX IF NOT EXISTS sentiment_analysis_embeddings_idx ON sentiment_analysis
USING hnsw(embedding vector_cosine_ops);
</file>

<file path="migrations/05_mongodb_vector_store.rs">
use crate::config::mongodb::MongoConfig;
use anyhow::Result;
use rig_mongodb::{bson::doc, MongoDbPool};
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenvy::dotenv().ok();
    info!("Running vector store migration...");
    let config = MongoConfig::from_env();
    let pool = config.create_pool().await?;
    let db = pool.database(&config.database);
    // Create vector collections with proper schemas for different embedding types
    // Market data vectors
    db.create_collection(
        "market_data_vectors",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["document", "embedding", "timestamp"],
                    "properties": {
                        "document": { "bsonType": "object" },
                        "embedding": { "bsonType": "array" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Trade history vectors
    db.create_collection(
        "trade_history_vectors",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["document", "embedding", "timestamp"],
                    "properties": {
                        "document": { "bsonType": "object" },
                        "embedding": { "bsonType": "array" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Risk model vectors
    db.create_collection(
        "risk_model_vectors",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["document", "embedding", "timestamp"],
                    "properties": {
                        "document": { "bsonType": "object" },
                        "embedding": { "bsonType": "array" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Sentiment analysis vectors
    db.create_collection(
        "sentiment_vectors",
        Some(doc! {
            "validator": {
                "$jsonSchema": {
                    "bsonType": "object",
                    "required": ["document", "embedding", "timestamp"],
                    "properties": {
                        "document": { "bsonType": "object" },
                        "embedding": { "bsonType": "array" },
                        "metadata": { "bsonType": "object" },
                        "timestamp": { "bsonType": "date" }
                    }
                }
            }
        }),
    )
    .await?;
    // Create vector search indexes for each collection
    let vector_search_options = doc! {
        "numDimensions": 1536,  // OpenAI embedding dimensions
        "similarity": "cosine"
    };
    // Market data vectors index
    db.run_command(
        doc! {
            "createSearchIndex": "market_data_vectors",
            "definition": {
                "mappings": {
                    "dynamic": true,
                    "fields": {
                        "embedding": {
                            "type": "knnVector",
                            "dimensions": 1536,
                            "similarity": "cosine"
                        },
                        "timestamp": { "type": "date" }
                    }
                }
            }
        },
        None,
    )
    .await?;
    // Trade history vectors index
    db.run_command(
        doc! {
            "createSearchIndex": "trade_history_vectors",
            "definition": {
                "mappings": {
                    "dynamic": true,
                    "fields": {
                        "embedding": {
                            "type": "knnVector",
                            "dimensions": 1536,
                            "similarity": "cosine"
                        },
                        "timestamp": { "type": "date" }
                    }
                }
            }
        },
        None,
    )
    .await?;
    // Risk model vectors index
    db.run_command(
        doc! {
            "createSearchIndex": "risk_model_vectors",
            "definition": {
                "mappings": {
                    "dynamic": true,
                    "fields": {
                        "embedding": {
                            "type": "knnVector",
                            "dimensions": 1536,
                            "similarity": "cosine"
                        },
                        "timestamp": { "type": "date" }
                    }
                }
            }
        },
        None,
    )
    .await?;
    // Sentiment vectors index
    db.run_command(
        doc! {
            "createSearchIndex": "sentiment_vectors",
            "definition": {
                "mappings": {
                    "dynamic": true,
                    "fields": {
                        "embedding": {
                            "type": "knnVector",
                            "dimensions": 1536,
                            "similarity": "cosine"
                        },
                        "timestamp": { "type": "date" }
                    }
                }
            }
        },
        None,
    )
    .await?;
    // Create regular indexes for metadata filtering
    for collection in [
        "market_data_vectors",
        "trade_history_vectors",
        "risk_model_vectors",
        "sentiment_vectors",
    ]
    .iter()
    {
        db.collection(collection)
            .create_index(
                doc! {
                    "metadata.token_address": 1,
                    "timestamp": -1
                },
                None,
            )
            .await?;
    }
    info!("Vector store migration completed successfully!");
    Ok(())
}
</file>

<file path="scripts/capture_market_data.rs">
use cainam_core::{
    config::mongodb::{MongoConfig, MongoDbPool, MongoPoolConfig},
    services::TokenAnalyticsService,
    birdeye::api::BirdeyeClient,
    error::{AgentError, AgentResult},
};
use std::sync::Arc;
use std::env;
use tokio;
use tracing::{info, error, Level};
use dotenvy::dotenv;
const MARKET_TOKENS_ENV: &str = "MARKET_TOKENS";
#[tokio::main]
async fn main() -> AgentResult<()> {
    // Initialize tracing with a more visible format
    tracing_subscriber::fmt()
        .with_max_level(Level::INFO)
        .with_target(false)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();
    println!("Starting market data capture...");
    // Load environment variables
    dotenv().ok();
    // Get MongoDB connection details
    let mongodb_uri = env::var("MONGODB_URI").expect("MONGODB_URI must be set");
    let mongodb_database = env::var("MONGODB_DATABASE").expect("MONGODB_DATABASE must be set");
    // Initialize MongoDB connection
    let config = MongoConfig {
        uri: mongodb_uri.clone(),
        database: mongodb_database.clone(),
        app_name: Some("market-data-capture".to_string()),
        pool_config: MongoPoolConfig::default(),
    };
    let db_pool = MongoDbPool::create_pool(config).await.map_err(|e| AgentError::Other(e.into()))?;
    info!("Connected to MongoDB at {}", mongodb_uri);
    // Initialize Birdeye client
    let birdeye_api_key = env::var("BIRDEYE_API_KEY").expect("BIRDEYE_API_KEY must be set");
    let birdeye_client = Arc::new(BirdeyeClient::new(birdeye_api_key));
    info!("Initialized Birdeye client");
    // Initialize analytics service
    let analytics_service = TokenAnalyticsService::new(db_pool, birdeye_client.clone(), None).await?;
    info!("Initialized analytics service");
    // Get market tokens from environment
    let market_tokens = env::var(MARKET_TOKENS_ENV)
        .expect("MARKET_TOKENS must be set")
        .split(',')
        .map(|pair| {
            let parts: Vec<&str> = pair.split(':').collect();
            if parts.len() != 2 {
                panic!("Invalid market token format. Expected FORMAT: SYMBOL:ADDRESS");
            }
            (parts[0].to_string(), parts[1].to_string())
        })
        .collect::<Vec<_>>();
    info!("Processing {} market tokens", market_tokens.len());
    // Process each token
    for (symbol, address) in market_tokens {
        info!("Processing token: {} ({})", symbol, address);
        match analytics_service.fetch_and_store_token_info(&symbol, &address).await {
            Ok(analytics) => {
                info!(
                    "Successfully captured data for {}: price=${:.4}, volume=${:.2}",
                    symbol,
                    analytics.price,
                    analytics.volume_24h.unwrap_or_default()
                );
            }
            Err(e) => {
                error!("Failed to capture data for {}: {}", symbol, e);
                // Continue with next token instead of stopping
                continue;
            }
        }
    }
    info!("Market data capture completed");
    Ok(())
}
</file>

<file path="scripts/init_mongodb.rs">
use rig_mongodb::{MongoDbPool, bson::doc, options::ClientOptions};
use anyhow::Result;
use tracing::info;
#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    let mongodb_uri = std::env::var("MONGODB_URI").expect("MONGODB_URI must be set");
    info!("Connecting to MongoDB...");
    let client_options = ClientOptions::parse(&mongodb_uri).await?;
    let pool = MongoDbPool::new_with_options(&mongodb_uri, client_options).await?;
    let db = pool.database("cainam");
    info!("Creating collections and indexes...");
    // Create token_analytics collection with indexes
    db.create_collection("token_analytics", None).await?;
    db.collection("token_analytics").create_index(
        doc! {
            "token_address": 1,
            "timestamp": -1
        },
        None,
    ).await?;
    // Create market_signals collection with indexes
    db.create_collection("market_signals", None).await?;
    db.collection("market_signals").create_index(
        doc! {
            "asset_address": 1,
            "timestamp": -1
        },
        None,
    ).await?;
    // Create vector_store collection with indexes
    db.create_collection("vectors", None).await?;
    db.collection("vectors").create_index(
        doc! {
            "vector": "2dsphere",
            "metadata.timestamp": -1
        },
        None,
    ).await?;
    info!("MongoDB setup completed successfully!");
    Ok(())
}
</file>

<file path="scripts/init_vector_store.rs">
use anyhow::Result;
use cainam_core::config::mongodb::MongoConfig;
use mongodb::bson::Document;
use mongodb::{bson::doc, Client, IndexModel};
use tracing::info;
use tracing_subscriber::fmt;
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    fmt()
        .with_target(false)
        .with_thread_ids(false)
        .with_thread_names(false)
        .with_file(true)
        .with_line_number(true)
        .init();
    // Load environment variables
    dotenvy::dotenv().ok();
    info!("Initializing vector store...");
    // Initialize MongoDB connection
    let config = MongoConfig::from_env();
    let uri = std::env::var("MONGODB_URI").expect("MONGODB_URI must be set");
    let client = Client::with_uri_str(&uri).await?;
    let db = client.database(&config.database);
    // Create token_analytics collection
    info!("Creating token_analytics collection...");
    match db.create_collection("token_analytics").await {
        Ok(_) => info!("Created token_analytics collection"),
        Err(e) if e.to_string().contains("already exists") => {
            info!("Collection token_analytics already exists")
        }
        Err(e) => return Err(e.into()),
    }
    // Create metadata index for token_analytics
    info!("Creating metadata index for token_analytics...");
    let metadata_index = doc! {
        "metadata": 1
    };
    match db
        .collection::<Document>("token_analytics")
        .create_index(IndexModel::builder().keys(metadata_index).build())
        .await
    {
        Ok(_) => info!("Created metadata index for token_analytics"),
        Err(e) if e.to_string().contains("already exists") => {
            info!("Metadata index already exists for token_analytics")
        }
        Err(e) => return Err(e.into()),
    }
    // Create metadata index for market_signals
    info!("Creating metadata index for market_signals...");
    let index_model = IndexModel::builder()
        .keys(doc! {
            "asset_address": 1,
            "timestamp": -1
        })
        .build();
    let collection = db.collection::<Document>("market_signals");
    match collection.create_index(index_model).await {
        Ok(_) => info!("Created metadata index for market_signals"),
        Err(e) if e.to_string().contains("already exists") => {
            info!("Metadata index for market_signals already exists")
        }
        Err(e) => return Err(e.into()),
    }
    info!("Vector store initialization complete");
    Ok(())
}
</file>

<file path="scripts/run_agent.rs">
use anyhow::Result;
use cainam_core::{
    agent::trader::TradingAgent,
    config::mongodb::MongoDbPool,
    config::{mongodb::MongoConfig, AgentConfig},
    trading::SolanaAgentKit,
};
use dotenvy::dotenv;
use tracing::{info, Level};
#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables
    dotenv().ok();
    // Initialize logging
    tracing_subscriber::fmt().with_max_level(Level::INFO).init();
    info!("Starting Cainam Trading Agent...");
    // Load configuration
    let agent_config = AgentConfig::new_from_env()?;
    let mongo_config = MongoConfig::from_env();
    // Initialize MongoDB connection
    let db = MongoDbPool::create_pool(mongo_config).await?;
    // Initialize Solana agent kit
    let solana_agent = SolanaAgentKit::new_from_env()?;
    // Create and run the trading agent
    let agent = TradingAgent::new(agent_config, db, solana_agent).await?;
    info!("Agent initialized successfully. Starting main loop...");
    agent.run().await?;
    Ok(())
}
</file>

<file path="scripts/run_migrations.rs">
use anyhow::Result;
use tracing::info;
use crate::config::mongodb::MongoConfig;
mod mongodb {
    pub mod m01_setup;
    pub mod m02_schema;
    pub mod m03_trade_status;
    pub mod m04_allocations;
    pub mod m05_vector_store;
}
#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    info!("Starting migrations...");
    // Initialize MongoDB configuration
    let config = MongoConfig::from_env();
    // Run MongoDB migrations in order
    info!("Running MongoDB migrations...");
    mongodb::m01_setup::run(&config).await?;
    mongodb::m02_schema::run(&config).await?;
    mongodb::m03_trade_status::run(&config).await?;
    mongodb::m04_allocations::run(&config).await?;
    mongodb::m05_vector_store::run(&config).await?;
    info!("All migrations completed successfully!");
    Ok(())
}
</file>

<file path="scripts/setup_mongodb.rs">
use cainam_core::config::mongodb::MongoConfig;
use mongodb::{
    bson::Document,
    options::{ClientOptions, IndexOptions},
    Client, IndexModel,
};
use std::error::Error;
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Load environment variables first
    dotenvy::dotenv().ok();
    // Initialize MongoDB client using configuration
    let config = MongoConfig::from_env();
    let mut client_options = ClientOptions::parse(&config.uri).await?;
    client_options.server_api = Some(
        mongodb::options::ServerApi::builder()
            .version(mongodb::options::ServerApiVersion::V1)
            .build(),
    );
    let client = Client::with_options(client_options)?;
    let db = client.database(&config.database);
    println!("Connected to MongoDB successfully");
    // Create collections if they don't exist
    println!("Creating collections...");
    let collections = db.list_collection_names().await?;
    if !collections.contains(&"token_analytics".to_string()) {
        db.create_collection("token_analytics").await?;
        println!("Created token_analytics collection");
    } else {
        println!("Collection token_analytics already exists");
    }
    if !collections.contains(&"market_signals".to_string()) {
        db.create_collection("market_signals").await?;
        println!("Created market_signals collection");
    } else {
        println!("Collection market_signals already exists");
    }
    // Get collections
    let token_analytics = db.collection::<Document>("token_analytics");
    let market_signals = db.collection::<Document>("market_signals");
    // Create indexes for token_analytics collection
    println!("Creating indexes for token_analytics collection...");
    // Compound index on token_address and timestamp
    let compound_index_options = IndexOptions::builder().build();
    let compound_index = IndexModel::builder()
        .keys(mongodb::bson::doc! {
            "token_address": 1,
            "timestamp": 1
        })
        .options(compound_index_options)
        .build();
    match token_analytics.create_index(compound_index).await {
        Ok(_) => println!("Created compound index for token_analytics"),
        Err(e) if e.to_string().contains("already exists") => {
            println!("Compound index already exists for token_analytics");
        }
        Err(e) => return Err(e.into()),
    }
    // Create vector search index for embeddings
    let vector_search_command = mongodb::bson::doc! {
        "createSearchIndexes": "token_analytics",
        "indexes": [{
            "name": "vector_index",
            "definition": {
                "mappings": {
                    "dynamic": true,
                    "fields": {
                        "id": {
                            "type": "string"
                        },
                        "token_address": {
                            "type": "string"
                        },
                        "token_name": {
                            "type": "string"
                        },
                        "token_symbol": {
                            "type": "string"
                        },
                        "embedding": {
                            "type": "knnVector",
                            "dimensions": 1536,
                            "similarity": "cosine"
                        }
                    }
                }
            }
        }]
    };
    match db.run_command(vector_search_command).await {
        Ok(_) => println!("Created vector search index for token_analytics collection"),
        Err(e) if e.to_string().contains("already defined") => {
            println!("Vector search index already exists for token_analytics collection");
        }
        Err(e) => return Err(e.into()),
    }
    // Create indexes for market_signals collection
    println!("Creating indexes for market_signals collection...");
    let market_index_options = IndexOptions::builder().build();
    let market_index = IndexModel::builder()
        .keys(mongodb::bson::doc! {
            "asset_address": 1,
            "timestamp": 1
        })
        .options(market_index_options)
        .build();
    match market_signals.create_index(market_index).await {
        Ok(_) => println!("Created index for market_signals"),
        Err(e) if e.to_string().contains("already exists") => {
            println!("Index already exists for market_signals");
        }
        Err(e) => return Err(e.into()),
    }
    println!("MongoDB setup completed successfully!");
    Ok(())
}
</file>

<file path="scripts/test_vector_search.rs">
use anyhow::Result;
use cainam_core::config::mongodb::MongoConfig;
use cainam_core::config::mongodb::{MongoDbPool, TokenAnalyticsData, TokenAnalyticsDataExt};
use mongodb::bson::doc;
use rig::embeddings::embed::{Embed, EmbedError, TextEmbedder};
use rig::providers::openai::{Client as OpenAiClient, TEXT_EMBEDDING_3_SMALL};
use std::env;
use tracing::info;
use tracing_subscriber::fmt;
// Add a local wrapper for TokenAnalyticsData to bypass the orphan rule.
#[derive(serde::Serialize)]
struct WrappedTokenAnalyticsData(TokenAnalyticsData);
impl From<TokenAnalyticsData> for WrappedTokenAnalyticsData {
    fn from(data: TokenAnalyticsData) -> Self {
        WrappedTokenAnalyticsData(data)
    }
}
impl Embed for WrappedTokenAnalyticsData {
    fn embed(&self, embedder: &mut TextEmbedder) -> Result<(), EmbedError> {
        let text = format!(
            "Name: {}, Symbol: {}, Address: {}",
            self.0.token_name, self.0.token_symbol, self.0.token_address
        );
        embedder.embed(text);
        Ok(())
    }
}
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing (with file and line numbers for easier debugging)
    fmt()
        .with_target(false)
        .with_thread_ids(false)
        .with_thread_names(false)
        .with_file(true)
        .with_line_number(true)
        .init();
    // Load environment variables from .env file
    dotenvy::dotenv().ok();
    info!("Starting vector search test...");
    // Initialize MongoDB connection using the configuration from the environment.
    let config = MongoConfig::from_env();
    let pool = MongoDbPool::create_pool(config).await?;
    // Clear the collection before inserting test data
    pool.client()
        .database("cainam")
        .collection::<TokenAnalyticsData>("token_analytics")
        .delete_many(doc! {})
        .await?;
    // Initialize the OpenAI client and create an embedding model using TEXT_EMBEDDING_3_SMALL.
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
    let openai_client = OpenAiClient::new(&openai_api_key);
    let embedding_model = openai_client.embedding_model(TEXT_EMBEDDING_3_SMALL);
    // Define sample test token data.
    // Here we leave the embedding vector empty so that insert_token_analytics_documents can generate it.
    let test_tokens = vec![
        WrappedTokenAnalyticsData(TokenAnalyticsData {
            id: "1".to_string(),
            token_address: "So11111111111111111111111111111111111111112".to_string(),
            token_name: "Wrapped SOL".to_string(),
            token_symbol: "SOL".to_string(),
            embedding: vec![],
        }),
        WrappedTokenAnalyticsData(TokenAnalyticsData {
            id: "2".to_string(),
            token_address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string(),
            token_name: "USD Coin".to_string(),
            token_symbol: "USDC".to_string(),
            embedding: vec![],
        }),
        WrappedTokenAnalyticsData(TokenAnalyticsData {
            id: "3".to_string(),
            token_address: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263".to_string(),
            token_name: "Bonk".to_string(),
            token_symbol: "BONK".to_string(),
            embedding: vec![],
        }),
    ];
    // Insert test token documents.
    // Because the trait is implemented for MongoDbPool, and pool is an Arc<MongoDbPool>,
    // we call the methods on &*pool (which dereferences the Arc).
    info!("Inserting test token data...");
    (&*pool)
        .insert_token_analytics_documents("token_analytics", embedding_model.clone(), test_tokens)
        .await?;
    info!("Test data inserted successfully");
    // Define the vector search queries.
    let test_queries = vec![
        "Find me a stablecoin",
        "What's the native token of Solana",
        "Show me a meme token",
    ];
    // Execute each query and print search results.
    for query in test_queries {
        info!("Testing search with query: {}", query);
        let results = (&*pool)
            .top_n("token_analytics", embedding_model.clone(), query, 2)
            .await?;
        info!("Search results for '{}': {:#?}", query, results);
    }
    info!("Vector search test completed successfully");
    Ok(())
}
</file>

<file path="src/actions/helius/create_webhook.rs">
use crate::SolanaAgentKit;
use serde::{Deserialize, Serialize};
#[derive(Deserialize, Serialize)]
pub struct HeliusWebhookResponse {
    pub webhook_url: String,
    pub webhook_id: String,
}
pub async fn create_webhook(
    agent: &SolanaAgentKit,
    account_addresses: Vec<String>,
    webhook_url: String,
) -> Result<HeliusWebhookResponse, Box<dyn std::error::Error>> {
    // Get the Helius API key from the agent's configuration
    let api_key = match agent.config.helius_api_key.as_ref() {
        Some(key) => key,
        None => return Err("Missing Helius API key in agent.config.HELIUS_API_KEY".into()),
    };
    let url = format!("https://api.helius.xyz/v0/webhooks?api-key={}", api_key);
    let body = serde_json::json!({
        "webhookURL": webhook_url,
        "transactionTypes": ["Any"],
        "accountAddresses": account_addresses,
        "webhookType": "enhanced",
        "txnStatus": "all",
    });
    let client = reqwest::Client::new();
    let response = client.post(url).header("Content-Type", "application/json").json(&body).send().await?;
    let data = response.json::<serde_json::Value>().await?;
    let webhook_url = data.get("webhookURL").expect("webhookURL field").as_str().expect("webhookURL text");
    let webhook_id = data.get("webhookID").expect("webhookID field").as_str().expect("webhookID text");
    Ok(HeliusWebhookResponse { webhook_url: webhook_url.to_string(), webhook_id: webhook_id.to_string() })
}
</file>

<file path="src/actions/helius/delete_webhook.rs">
use crate::SolanaAgentKit;
/// Deletes a Helius Webhook by its ID.
///
/// # Arguments
/// * `agent` - An instance of SolanaAgentKit (with .config.HELIUS_API_KEY)
/// * `webhook_id` - The unique ID of the webhook to delete
///
/// # Returns
/// The response body from the Helius API (which may contain status or other info)
pub async fn delete_webhook(
    agent: &SolanaAgentKit,
    webhook_id: &str,
) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    // Get the Helius API key from the agent's configuration
    let api_key = match agent.config.helius_api_key.as_ref() {
        Some(key) => key,
        None => return Err("Missing Helius API key in agent.config.HELIUS_API_KEY".into()),
    };
    // Construct the URL for the DELETE request
    let url = format!("https://api.helius.xyz/v0/webhooks/{}?api-key={}", webhook_id, api_key);
    // Create an HTTP client
    let client = reqwest::Client::new();
    // Send the DELETE request
    let response = client.delete(&url).header("Content-Type", "application/json").send().await?;
    // Check if the request was successful
    if !response.status().is_success() {
        return Err(format!(
            "Failed to delete webhook: {} {}",
            response.status(),
            response.status().canonical_reason().unwrap_or("Unknown")
        )
        .into());
    }
    // Handle different response status codes
    if response.status().as_u16() == 204 {
        return Ok(serde_json::json!({"message": "Webhook deleted successfully (no content returned)"}));
    }
    // Check if the response body is empty
    let content_length = response.headers().get("Content-Length");
    if content_length.is_none() || content_length.expect("HeaderValue").to_str()? == "0" {
        return Ok(serde_json::json!({"message": "Webhook deleted successfully (empty body)"}));
    }
    // Parse the response body as JSON
    let data: serde_json::Value = response.json().await?;
    Ok(data)
}
</file>

<file path="src/actions/helius/get_assets_by_owner.rs">
use crate::SolanaAgentKit;
use serde_json::json;
pub async fn get_assets_by_owner(
    agent: &SolanaAgentKit,
    owner_public_key: &str,
    limit: u32,
) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    // Get the Helius API key from the agent's configuration
    let api_key = match agent.config.helius_api_key.as_ref() {
        Some(key) => key,
        None => return Err("Missing Helius API key in agent.config.HELIUS_API_KEY".into()),
    };
    let url = format!("https://mainnet.helius-rpc.com/?api-key={}", api_key);
    let client = reqwest::Client::new();
    let request_body = json!({
        "jsonrpc": "2.0",
        "id": "get-assets",
        "method": "getAssetsByOwner",
        "params": json!({
            "ownerAddress": owner_public_key,
            "page": 3,
            "limit": limit,
            "displayOptions": { "showFungible": true },
        }),
    });
    let response = client.post(&url).header("Content-Type", "application/json").json(&request_body).send().await?;
    if !response.status().is_success() {
        return Err(format!(
            "Failed to fetch: {} - {}",
            response.status(),
            response.status().canonical_reason().unwrap_or("Unknown")
        )
        .into());
    }
    let data: serde_json::Value = response.json().await?;
    Ok(data)
}
</file>

<file path="src/actions/helius/get_webhook.rs">
use crate::SolanaAgentKit;
use serde::{Deserialize, Serialize};
#[derive(Debug, Serialize, Deserialize)]
pub struct HeliusWebhookIdResponse {
    pub wallet: String,
    pub webhook_url: String,
    pub transaction_types: Vec<String>,
    pub account_addresses: Vec<String>,
    pub webhook_type: String,
}
/// Retrieves a Helius Webhook by ID, returning only the specified fields.
///
/// # Arguments
/// * `agent` - An instance of SolanaAgentKit (with .config.HELIUS_API_KEY)
/// * `webhook_id` - The unique ID of the webhook to delete
///
/// # Returns
/// A HeliusWebhook object containing { wallet, webhookURL, transactionTypes, accountAddresses, webhookType }
pub async fn get_webhook(
    agent: &SolanaAgentKit,
    webhook_id: &str,
) -> Result<HeliusWebhookIdResponse, Box<dyn std::error::Error>> {
    // Get the Helius API key from the agent's configuration
    let api_key = match agent.config.helius_api_key.as_ref() {
        Some(key) => key,
        None => return Err("Missing Helius API key in agent.config.HELIUS_API_KEY".into()),
    };
    let client = reqwest::Client::new();
    let url = format!("https://api.helius.xyz/v0/webhooks/{}?api-key={}", webhook_id, api_key);
    let response = client.get(url).header("Content-Type", "application/json").send().await?;
    let data = response.json::<HeliusWebhookIdResponse>().await?;
    Ok(data)
}
</file>

<file path="src/actions/helius/mod.rs">
mod create_webhook;
pub use create_webhook::{create_webhook, HeliusWebhookResponse};
mod delete_webhook;
pub use delete_webhook::delete_webhook;
mod get_webhook;
pub use get_webhook::{get_webhook, HeliusWebhookIdResponse};
mod transaction_parsing;
pub use transaction_parsing::transaction_parse;
mod get_assets_by_owner;
pub use get_assets_by_owner::get_assets_by_owner;
</file>

<file path="src/actions/helius/transaction_parsing.rs">
use crate::SolanaAgentKit;
use serde::{Deserialize, Serialize};
use serde_json::json;
#[derive(Debug, Serialize, Deserialize)]
pub struct HeliusWebhookIdResponse {
    pub wallet: String,
    pub webhook_url: String,
    pub transaction_types: Vec<String>,
    pub account_addresses: Vec<String>,
    pub webhook_type: String,
}
/// Parse a Solana transaction using the Helius Enhanced Transactions API
///
/// # Arguments
/// * `agent` - An instance of SolanaAgentKit (with .config.HELIUS_API_KEY)
/// * `transaction_id` - The transaction ID to parse
///
/// # Returns
/// Parsed transaction data
pub async fn transaction_parse(
    agent: &SolanaAgentKit,
    transaction_id: &str,
) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    // Get the Helius API key from the agent's configuration
    let api_key = match agent.config.helius_api_key.as_ref() {
        Some(key) => key,
        None => return Err("Missing Helius API key in agent.config.HELIUS_API_KEY".into()),
    };
    let client = reqwest::Client::new();
    let url = format!("https://api.helius.xyz/v0/transactions/?api-key={}", api_key);
    let body = json!( {
        "transactions": vec![transaction_id.to_string()],
    });
    let response = client.post(url).header("Content-Type", "application/json").json(&body).send().await?;
    let data = response.json().await?;
    Ok(data)
}
</file>

<file path="src/actions/solana/close_empty_token_accounts.rs">
use crate::{primitives::USDC, SolanaAgentKit};
use solana_client::rpc_request::TokenAccountsFilter;
use solana_sdk::{instruction::Instruction, pubkey::Pubkey, transaction::Transaction};
use spl_token::instruction::close_account;
use serde::{Deserialize, Serialize};
#[derive(serde::Deserialize)]
pub struct Parsed {
    pub info: SplToken,
}
#[derive(serde::Deserialize)]
pub struct SplToken {
    pub mint: String,
    #[serde(rename(deserialize = "tokenAmount"))]
    pub token_amount: Amount,
}
#[allow(dead_code)]
#[derive(serde::Deserialize)]
pub struct Amount {
    pub amount: String,
    #[serde(rename(deserialize = "uiAmountString"))]
    ui_amount_string: String,
    #[serde(rename(deserialize = "uiAmount"))]
    pub ui_amount: f64,
    pub decimals: u8,
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CloseEmptyTokenAccountsData {
    pub signature: String,
    pub closed_size: usize,
}
impl CloseEmptyTokenAccountsData {
    pub fn new(signature: String, closed_size: usize) -> Self {
        CloseEmptyTokenAccountsData { signature, closed_size }
    }
}
/// Close Empty SPL Token accounts of the agent.
///
/// # Parameters
///
/// - `agent`: An instance of `SolanaAgentKit`.
///
/// # Returns
///
/// Transaction signature and total number of accounts closed or an error if the account doesn't exist.
pub async fn close_empty_token_accounts(
    agent: &SolanaAgentKit,
) -> Result<CloseEmptyTokenAccountsData, Box<dyn std::error::Error>> {
    let max_instructions = 40_u32;
    let mut transaction: Vec<Instruction> = vec![];
    let mut closed_size = 0;
    let token_programs = vec![spl_token::ID, spl_token_2022::ID];
    for token_program in token_programs {
        let accounts = agent
            .connection
            .get_token_accounts_by_owner(
                &agent.wallet.address,
                TokenAccountsFilter::ProgramId(token_program.to_owned()),
            )
            .expect("get_token_accounts_by_owner");
        closed_size += accounts.len();
        for account in accounts {
            if transaction.len() >= max_instructions as usize {
                break;
            }
            if let solana_account_decoder::UiAccountData::Json(d) = &account.account.data {
                if let Ok(parsed) = serde_json::from_value::<Parsed>(d.parsed.clone()) {
                    if parsed.info.token_amount.amount.parse::<u32>().unwrap_or_default() == 0_u32
                        && parsed.info.mint != USDC
                    {
                        let account_pubkey = Pubkey::from_str_const(&account.pubkey);
                        if let Ok(instruct) = close_account(
                            &token_program,
                            &account_pubkey,
                            &agent.wallet.address,
                            &agent.wallet.address,
                            &[&agent.wallet.address],
                        ) {
                            transaction.push(instruct);
                        }
                    }
                }
            }
        }
    }
    if transaction.is_empty() {
        return Ok(CloseEmptyTokenAccountsData::default());
    }
    // Create and send transaction
    let recent_blockhash = agent.connection.get_latest_blockhash()?;
    let transaction = Transaction::new_signed_with_payer(
        &transaction,
        Some(&agent.wallet.address),
        &[&agent.wallet.wallet],
        recent_blockhash,
    );
    let signature = agent.connection.send_and_confirm_transaction(&transaction)?;
    let data = CloseEmptyTokenAccountsData::new(signature.to_string(), closed_size);
    Ok(data)
}
</file>

<file path="src/actions/solana/get_balance.rs">
use crate::SolanaAgentKit;
use solana_client::client_error::ClientError;
use solana_sdk::{native_token::LAMPORTS_PER_SOL, pubkey::Pubkey};
use std::str::FromStr;
/// Gets the balance of SOL or an SPL token for the agent's wallet.
///
/// # Parameters
///
/// - `agent`: An instance of `SolanaAgentKit`.
/// - `token_address`: An optional SPL token mint address. If not provided, returns the SOL balance.
///
/// # Returns
///
/// A `Result` that resolves to the balance as a number (in UI units) or an error if the account doesn't exist.
pub async fn get_balance(agent: &SolanaAgentKit, token_address: Option<String>) -> Result<f64, ClientError> {
    if let Some(token_address) = token_address {
        // Get SPL token account balance
        if let Ok(pubkey) = Pubkey::from_str(&token_address) {
            let token_account = agent.connection.get_token_account_balance(&pubkey)?;
            let ui_amount = token_account.ui_amount.unwrap_or(0.0);
            return Ok(ui_amount);
        }
    }
    // Get SOL balance
    let balance = agent.connection.get_balance(&agent.wallet.address)?;
    Ok(balance as f64 / LAMPORTS_PER_SOL as f64)
}
</file>

<file path="src/actions/solana/get_tps.rs">
use crate::SolanaAgentKit;
use solana_client::client_error::ClientError;
/// Gets the transactions per second (TPS) from the Solana network.
///
/// # Parameters
///
/// - `agent`: An instance of `SolanaAgentKit` that connects to the Solana cluster.
///
/// # Returns
///
/// A `Result` containing the TPS as a `f64`, or an error if fetching performance samples fails.
pub async fn get_tps(agent: &SolanaAgentKit) -> Result<f64, ClientError> {
    // Fetch recent performance samples
    let limit = 1;
    let perf_samples = agent.connection.get_recent_performance_samples(Some(limit))?;
    // Check if there are any samples available
    if !perf_samples.is_empty() {
        // Calculate TPS
        let num_transactions = perf_samples[0].num_transactions;
        let sample_period_secs = perf_samples[0].sample_period_secs;
        let tps = num_transactions as f64 / sample_period_secs as f64;
        return Ok(tps);
    }
    Ok(0.0)
}
</file>

<file path="src/actions/solana/mod.rs">
mod close_empty_token_accounts;
pub use close_empty_token_accounts::{close_empty_token_accounts, CloseEmptyTokenAccountsData};
mod get_balance;
pub use get_balance::get_balance;
mod request_faucet_funds;
pub use request_faucet_funds::request_faucet_funds;
mod get_tps;
pub use get_tps::get_tps;
mod transfer;
pub use transfer::transfer;
</file>

<file path="src/actions/solana/request_faucet_funds.rs">
use crate::SolanaAgentKit;
use solana_client::client_error::ClientError;
use solana_sdk::native_token::LAMPORTS_PER_SOL;
/// Requests SOL from the Solana faucet (devnet/testnet only).
///
/// # Parameters
///
/// - `agent`: An instance of `SolanaAgentKit`.
///
/// # Returns
///
/// A transaction signature as a `String`.
///
/// # Errors
///
/// Returns an error if the request fails or times out.
pub async fn request_faucet_funds(agent: &SolanaAgentKit) -> Result<String, ClientError> {
    // Request airdrop of 5 SOL (5 * LAMPORTS_PER_SOL)
    let tx = agent.connection.request_airdrop(&agent.wallet.address, 5 * LAMPORTS_PER_SOL)?;
    // Confirm the transaction
    agent.connection.confirm_transaction(&tx)?;
    Ok(tx.to_string())
}
</file>

<file path="src/actions/solana/transfer.rs">
use crate::SolanaAgentKit;
use solana_client::client_error::ClientError;
use solana_sdk::{program_pack::Pack, pubkey::Pubkey, system_instruction, transaction::Transaction};
use spl_associated_token_account::get_associated_token_address;
use spl_token::{instruction::transfer as transfer_instruct, state::Mint};
/// Transfer SOL or SPL tokens to a recipient
///
/// `agent` - SolanaAgentKit instance
/// `to` - Recipient's public key
/// `amount` - Amount to transfer
/// `mint` - Optional mint address for SPL tokens
///
/// Returns the transaction signature.
pub async fn transfer(
    agent: &SolanaAgentKit,
    to: &str,
    amount: u64,
    mint: Option<String>,
) -> Result<String, ClientError> {
    match mint {
        Some(mint) => {
            // Transfer SPL Token
            let mint = Pubkey::from_str_const(&mint);
            let to = Pubkey::from_str_const(to);
            let from_ata = get_associated_token_address(&mint, &agent.wallet.address);
            let to_ata = get_associated_token_address(&mint, &to);
            let account_info = &agent.connection.get_account(&mint).expect("get_account");
            let mint_info = Mint::unpack_from_slice(&account_info.data).expect("unpack_from_slice");
            let adjusted_amount = amount * 10u64.pow(mint_info.decimals as u32);
            let transfer_instruction = transfer_instruct(
                &spl_token::id(),
                &from_ata,
                &to_ata,
                &from_ata,
                &[&agent.wallet.address],
                adjusted_amount,
            )
            .expect("transfer_instruct");
            let transaction = Transaction::new_signed_with_payer(
                &[transfer_instruction],
                Some(&agent.wallet.address),
                &[&agent.wallet.wallet],
                agent.connection.get_latest_blockhash().expect("new_signed_with_payer"),
            );
            let signature =
                agent.connection.send_and_confirm_transaction(&transaction).expect("send_and_confirm_transaction");
            Ok(signature.to_string())
        }
        None => {
            let transfer_instruction =
                system_instruction::transfer(&agent.wallet.address, &Pubkey::from_str_const(to), amount);
            let transaction = Transaction::new_signed_with_payer(
                &[transfer_instruction],
                Some(&agent.wallet.address),
                &[&agent.wallet.wallet],
                agent.connection.get_latest_blockhash().expect("get_latest_blockhash"),
            );
            let signature =
                agent.connection.send_and_confirm_transaction(&transaction).expect("send_and_confirm_transaction");
            Ok(signature.to_string())
        }
    }
}
</file>

<file path="src/agent/analyst.rs">
use crate::config::mongodb::MongoDbPool;
use crate::models::market_signal::MarketSignal;
use crate::services::token_analytics::TokenAnalyticsService;
use anyhow::Result;
use bson::DateTime;
use chrono::{Duration, TimeZone, Utc};
use std::sync::Arc;
use thiserror::Error;
#[derive(Error, Debug)]
pub enum Error {
    #[error("MongoDB error: {0}")]
    Mongo(#[from] mongodb::error::Error),
    #[error("Other error: {0}")]
    Other(String),
}
pub struct AnalystAgent {
    analytics_service: Arc<TokenAnalyticsService>,
    db: Arc<MongoDbPool>,
}
impl AnalystAgent {
    pub fn new(analytics_service: Arc<TokenAnalyticsService>, db: Arc<MongoDbPool>) -> Self {
        Self {
            analytics_service,
            db,
        }
    }
    pub async fn analyze_token(&self, symbol: &str, address: &str) -> Result<Option<MarketSignal>> {
        // First fetch and store current token info
        let analytics = self
            .analytics_service
            .fetch_and_store_token_info(symbol, address)
            .await
            .map_err(|e| anyhow::anyhow!(e))?;
        // Get historical data for analysis
        let now = DateTime::now();
        let timestamp_millis = now.timestamp_millis();
        let chrono_now = Utc.timestamp_millis_opt(timestamp_millis).unwrap();
        let start_time_chrono = chrono_now - Duration::days(7);
        let new_timestamp_millis = start_time_chrono.timestamp_millis();
        let start_time = DateTime::from_millis(new_timestamp_millis);
        // let start_time = DateTime::now() - chrono::Duration::days(7);
        let end_time = DateTime::now();
        let _history = self
            .analytics_service
            .get_token_history(address, start_time, end_time, 100, 0)
            .await
            .map_err(|e| anyhow::anyhow!(e))?;
        // Get latest analytics for comparison
        let latest = self
            .analytics_service
            .get_latest_token_analytics(address)
            .await
            .map_err(|e| anyhow::anyhow!(e))?;
        if let Some(latest) = latest {
            // Calculate volume change
            if let Some(current_volume) = analytics.volume_24h.clone() {
                if let Some(_volume_change) = self
                    .analytics_service
                    .calculate_volume_change(&current_volume, &latest)
                {
                    // Generate market signals based on the analysis
                    return self
                        .analytics_service
                        .generate_market_signals(&analytics)
                        .await
                        .map_err(|e| anyhow::anyhow!(e));
                }
            }
        }
        Ok(None)
    }
    // async fn store_analysis(&self, analysis: &Analysis) -> Result<(), Error> {
    //     let collection = self.db.database("cainam").collection("market_analysis");
    //     collection
    //         .insert_one(analysis, None)
    //         .await
    //         .map_err(|e| Error::Mongo(e))?;
    //     Ok(())
    // }
}
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::birdeye::{BirdeyeApi, MockBirdeyeApi, TokenInfo};
//     use crate::config::MarketConfig;
//     use rig_mongodb::MongoDbPool;
//     async fn setup_test_db() -> Arc<MongoDbPool> {
//         MongoDbPool::new_from_uri("mongodb://localhost:32770", "cainam_test")
//             .await
//             .expect("Failed to create test database pool")
//             .into()
//     }
//     fn setup_mock_birdeye() -> (Arc<dyn BirdeyeApi>, Arc<BirdeyeClient>) {
//         let mut mock = MockBirdeyeApi::new();
//         mock.expect_get_token_info().returning(|_| {
//             Ok(TokenInfo {
//                 price: 100.0,
//                 volume_24h: 1000000.0,
//                 price_change_24h: 5.0,
//                 liquidity: 500000.0,
//                 trade_24h: 1000,
//             })
//         });
//         (
//             Arc::new(mock),
//             Arc::new(BirdeyeClient::new("test_key".to_string())),
//         )
//     }
//     #[tokio::test]
//     async fn test_analyze_token() -> Result<()> {
//         let db = setup_test_db().await;
//         let (birdeye, birdeye_extended) = setup_mock_birdeye();
//         let market_config = MarketConfig::default();
//         let analytics_service = Arc::new(TokenAnalyticsService::new(
//             db,
//             birdeye,
//             birdeye_extended,
//             Some(market_config),
//         ));
//         let analyst = AnalystAgent::new(analytics_service);
//         let signal = analyst.analyze_token("SOL", "test_address").await?;
//         assert!(signal.is_some());
//         Ok(())
//     }
// }
</file>

<file path="src/agent/mod.rs">
pub mod trader;
// pub mod risk_manager;
// pub mod portfolio_optimizer;
pub mod analyst;
use serde::{Deserialize, Serialize};
use std::time::Duration;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfig {
    pub openai_api_key: String,
    pub birdeye_api_key: String,
    pub twitter_email: String,
    pub twitter_username: String,
    pub twitter_password: String,
    pub analysis_interval: Duration,
    pub trade_min_confidence: f64,
    pub trade_max_amount: f64,
}
impl Default for AgentConfig {
    fn default() -> Self {
        Self {
            openai_api_key: String::new(),
            birdeye_api_key: String::new(),
            twitter_email: String::new(),
            twitter_username: String::new(),
            twitter_password: String::new(),
            analysis_interval: Duration::from_secs(300), // 5 minutes
            trade_min_confidence: 0.7,
            trade_max_amount: 1000.0,
        }
    }
}
// Re-export common types
</file>

<file path="src/agent/portfolio_optimizer.rs">
use anyhow::Result;
use bigdecimal::{BigDecimal, ToPrimitive};
use crate::models::market_signal::MarketSignal;
use crate::models::token_analytics::TokenAnalytics;
use crate::utils::f64_to_decimal;
use std::sync::Arc;
use rig_mongodb::{MongoDbPool, bson::doc};
use crate::error::Error;
use crate::models::allocation::Allocation;
pub struct PortfolioOptimizer {
    db: Arc<MongoDbPool>,
}
impl PortfolioOptimizer {
    pub fn new(db: Arc<MongoDbPool>) -> Self {
        Self { db }
    }
    pub async fn get_allocation(&self, _token: &TokenAnalytics, _signal: &MarketSignal) -> Result<BigDecimal> {
        // For now, return a default allocation
        Ok(f64_to_decimal(0.1)) // 10% allocation
    }
    pub async fn get_position_allocation(&self, address: &str) -> Result<BigDecimal> {
        let collection = self.db.collection("allocations");
        let filter = doc! {
            "token_address": address,
        };
        let doc = collection.find_one(filter, None)
            .await?;
        let allocation = doc
            .and_then(|d| d.get_f64("allocation"))
            .unwrap_or(0.0);
        Ok(f64_to_decimal(allocation))
    }
    async fn get_allocation(&self, token_address: &str) -> Result<Option<Allocation>, Error> {
        let collection = self.db.database("cainam").collection("allocations");
        let filter = doc! {
            "token_address": token_address,
        };
        collection.find_one(filter, None)
            .await
            .map_err(|e| Error::Database(e.to_string()))
    }
}
</file>

<file path="src/agent/risk_manager.rs">
use anyhow::Result;
use crate::models::market_signal::MarketSignal;
use crate::utils::{decimal_to_f64, f64_to_decimal};
use std::sync::Arc;
use rig_mongodb::MongoDbPool;
pub struct RiskManagerAgent {
    db: Arc<MongoDbPool>,
    max_position_size: f64,
    max_drawdown: f64,
}
impl RiskManagerAgent {
    pub fn new(db: Arc<MongoDbPool>, max_position_size: f64, max_drawdown: f64) -> Self {
        Self {
            db,
            max_position_size,
            max_drawdown,
        }
    }
    pub async fn validate_trade(&self, signal: &MarketSignal) -> Result<bool> {
        // TODO: Implement risk validation logic
        // - Check current exposure
        // - Validate against max drawdown
        // - Check correlation with existing positions
        // - Verify position sizing
        let min_confidence = f64_to_decimal(0.5);
        let max_risk = f64_to_decimal(0.7);
        if signal.confidence < min_confidence || signal.risk_score > max_risk {
            return Ok(false);
        }
        Ok(true)
    }
    pub async fn calculate_position_size(&self, signal: &MarketSignal) -> Result<f64> {
        // Calculate optimal position size based on:
        // - Current portfolio value
        // - Risk metrics
        // - Signal confidence
        let max_size = f64_to_decimal(self.max_position_size);
        let base_size = max_size.clone() * signal.confidence.clone();
        let one = f64_to_decimal(1.0);
        let risk_factor = one - signal.risk_score.clone();
        let risk_adjusted_size = base_size * risk_factor;
        Ok(decimal_to_f64(&risk_adjusted_size.min(max_size)))
    }
}
</file>

<file path="src/agent/trader.rs">
// use crate::models::trade::Trade;
use crate::{
    config::AgentConfig,
    birdeye::api::BirdeyeClient,
    config::mongodb::MongoDbPool,
    config::MarketConfig,
    error::{AgentError, AgentResult},
    models::market_signal::{MarketSignal, SignalType},
    services::TokenAnalyticsService,
    trading::trading_engine::TradingEngine,
    trading::SolanaAgentKit,
    utils::f64_to_decimal,
};
use bigdecimal::BigDecimal;
use rig::{
    agent::Agent,
    providers::openai::{Client as OpenAIClient, CompletionModel},
};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use tokio::time::sleep;
use tracing::{error, info};
const MAX_RETRIES: u32 = 3;
const RETRY_DELAY: u64 = 1000; // 1 second
pub struct TradingAgent {
    agent: Agent<CompletionModel>,
    trading_engine: TradingEngine,
    analytics_service: Arc<TokenAnalyticsService>,
    config: AgentConfig,
    running: Arc<AtomicBool>,
    db: Arc<MongoDbPool>,
    birdeye: Arc<BirdeyeClient>,
    birdeye_extended: Arc<BirdeyeClient>,
}
impl TradingAgent {
    pub async fn new(
        config: AgentConfig,
        db: Arc<MongoDbPool>,
        solana_agent: SolanaAgentKit,
    ) -> AgentResult<Self> {
        info!("Initializing TradingAgent...");
        // Initialize OpenAI client
        let openai_client = OpenAIClient::new(&config.openai_api_key);
        info!("Creating GPT-4 agent...");
        let agent = openai_client
            .agent(crate::config::get_openai_model())
            .preamble(include_str!("../prompts/system.txt"))
            .build();
        // Initialize components
        let trading_engine = TradingEngine::new(
            config.trade_min_confidence,
            config.trade_max_amount,
            solana_agent,
        );
        // info!("Initializing Twitter client...");
        // let mut twitter_client = TwitterClient::new(
        //     config.twitter_email.clone(),
        //     config.twitter_username.clone(),
        //     config.twitter_password.clone(),
        // );
        // // Retry Twitter login with exponential backoff
        // let mut retry_count = 0;
        // loop {
        //     match twitter_client.login().await {
        //         Ok(_) => {
        //             info!("Successfully logged in to Twitter");
        //             break;
        //         }
        //         Err(e) => {
        //             retry_count += 1;
        //             if retry_count >= MAX_RETRIES {
        //                 error!("Failed to login to Twitter after {} attempts", MAX_RETRIES);
        //                 return Err(AgentError::TwitterApi(format!("Login failed: {}", e)));
        //             }
        //             warn!(
        //                 "Failed to login to Twitter (attempt {}), retrying...",
        //                 retry_count
        //             );
        //             sleep(Duration::from_millis(RETRY_DELAY * 2u64.pow(retry_count))).await;
        //         }
        //     }
        // }
        info!("Initializing Birdeye clients...");
        let birdeye = Arc::new(BirdeyeClient::new(config.birdeye_api_key.clone()));
        let birdeye_extended = Arc::new(BirdeyeClient::new(config.birdeye_api_key.clone()));
        // Initialize market config
        let market_config = MarketConfig::new_from_env()?;
        // Initialize analytics service
        let analytics_service =
            Arc::new(TokenAnalyticsService::new(db.clone(), birdeye.clone(), Some(market_config)).await?);
        Ok(Self {
            agent,
            trading_engine,
            analytics_service,
            config,
            running: Arc::new(AtomicBool::new(false)),
            db,
            birdeye,
            birdeye_extended,
        })
    }
    // async fn store_trade(&self, trade: &Trade) -> Result<(), Error> {
    //     let collection = self.db.database("cainam").collection("trades");
    //     collection
    //         .insert_one(trade)
    //         .await
    //         .map_err(|e| Error::Mongo(e))?;
    //     Ok(())
    // }
    pub async fn analyze_market(
        &self,
        symbol: &str,
        address: &str,
    ) -> AgentResult<Option<MarketSignal>> {
        info!("Starting market analysis for {}", symbol);
        // Fetch and store token analytics
        let analytics = self
            .analytics_service
            .fetch_and_store_token_info(symbol, address)
            .await
            .map_err(|e| {
                AgentError::MarketAnalysis(format!("Failed to fetch token info: {}", e))
            })?;
        info!("Market Analysis for {}:", symbol);
        info!("Current Price: ${:.4}", analytics.price);
        if let Some(ref volume) = analytics.volume_24h {
            info!("24h Volume: ${:.2}", volume);
        }
        // Generate market signals
        let signal = self
            .analytics_service
            .generate_market_signals(&analytics)
            .await
            .map_err(|e| {
                AgentError::MarketAnalysis(format!("Failed to generate signals: {}", e))
            })?;
        if let Some(signal) = &signal {
            info!(
                "Market signal generated: {:?} (confidence: {:.2})",
                signal.signal_type, signal.confidence
            );
        }
        Ok(signal)
    }
    pub async fn process_signal(&self, signal: &MarketSignal) -> AgentResult<Option<String>> {
        let zero = BigDecimal::from(0);
        let action = match signal.signal_type {
            SignalType::PriceSpike if signal.price > zero => "BUY",
            SignalType::StrongBuy => "BUY",
            SignalType::Buy => "BUY",
            SignalType::VolumeSurge if signal.volume_change > zero => "BUY",
            SignalType::PriceDrop => "SELL",
            SignalType::StrongSell => "SELL",
            SignalType::Sell => "SELL",
            SignalType::Hold => "HOLD",
            _ => return Ok(None),
        };
        // Convert f64 config values to BigDecimal
        let threshold = f64_to_decimal(self.config.trade_min_confidence);
        let max_amount = f64_to_decimal(self.config.trade_max_amount);
        if signal.confidence >= threshold {
            let amount = (max_amount.clone() * signal.confidence.clone()).min(max_amount.clone());
            match action {
                "BUY" | "SELL" => {
                    info!(
                        "Executing {} trade for {} with amount {}",
                        action, signal.asset_address, amount
                    );
                    self.trading_engine
                        .execute_trade(signal)
                        .await
                        .map_err(|e| {
                            AgentError::Trading(format!("Trade execution failed: {}", e))
                        })?;
                }
                _ => {}
            }
        }
        Ok(Some(action.to_string()))
    }
    pub async fn execute_trade(&self, _symbol: &str, signal: &MarketSignal) -> AgentResult<String> {
        self.trading_engine
            .execute_trade(signal)
            .await
            .map_err(|e| AgentError::Trading(format!("Trade execution failed: {}", e)))
    }
    pub async fn post_trade_update(
        &self,
        _symbol: &str,
        _action: &str,
        _amount: f64,
        _signal_type: &SignalType,
    ) -> AgentResult<()> {
        // TODO: Implement post-trade updates
        // - Update portfolio state
        // - Log trade details
        // - Send notifications
        Ok(())
    }
    pub async fn run(&self) -> AgentResult<()> {
        info!("Starting trading agent...");
        self.running.store(true, Ordering::SeqCst);
        let tokens = [
            ("SOL", "So11111111111111111111111111111111111111112"),
            ("BONK", "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"),
        ];
        while self.running.load(Ordering::SeqCst) {
            for (symbol, address) in tokens.iter() {
                match self.analyze_market(symbol, address).await {
                    Ok(Some(signal)) => {
                        let min_confidence = f64_to_decimal(self.config.trade_min_confidence);
                        if signal.confidence >= min_confidence {
                            if let Err(e) = self.process_signal(&signal).await {
                                error!("Error processing signal: {}", e);
                            }
                        } else {
                            info!("Signal confidence too low for trading");
                        }
                    }
                    Ok(None) => {
                        info!("No trading signals generated");
                    }
                    Err(e) => {
                        error!("Market analysis failed for {}: {}", symbol, e);
                    }
                }
            }
            info!(
                "Waiting for next analysis interval ({:?})...",
                self.config.analysis_interval
            );
            sleep(self.config.analysis_interval).await;
            info!("Starting next analysis cycle");
        }
        info!("Trading agent stopped");
        Ok(())
    }
    pub fn stop(&self) {
        info!("Stopping trading agent...");
        self.running.store(false, Ordering::SeqCst);
    }
}
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::birdeye::MockBirdeyeApi;
//     use crate::twitter::MockTwitterApi;
//     async fn setup_test_db() -> Arc<MongoDbPool> {
//         MongoDbPool::new_from_uri("mongodb://localhost:32770", "cainam_test")
//             .await
//             .expect("Failed to create test database pool")
//             .into()
//     }
//     async fn setup_mocks() -> (Box<MockTwitterApi>, Box<MockBirdeyeApi>) {
//         let mut twitter_mock = Box::new(MockTwitterApi::new());
//         twitter_mock
//             .expect_login()
//             .times(1)
//             .returning(|| Box::pin(async { Ok(()) }));
//         let mut birdeye_mock = Box::new(MockBirdeyeApi::new());
//         birdeye_mock.expect_get_token_info().returning(|_| {
//             Box::pin(async {
//                 Ok(crate::birdeye::TokenInfo {
//                     price: 100.0,
//                     volume_24h: 1000000.0,
//                     price_change_24h: 5.0,
//                     liquidity: 500000.0,
//                     trade_24h: 1000,
//                 })
//             })
//         });
//         (twitter_mock, birdeye_mock)
//     }
//     #[tokio::test]
//     async fn test_market_analysis() -> AgentResult<()> {
//         let db = setup_test_db().await;
//         let solana_agent = SolanaAgentKit::new_from_env()?;
//         let config = AgentConfig::new_from_env()?;
//         let agent = TradingAgent::new(config, db, solana_agent).await?;
//         let signal = agent
//             .analyze_market("SOL", "So11111111111111111111111111111111111111112")
//             .await?;
//         assert!(signal.is_some());
//         Ok(())
//     }
// }
</file>

<file path="src/birdeye/api.rs">
use super::{BIRDEYE_API_BASE};
use crate::models::token_info::TokenInfo;
use anyhow::{anyhow, Result};
use async_trait::async_trait;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: T,
    pub message: Option<String>,
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenPrice {
    pub value: f64,
    pub decimals: u8,
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenData {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub image: Option<String>,
    pub price: f64,
    pub decimals: u8,
    #[serde(rename = "price24h")]
    pub price_24h: Option<f64>,
    #[serde(rename = "priceChange24h")]
    pub price_change_24h: Option<f64>,
    #[serde(rename = "volume24h")]
    pub volume_24h: Option<f64>,
    #[serde(rename = "volumeChange24h")]
    pub volume_change_24h: Option<f64>,
    pub liquidity: Option<f64>,
    #[serde(rename = "txns24h")]
    pub trade_24h: Option<i64>,
    pub holders: Option<i64>,
    #[serde(rename = "fdv")]
    pub fully_diluted_value: Option<f64>,
    #[serde(rename = "mcap")]
    pub market_cap: Option<f64>,
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MultiTokenData {
    #[serde(flatten)]
    pub tokens: HashMap<String, TokenData>,
}
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TokenMarketResponse {
    pub value: f64,
}
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TrendingToken {
    pub name: String,
    pub value: f64,
}
#[async_trait]
pub trait BirdeyeApi: Send + Sync {
    async fn get_token_info(&self, symbol: &str) -> Result<TokenInfo>;
    async fn get_token_info_by_address(&self, address: &str) -> Result<TokenInfo>;
    async fn get_market_data(&self, address: &str) -> Result<TokenMarketResponse>;
    async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<TrendingToken>>;
}
pub struct BirdeyeClient {
    client: Client,
    api_key: String,
}
impl BirdeyeClient {
    pub fn new(api_key: String) -> Self {
        BirdeyeClient {
            client: Client::new(),
            api_key,
        }
    }
    async fn get(&self, endpoint: &str) -> Result<reqwest::Response> {
        let url = format!("{}{}", BIRDEYE_API_BASE, endpoint);
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await?;
        if response.status().is_success() {
            Ok(response)
        } else {
            let status = response.status();
            let text = response.text().await?;
            Err(anyhow!(
                "Birdeye API request failed with status {}: {}",
                status,
                text
            ))
        }
    }
}
#[async_trait]
impl BirdeyeApi for BirdeyeClient {
    async fn get_token_info(&self, symbol: &str) -> Result<TokenInfo> {
        let endpoint = format!("/public/token_info/{}", symbol);
        let response: ApiResponse<TokenData> = self.get(&endpoint).await?.json().await?;
        if response.success {
            let token_data = response.data;
            Ok(TokenInfo {
                address: token_data.address,
                symbol: token_data.symbol,
                name: token_data.name,
                decimals: token_data.decimals,
                price: token_data.price,
                volume_24h: token_data.volume_24h.unwrap_or(0.0),
                market_cap: token_data.market_cap,
                price_change_24h: Some(token_data.price_change_24h.unwrap_or(0.0)),
                volume_change_24h: Some(token_data.volume_change_24h.unwrap_or(0.0)),
                liquidity: token_data.liquidity.unwrap_or(0.0),
                trade_24h: Some(token_data.trade_24h.unwrap_or(0)),
                logo_uri: token_data.image,
                extensions: None,
                timestamp: bson::DateTime::now(),
            })
        } else {
            Err(anyhow!(
                "Failed to get token info: {}",
                response.message.unwrap_or_else(|| "Unknown error".to_string())
            ))
        }
    }
    async fn get_token_info_by_address(&self, address: &str) -> Result<TokenInfo> {
        let endpoint = format!("/public/token_info/{}", address);
        let response: ApiResponse<TokenData> = self.get(&endpoint).await?.json().await?;
        if response.success {
            let token_data = response.data;
            Ok(TokenInfo {
                address: token_data.address,
                symbol: token_data.symbol,
                name: token_data.name,
                decimals: token_data.decimals,
                price: token_data.price,
                volume_24h: token_data.volume_24h.unwrap_or(0.0),
                market_cap: token_data.market_cap,
                price_change_24h: Some(token_data.price_change_24h.unwrap_or(0.0)),
                volume_change_24h: Some(token_data.volume_change_24h.unwrap_or(0.0)),
                liquidity: token_data.liquidity.unwrap_or(0.0),
                trade_24h: Some(token_data.trade_24h.unwrap_or(0)),
                logo_uri: token_data.image,
                extensions: None,
                timestamp: bson::DateTime::now(),
            })
        } else {
            Err(anyhow!(
                "Failed to get token info by address: {}",
                response.message.unwrap_or_else(|| "Unknown error".to_string())
            ))
        }
    }
    async fn get_market_data(&self, address: &str) -> Result<TokenMarketResponse> {
        let endpoint = format!("/public/token_price/{}", address);
        let response: ApiResponse<TokenMarketResponse> = self.get(&endpoint).await?.json().await?;
        if response.success {
            Ok(response.data)
        } else {
            Err(anyhow!(
                "Failed to get market data: {}",
                response.message.unwrap_or_else(|| "Unknown error".to_string())
            ))
        }
    }
    async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<TrendingToken>> {
        let endpoint = format!("/public/trending_tokens?limit={}", limit);
        let response: ApiResponse<Vec<TrendingToken>> = self.get(&endpoint).await?.json().await?;
        if response.success {
            Ok(response.data)
        } else {
            Err(anyhow!(
                "Failed to get trending tokens: {}",
                response.message.unwrap_or_else(|| "Unknown error".to_string())
            ))
        }
    }
}
// Mock BirdeyeApi for testing
#[cfg(test)]
pub struct MockBirdeyeApi {
    pub token_info: Option<TokenInfo>,
    pub token_info_by_address: Option<TokenInfo>,
    pub market_data: Option<TokenMarketResponse>,
    pub trending_tokens: Option<Vec<TrendingToken>>,
}
#[cfg(test)]
impl MockBirdeyeApi {
    pub fn new() -> Self {
        MockBirdeyeApi {
            token_info: None,
            token_info_by_address: None,
            market_data: None,
            trending_tokens: None,
        }
    }
    pub fn expect_get_token_info_by_address(&mut self) -> &mut Self {
        self.token_info_by_address = Some(TokenInfo {
            address: "So11111111111111111111111111111111111111112".to_string(),
            symbol: "SOL".to_string(),
            name: "Solana".to_string(),
            decimals: 9,
            price: 100.0,
            volume_24h: 1000000.0,
            market_cap: Some(1000000000.0),
            price_change_24h: Some(5.0),
            volume_change_24h: Some(10.0),
            liquidity: 500000.0,
            trade_24h: Some(1000),
            logo_uri: Some("https://example.com/sol.png".to_string()),
            extensions: None,
            timestamp: bson::DateTime::now(),
        });
        self
    }
}
#[cfg(test)]
#[async_trait]
impl BirdeyeApi for MockBirdeyeApi {
    async fn get_token_info(&self, _symbol: &str) -> Result<TokenInfo> {
        self.token_info.clone().ok_or(anyhow!("Mock not set"))
    }
    async fn get_token_info_by_address(&self, _address: &str) -> Result<TokenInfo> {
        self.token_info_by_address.clone().ok_or(anyhow!("Mock not set"))
    }
    async fn get_market_data(&self, _address: &str) -> Result<TokenMarketResponse> {
        self.market_data.clone().ok_or(anyhow!("Mock not set"))
    }
    async fn get_trending_tokens(&self, _limit: usize) -> Result<Vec<TrendingToken>> {
        self.trending_tokens.clone().ok_or(anyhow!("Mock not set"))
    }
}
</file>

<file path="src/birdeye/mod.rs">
pub mod api;
pub use api::{BirdeyeApi, TokenMarketResponse, TrendingToken};
use async_trait::async_trait;
use crate::models::token_info::TokenInfo;
const BIRDEYE_API_BASE: &str = "https://public-api.birdeye.so";
const RATE_LIMIT_DELAY: u64 = 500; // 500ms between requests
pub const TOKEN_ADDRESSES: &[(&str, &str)] = &[
    ("SOL", "So11111111111111111111111111111111111111112"),
    ("USDC", "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
    ("USDT", "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),
    ("PYUSD", "HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3"),
];
#[async_trait]
pub trait BirdeyeClient: Send + Sync {
    async fn get_token_info(&self, symbol: &str) -> Result<TokenInfo, anyhow::Error>;
    async fn get_token_info_by_address(&self, address: &str) -> Result<TokenInfo, anyhow::Error>;
    async fn get_market_data(&self, address: &str) -> Result<TokenMarketResponse, anyhow::Error>;
    async fn get_trending_tokens(&self, limit: usize) -> Result<Vec<TrendingToken>, anyhow::Error>;
}
</file>

<file path="src/character/mod.rs">
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Character {
    pub name: String,
    pub username: String,
    pub clients: Vec<String>,
    pub model_provider: String,
    pub image_model_provider: String,
    pub plugins: Vec<String>,
    pub settings: Settings,
    pub system: String,
    pub bio: Vec<String>,
    pub lore: Vec<String>,
    pub knowledge: Vec<String>,
    pub message_examples: Vec<Vec<MessageExample>>,
    pub post_examples: Vec<String>,
    pub topics: Vec<String>,
    pub style: Style,
    pub adjectives: Vec<String>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    pub secrets: HashMap<String, String>,
    pub voice: VoiceSettings,
    pub rag_knowledge: bool,
    pub model_config: ModelConfig,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceSettings {
    pub model: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelConfig {
    pub temperature: f32,
    pub max_tokens: u32,
    pub frequency_penalty: f32,
    pub presence_penalty: f32,
    pub top_p: f32,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExample {
    pub user: String,
    pub content: MessageContent,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContent {
    pub text: String,
    pub action: Option<String>,
    pub content: Option<serde_json::Value>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Style {
    pub tone: String,
    pub writing: String,
    pub personality: String,
    pub quirks: Vec<String>,
    pub all: Vec<String>,
    pub chat: Vec<String>,
    pub post: Vec<String>,
}
impl Character {
    pub fn load(path: &str) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let character = serde_json::from_str(&content)?;
        Ok(character)
    }
    pub fn get_system_prompt(&self) -> String {
        let mut prompt = String::new();
        // Add system description
        prompt.push_str(&self.system);
        prompt.push_str("\n\n");
        // Add style guidelines
        prompt.push_str("Style Guidelines:\n");
        for guideline in &self.style.all {
            prompt.push_str(&format!("- {}\n", guideline));
        }
        prompt.push_str("\n");
        // Add knowledge base summary
        prompt.push_str("Knowledge Base:\n");
        for knowledge in &self.knowledge {
            prompt.push_str(&format!("- {}\n", knowledge));
        }
        prompt
    }
    pub fn get_post_style(&self) -> Vec<String> {
        self.style.post.clone()
    }
    pub fn get_chat_style(&self) -> Vec<String> {
        self.style.chat.clone()
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_character_deserialization() {
        let json = r#"{
            "name": "Vergen",
            "username": "vergen",
            "clients": ["direct", "discord", "telegram", "twitter"],
            "modelProvider": "anthropic",
            "imageModelProvider": "openai",
            "plugins": [],
            "settings": {
                "secrets": {},
                "voice": {
                    "model": "en_US-hfc_male-medium"
                },
                "ragKnowledge": true,
                "modelConfig": {
                    "temperature": 0.7,
                    "maxTokens": 2048,
                    "frequencyPenalty": 0.0,
                    "presencePenalty": 0.0,
                    "topP": 0.95
                }
            },
            "system": "Test system prompt",
            "bio": ["Test bio"],
            "lore": ["Test lore"],
            "knowledge": ["Test knowledge"],
            "messageExamples": [],
            "postExamples": [],
            "topics": ["Test topic"],
            "style": {
                "tone": "professional",
                "writing": "clear",
                "personality": "confident",
                "quirks": ["test quirk"],
                "all": ["test guideline"],
                "chat": ["test chat style"],
                "post": ["test post style"]
            },
            "adjectives": ["analytical"]
        }"#;
        let character: Character = serde_json::from_str(json).unwrap();
        assert_eq!(character.name, "Vergen");
        assert_eq!(character.username, "vergen");
    }
}
</file>

<file path="src/characteristics/adjectives.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct Adjectives;
impl Characteristic for Adjectives {
    fn get_header(&self) -> String {
        "These are the adjectives.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/adjectives.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/bio.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct Bio;
impl Characteristic for Bio {
    fn get_header(&self) -> String {
        "This is your background.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/bio.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/lore.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct Lore;
impl Characteristic for Lore {
    fn get_header(&self) -> String {
        "This is your lore.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/lore.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/mod.rs">
pub mod adjectives;
pub mod bio;
pub mod lore;
pub mod post_examples;
pub mod previous_messages;
pub mod topics;
pub mod styles;
</file>

<file path="src/characteristics/post_examples.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct PostExamples;
impl Characteristic for PostExamples {
    fn get_header(&self) -> String {
        "These are previous post examples.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/post_examples.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/previous_messages.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct PreviousMessages;
impl Characteristic for PreviousMessages {
    fn get_header(&self) -> String {
        "These are examples of your previous messages.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/previous_messages.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/styles.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct Styles;
impl Characteristic for Styles {
    fn get_header(&self) -> String {
        "This is the style you use to talk in".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/styles.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/characteristics/topics.rs">
use std::fs;
use std::io;
use crate::core::characteristics::Characteristic;
pub struct Topics;
impl Characteristic for Topics {
    fn get_header(&self) -> String {
        "These are the topics you should talk about.".to_string()
    }
    fn get_traits(&self, character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/topics.txt", character_name);
        fs::read_to_string(&path)
    }
}
</file>

<file path="src/clients/twitter.rs">
use anyhow::{Result, anyhow};
use async_trait::async_trait;
use reqwest::{Client, cookie::Jar};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;
use url::Url;
const TWITTER_API_URL: &str = "https://api.twitter.com";
const TWITTER_LOGIN_URL: &str = "https://twitter.com/i/flow/login";
#[derive(Debug, Clone)]
pub struct TwitterClient {
    client: Arc<Client>,
    session: Arc<RwLock<Option<TwitterSession>>>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TwitterSession {
    auth_token: String,
    csrf_token: String,
    cookies: Vec<(String, String)>,
}
#[async_trait]
pub trait SocialMediaClient: Send + Sync {
    async fn post(&self, content: &str) -> Result<String>;
    async fn reply(&self, parent_id: &str, content: &str) -> Result<String>;
    async fn delete(&self, post_id: &str) -> Result<()>;
}
impl TwitterClient {
    pub fn new() -> Self {
        let cookie_store = Arc::new(Jar::default());
        let client = Client::builder()
            .cookie_provider(cookie_store.clone())
            .build()
            .unwrap();
        Self {
            client: Arc::new(client),
            session: Arc::new(RwLock::new(None)),
        }
    }
    pub async fn login(&self, email: &str, username: &str, password: &str) -> Result<()> {
        // First, get the guest token and initial cookies
        let guest_token = self.get_guest_token().await?;
        // Start login flow
        let flow_token = self.start_login_flow(&guest_token).await?;
        // Submit username/email
        let account_flow_token = self.submit_username(&flow_token, username, email).await?;
        // Submit password
        let auth_token = self.submit_password(&account_flow_token, password).await?;
        // Store session
        let session = TwitterSession {
            auth_token,
            csrf_token: self.get_csrf_token().await?,
            cookies: self.extract_cookies(),
        };
        *self.session.write().await = Some(session);
        Ok(())
    }
    async fn get_guest_token(&self) -> Result<String> {
        let response = self.client
            .post(&format!("{}/1.1/guest/activate.json", TWITTER_API_URL))
            .send()
            .await?;
        #[derive(Deserialize)]
        struct GuestToken {
            guest_token: String,
        }
        let token: GuestToken = response.json().await?;
        Ok(token.guest_token)
    }
    async fn start_login_flow(&self, guest_token: &str) -> Result<String> {
        let response = self.client
            .get(TWITTER_LOGIN_URL)
            .header("x-guest-token", guest_token)
            .send()
            .await?;
        // Extract flow_token from response
        // This is a placeholder - actual implementation would need to parse the HTML/JS
        Ok("flow_token".to_string())
    }
    async fn submit_username(&self, flow_token: &str, username: &str, email: &str) -> Result<String> {
        // Submit username/email to the login flow
        // This is a placeholder - actual implementation would need to handle the specific endpoints
        Ok("account_flow_token".to_string())
    }
    async fn submit_password(&self, flow_token: &str, password: &str) -> Result<String> {
        // Submit password and get auth token
        // This is a placeholder - actual implementation would need to handle the specific endpoints
        Ok("auth_token".to_string())
    }
    async fn get_csrf_token(&self) -> Result<String> {
        // Get CSRF token from cookies or make a request to get it
        Ok("csrf_token".to_string())
    }
    fn extract_cookies(&self) -> Vec<(String, String)> {
        // Extract relevant cookies from the cookie store
        vec![]
    }
    async fn ensure_authenticated(&self) -> Result<()> {
        if self.session.read().await.is_none() {
            return Err(anyhow!("Not authenticated"));
        }
        Ok(())
    }
}
#[async_trait]
impl SocialMediaClient for TwitterClient {
    async fn post(&self, content: &str) -> Result<String> {
        self.ensure_authenticated().await?;
        let session = self.session.read().await;
        let session = session.as_ref().unwrap();
        let response = self.client
            .post(&format!("{}/2/tweets", TWITTER_API_URL))
            .header("authorization", &format!("Bearer {}", session.auth_token))
            .header("x-csrf-token", &session.csrf_token)
            .json(&serde_json::json!({
                "text": content
            }))
            .send()
            .await?;
        #[derive(Deserialize)]
        struct TweetResponse {
            data: TweetData,
        }
        #[derive(Deserialize)]
        struct TweetData {
            id: String,
        }
        let tweet: TweetResponse = response.json().await?;
        Ok(tweet.data.id)
    }
    async fn reply(&self, parent_id: &str, content: &str) -> Result<String> {
        self.ensure_authenticated().await?;
        let session = self.session.read().await;
        let session = session.as_ref().unwrap();
        let response = self.client
            .post(&format!("{}/2/tweets", TWITTER_API_URL))
            .header("authorization", &format!("Bearer {}", session.auth_token))
            .header("x-csrf-token", &session.csrf_token)
            .json(&serde_json::json!({
                "text": content,
                "reply": {
                    "in_reply_to_tweet_id": parent_id
                }
            }))
            .send()
            .await?;
        #[derive(Deserialize)]
        struct TweetResponse {
            data: TweetData,
        }
        #[derive(Deserialize)]
        struct TweetData {
            id: String,
        }
        let tweet: TweetResponse = response.json().await?;
        Ok(tweet.data.id)
    }
    async fn delete(&self, post_id: &str) -> Result<()> {
        self.ensure_authenticated().await?;
        let session = self.session.read().await;
        let session = session.as_ref().unwrap();
        self.client
            .delete(&format!("{}/2/tweets/{}", TWITTER_API_URL, post_id))
            .header("authorization", &format!("Bearer {}", session.auth_token))
            .header("x-csrf-token", &session.csrf_token)
            .send()
            .await?;
        Ok(())
    }
}
</file>

<file path="src/config/agent_config.rs">
use crate::error::{AgentError, AgentResult};
use std::env;
use std::time::Duration;
#[derive(Debug, Clone)]
pub struct AgentConfig {
    pub openai_api_key: String,
    pub birdeye_api_key: String,
    // pub twitter_email: String,
    // pub twitter_username: String,
    // pub twitter_password: String,
    pub analysis_interval: Duration,
    pub trade_min_confidence: f64,
    pub trade_max_amount: f64,
}
impl AgentConfig {
    /// Creates a new AgentConfig from environment variables with validation
    pub fn new_from_env() -> AgentResult<Self> {
        let config = Self {
            openai_api_key: get_env_var("OPENAI_API_KEY")?,
            birdeye_api_key: get_env_var("BIRDEYE_API_KEY")?,
            // twitter_email: get_env_var("TWITTER_EMAIL")?,
            // twitter_username: get_env_var("TWITTER_USERNAME")?,
            // twitter_password: get_env_var("TWITTER_PASSWORD")?,
            analysis_interval: parse_duration_secs("ANALYSIS_INTERVAL", 300)?,
            trade_min_confidence: parse_f64("TRADE_MIN_CONFIDENCE", 0.7)?,
            trade_max_amount: parse_f64("TRADE_MAX_AMOUNT", 1000.0)?,
        };
        config.validate()?;
        Ok(config)
    }
    /// Validates the configuration values
    fn validate(&self) -> AgentResult<()> {
        // Validate API keys are not empty
        if self.openai_api_key.is_empty() {
            return Err(AgentError::Config("OpenAI API key cannot be empty".into()));
        }
        if self.birdeye_api_key.is_empty() {
            return Err(AgentError::Config("Birdeye API key cannot be empty".into()));
        }
        // // Validate Twitter credentials
        // if self.twitter_email.is_empty() || !self.twitter_email.contains('@') {
        //     return Err(AgentError::Config("Invalid Twitter email".into()));
        // }
        // if self.twitter_username.is_empty() {
        //     return Err(AgentError::Config("Twitter username cannot be empty".into()));
        // }
        // if self.twitter_password.is_empty() {
        //     return Err(AgentError::Config("Twitter password cannot be empty".into()));
        // }
        // Validate trading parameters
        if !(0.0..=1.0).contains(&self.trade_min_confidence) {
            return Err(AgentError::InvalidConfig(
                "trade_min_confidence".into(),
                "must be between 0.0 and 1.0".into(),
            ));
        }
        if self.trade_max_amount <= 0.0 {
            return Err(AgentError::InvalidConfig(
                "trade_max_amount".into(),
                "must be greater than 0".into(),
            ));
        }
        Ok(())
    }
}
/// Helper function to get an environment variable
fn get_env_var(key: &str) -> AgentResult<String> {
    env::var(key).map_err(|_| AgentError::MissingEnvVar(key.to_string()))
}
/// Helper function to parse a duration from seconds
fn parse_duration_secs(key: &str, default: u64) -> AgentResult<Duration> {
    let secs = env::var(key)
        .map(|v| v.parse::<u64>())
        .unwrap_or(Ok(default))
        .map_err(|_| {
            AgentError::InvalidConfig(
                key.to_string(),
                "must be a valid number of seconds".to_string(),
            )
        })?;
    Ok(Duration::from_secs(secs))
}
/// Helper function to parse an f64 value
fn parse_f64(key: &str, default: f64) -> AgentResult<f64> {
    let value = env::var(key)
        .map(|v| v.parse::<f64>())
        .unwrap_or(Ok(default))
        .map_err(|_| {
            AgentError::InvalidConfig(key.to_string(), "must be a valid number".to_string())
        })?;
    Ok(value)
}
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    #[test]
    fn test_config_validation() {
        // Set required environment variables
        env::set_var("OPENAI_API_KEY", "test_key");
        env::set_var("BIRDEYE_API_KEY", "test_key");
        env::set_var("TWITTER_EMAIL", "test@example.com");
        env::set_var("TWITTER_USERNAME", "test_user");
        env::set_var("TWITTER_PASSWORD", "test_pass");
        let config = AgentConfig::new_from_env().unwrap();
        assert_eq!(config.trade_min_confidence, 0.7); // Default value
        assert_eq!(config.trade_max_amount, 1000.0); // Default value
        // Test invalid confidence
        env::set_var("TRADE_MIN_CONFIDENCE", "2.0");
        assert!(AgentConfig::new_from_env().is_err());
        // Test invalid amount
        env::set_var("TRADE_MAX_AMOUNT", "-100");
        assert!(AgentConfig::new_from_env().is_err());
        // Test invalid email
        env::set_var("TWITTER_EMAIL", "invalid_email");
        assert!(AgentConfig::new_from_env().is_err());
    }
}
</file>

<file path="src/config/market_config.rs">
use crate::error::{AgentError, AgentResult};
use crate::utils::f64_to_decimal;
use bigdecimal::BigDecimal;
use std::env;
#[derive(Debug, Clone)]
pub struct MarketConfig {
    pub price_change_threshold: BigDecimal,
    pub volume_surge_threshold: BigDecimal,
    pub base_confidence: BigDecimal,
    pub price_weight: BigDecimal,
    pub volume_weight: BigDecimal,
}
impl MarketConfig {
    pub fn new_from_env() -> AgentResult<Self> {
        Ok(Self {
            price_change_threshold: parse_decimal_env("PRICE_CHANGE_THRESHOLD", 0.05)?,
            volume_surge_threshold: parse_decimal_env("VOLUME_SURGE_THRESHOLD", 1.0)?,
            base_confidence: parse_decimal_env("BASE_CONFIDENCE", 0.5)?,
            price_weight: parse_decimal_env("PRICE_WEIGHT", 0.3)?,
            volume_weight: parse_decimal_env("VOLUME_WEIGHT", 0.2)?,
        })
    }
    pub fn validate(&self) -> AgentResult<()> {
        // Validate thresholds are positive
        if self.price_change_threshold <= BigDecimal::from(0) {
            return Err(AgentError::InvalidConfig(
                "price_change_threshold".into(),
                "must be greater than 0".into(),
            ));
        }
        if self.volume_surge_threshold <= BigDecimal::from(0) {
            return Err(AgentError::InvalidConfig(
                "volume_surge_threshold".into(),
                "must be greater than 0".into(),
            ));
        }
        // Validate weights sum to less than or equal to 1
        let total_weight = &self.price_weight + &self.volume_weight;
        if total_weight > BigDecimal::from(1) {
            return Err(AgentError::InvalidConfig(
                "weights".into(),
                "sum of weights must not exceed 1.0".into(),
            ));
        }
        Ok(())
    }
}
impl Default for MarketConfig {
    fn default() -> Self {
        Self {
            price_change_threshold: f64_to_decimal(0.05),
            volume_surge_threshold: f64_to_decimal(1.0),
            base_confidence: f64_to_decimal(0.5),
            price_weight: f64_to_decimal(0.3),
            volume_weight: f64_to_decimal(0.2),
        }
    }
}
fn parse_decimal_env(key: &str, default: f64) -> AgentResult<BigDecimal> {
    match env::var(key) {
        Ok(val) => val
            .parse::<f64>()
            .map_err(|_| {
                AgentError::InvalidConfig(
                    key.to_string(),
                    "must be a valid decimal number".to_string(),
                )
            })
            .map(f64_to_decimal),
        Err(_) => Ok(f64_to_decimal(default)),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_market_config_defaults() {
        let config = MarketConfig::default();
        assert_eq!(config.price_change_threshold, f64_to_decimal(0.05));
        assert_eq!(config.volume_surge_threshold, f64_to_decimal(1.0));
        assert_eq!(config.base_confidence, f64_to_decimal(0.5));
    }
    #[test]
    fn test_market_config_validation() {
        // Valid config
        let config = MarketConfig::default();
        assert!(config.validate().is_ok());
        // Invalid: negative threshold
        let mut invalid_config = MarketConfig::default();
        invalid_config.price_change_threshold = f64_to_decimal(-0.1);
        assert!(invalid_config.validate().is_err());
        // Invalid: weights sum > 1
        let mut invalid_weights = MarketConfig::default();
        invalid_weights.price_weight = f64_to_decimal(0.6);
        invalid_weights.volume_weight = f64_to_decimal(0.5);
        assert!(invalid_weights.validate().is_err());
    }
}
</file>

<file path="src/config/mod.rs">
mod agent_config;
mod market_config;
pub mod mongodb;
pub use self::agent_config::AgentConfig;
pub use self::market_config::MarketConfig;
use rig::providers::openai::{GPT_4O, GPT_4O_MINI, O1_MINI, O1_PREVIEW};
pub const DEFAULT_MODEL: &str = "gpt-4o-mini";
pub fn get_openai_model() -> &'static str {
    match std::env::var("OPENAI_MODEL").as_deref() {
        Ok("gpt-4o") => GPT_4O,
        Ok("gpt-4o-mini") => GPT_4O_MINI,
        Ok("o3-mini") => O1_MINI,
        Ok("o1-preview") => O1_PREVIEW,
        _ => DEFAULT_MODEL,
    }
}
</file>

<file path="src/config/mongodb.rs">
use anyhow::{anyhow, Result};
use async_trait::async_trait;
use futures::TryStreamExt;
use mongodb::{
    bson::{self, doc, Document},
    options::ClientOptions,
    Client, Database,
};
use serde::{Deserialize, Deserializer, Serialize};
use serde_json::Value;
use std::{env, sync::Arc, time::Duration};
#[derive(Debug, Clone)]
pub struct MongoPoolConfig {
    pub min_pool_size: u32,
    pub max_pool_size: u32,
    pub connect_timeout: Duration,
}
impl Default for MongoPoolConfig {
    fn default() -> Self {
        Self {
            min_pool_size: 5,
            max_pool_size: 10,
            connect_timeout: Duration::from_secs(20),
        }
    }
}
impl MongoPoolConfig {
    pub fn from_env() -> Self {
        Self {
            min_pool_size: std::env::var("MONGODB_MIN_POOL_SIZE")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(5),
            max_pool_size: std::env::var("MONGODB_MAX_POOL_SIZE")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(10),
            connect_timeout: Duration::from_millis(
                std::env::var("MONGODB_CONNECT_TIMEOUT_MS")
                    .ok()
                    .and_then(|s| s.parse().ok())
                    .unwrap_or(20000),
            ),
        }
    }
    pub fn apply_to_options(&self, options: &mut ClientOptions) {
        options.min_pool_size = Some(self.min_pool_size);
        options.max_pool_size = Some(self.max_pool_size);
        options.connect_timeout = Some(self.connect_timeout);
    }
}
#[derive(Debug, Clone)]
pub struct MongoConfig {
    pub uri: String,
    pub database: String,
    pub app_name: Option<String>,
    pub pool_config: MongoPoolConfig,
}
impl Default for MongoConfig {
    fn default() -> Self {
        Self {
            uri: "mongodb://localhost:32770".to_string(),
            database: "cainam".to_string(),
            app_name: Some("cainam-core".to_string()),
            pool_config: MongoPoolConfig::default(),
        }
    }
}
impl MongoConfig {
    pub fn from_env() -> Self {
        let uri = env::var("MONGODB_URI").expect("MONGODB_URI must be set");
        let database = env::var("MONGODB_DATABASE").expect("MONGODB_DATABASE must be set");
        Self {
            uri,
            database,
            app_name: None,
            pool_config: MongoPoolConfig::default(),
        }
    }
}
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct TokenAnalyticsData {
    #[serde(rename = "_id", deserialize_with = "deserialize_object_id")]
    pub id: String,
    pub token_address: String,
    pub token_name: String,
    pub token_symbol: String,
    pub price: f64,
    pub volume_24h: Option<f64>,
    pub market_cap: Option<f64>,
    pub total_supply: Option<f64>,
    pub timestamp: bson::DateTime,
    pub created_at: Option<bson::DateTime>,
}
fn deserialize_object_id<'de, D>(deserializer: D) -> Result<String, D::Error>
where
    D: Deserializer<'de>,
{
    let value = Value::deserialize(deserializer)?;
    match value {
        Value::String(s) => Ok(s),
        Value::Object(map) => {
            if let Some(Value::String(oid)) = map.get("$oid") {
                Ok(oid.to_string())
            } else {
                Err(serde::de::Error::custom(
                    "Expected $oid field with string value",
                ))
            }
        }
        _ => Err(serde::de::Error::custom(
            "Expected string or object with $oid field",
        )),
    }
}
#[derive(Clone)]
pub struct MongoDbPool {
    client: Client,
    config: MongoConfig,
    db: Database,
}
impl MongoDbPool {
    pub async fn create_pool(config: MongoConfig) -> Result<Arc<MongoDbPool>> {
        let mut client_options = ClientOptions::parse(&config.uri).await?;
        if let Some(app_name) = &config.app_name {
            client_options.app_name = Some(app_name.clone());
        }
        // Set server API version to ensure compatibility
        client_options.server_api = Some(
            mongodb::options::ServerApi::builder()
                .version(mongodb::options::ServerApiVersion::V1)
                .build(),
        );
        // Apply pool configuration
        config.pool_config.apply_to_options(&mut client_options);
        let client = Client::with_options(client_options)?;
        let db = client.database(&config.database);
        // Test the connection
        client
            .database("admin")
            .run_command(doc! {"ping": 1})
            .await?;
        Ok(Arc::new(MongoDbPool { client, config, db }))
    }
    pub fn database(&self, name: &str) -> mongodb::Database {
        self.db.clone()
    }
    pub fn get_config(&self) -> &MongoConfig {
        &self.config
    }
    pub fn client(&self) -> &Client {
        &self.client
    }
}
#[async_trait]
pub trait TokenAnalyticsDataExt {
    async fn insert_token_analytics_documents<T>(
        &self,
        collection_name: &str,
        documents: Vec<T>,
    ) -> Result<()>
    where
        T: Serialize + Send + Sync;
    async fn find_tokens(
        &self,
        collection_name: &str,
        filter: Option<Document>,
        limit: i64,
    ) -> Result<Vec<Document>>;
}
#[async_trait]
impl TokenAnalyticsDataExt for MongoDbPool {
    async fn insert_token_analytics_documents<T>(
        &self,
        collection_name: &str,
        documents: Vec<T>,
    ) -> Result<()>
    where
        T: Serialize + Send + Sync,
    {
        let collection = self.db.collection::<Document>(collection_name);
        for doc in documents {
            let token_data_doc =
                bson::to_document(&doc).map_err(|e| anyhow!("Serialization error: {}", e))?;
            collection.insert_one(token_data_doc).await?;
        }
        Ok(())
    }
    async fn find_tokens(
        &self,
        collection_name: &str,
        filter: Option<Document>,
        limit: i64,
    ) -> Result<Vec<Document>> {
        let collection = self.db.collection::<Document>(collection_name);
        let filter = filter.unwrap_or_else(|| doc! {});
        let cursor = collection.find(filter).await?;
        let documents: Vec<Document> = cursor.try_collect().await?;
        Ok(documents)
    }
}
</file>

<file path="src/core/agent.rs">
use rig::agent::Agent as RigAgent;
use rig::providers::openai::{Client as OpenAIClient, CompletionModel, GPT_4_TURBO};
use rig::{completion::Prompt, providers};
use anyhow::Result;
pub struct Agent {
    agent: RigAgent<CompletionModel>,
}
impl Agent {
    pub fn new(openai_api_key: &str, prompt: &str) -> Self {
        let openai_client = OpenAIClient::new(openai_api_key);
        let agent = openai_client
            .agent(GPT_4_TURBO)
            .preamble(prompt)
            .temperature(1.0)
            .build();
        Agent { agent }
    }
    pub async fn prompt(&self, input: &str) -> Result<String> {
        let response = self.agent.prompt(input).await?;
        Ok(response)
    }
}
</file>

<file path="src/core/characteristics.rs">
use std::io;
use crate::characteristics::{
    adjectives::Adjectives, bio::Bio, lore::Lore, post_examples::PostExamples,
    previous_messages::PreviousMessages, styles::Styles, topics::Topics,
};
// Trait to simulate each characteristic module
pub trait Characteristic {
    fn get_header(&self) -> String;
    fn get_traits(&self, character_name: &str) -> io::Result<String>;
}
pub struct Characteristics;
impl Characteristics {
    // Simulate getCharacteristics
    pub fn get_characteristics() -> Vec<Box<dyn Characteristic>> {
        vec![
            Box::new(Bio),
            Box::new(Lore),
            Box::new(PreviousMessages),
            Box::new(PostExamples),
            Box::new(Adjectives),
            Box::new(Topics),
            Box::new(Styles),
        ]
    }
    // Simulate buildCharacteristicsInstructions
    pub fn build_characteristics_instructions(character_name: &str) -> String {
        let mut chars_instruction = String::new();
        let characteristics = Self::get_characteristics();
        for characteristic in characteristics {
            chars_instruction += &characteristic.get_header();
            chars_instruction += "\n";
            chars_instruction += &characteristic.get_traits(character_name).unwrap();
            chars_instruction += "\n";
        }
        chars_instruction
    }
    // Simulate getCharacterInstructions
    pub fn get_character_instructions(chars_instruction: &String) -> &String {
        chars_instruction
    }
}
</file>

<file path="src/core/instruction_builder.rs">
use std::fs;
use std::io::{self};
use super::characteristics::Characteristics;
pub struct InstructionBuilder {
    instructions: String,
}
impl InstructionBuilder {
    pub fn new() -> Self {
        Self {
            instructions: String::new(),
        }
    }
    // Read base instructions from a file
    pub fn get_base(character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/instructions/base.txt", character_name);
        fs::read_to_string(&path)
    }
    // Read suffix instructions from a file
    pub fn get_suffix(character_name: &str) -> io::Result<String> {
        let path = format!("./characters/{}/instructions/suffix.txt", character_name);
        fs::read_to_string(&path)
    }
    // Add instruction to the internal buffer
    pub fn add_instruction(&mut self, instruction: &str) {
        self.instructions.push_str(instruction);
    }
    // Add multiple instructions (array equivalent)
    pub fn add_instructions(&mut self, instructions: Vec<String>) {
        for instruction in instructions {
            self.add_instruction(&instruction);
        }
    }
    // Build the complete instructions
    pub fn build_instructions(&mut self, character_name: &str) -> io::Result<()> {
        self.instructions.clear();
        let characteristics = Characteristics::build_characteristics_instructions(character_name);
        // Add base instructions
        if let Ok(base) = Self::get_base(character_name) {
            self.add_instruction(&base);
        }
        // Add characteristics instructions
        self.add_instruction(&characteristics);
        // Add suffix instructions
        if let Ok(suffix) = Self::get_suffix(character_name) {
            self.add_instruction(&suffix);
        }
        Ok(())
    }
    // Get the complete instructions
    pub fn get_instructions(&self) -> &str {
        &self.instructions
    }
}
</file>

<file path="src/core/mod.rs">
pub mod agent;
pub mod characteristics;
pub mod instruction_builder;
pub mod runtime;
</file>

<file path="src/core/runtime.rs">
use rand::Rng;
use tokio::time::{sleep, Duration};
use crate::{
    core::agent::Agent,
    memory::MemoryStore,
    providers::{ai16z_twitter::Ai16zTwitter, discord::Discord, twitter::Twitter},
};
pub enum TwitterType {
    ApiKeys(Twitter),
    Ai16zTwitter(Ai16zTwitter),
}
impl TwitterType {
    pub async fn tweet(&self, text: &str) -> Result<(), anyhow::Error> {
        match self {
            TwitterType::ApiKeys(twitter) => {
                // Call the tweet method for Twitter API
                twitter.tweet(text.to_string()).await
            }
            TwitterType::Ai16zTwitter(ai6z_twitter) => {
                // Call the tweet method for Ai6zTwitter
                ai6z_twitter.tweet(text.to_string()).await
            }
        }
    }
}
pub struct Runtime {
    openai_api_key: String,
    twitter: TwitterType,
    discord: Discord,
    agents: Vec<Agent>,
    memory: Vec<String>,
}
impl Runtime {
    pub fn new(
        openai_api_key: &str,
        discord_webhook_url: &str,
        twitter_consumer_key: Option<&str>,
        twitter_consumer_secret: Option<&str>,
        twitter_access_token: Option<&str>,
        twitter_access_token_secret: Option<&str>,
        twitter_username: Option<&str>,
        twitter_password: Option<&str>,
    ) -> Self {
        let twitter = match (twitter_username, twitter_password) {
            (Some(username), Some(password)) => {
                // If both username and password are provided, prioritize Ai6zTwitter
                TwitterType::Ai16zTwitter(Ai16zTwitter::new(username, password))
            }
            (_, _) => {
                // Otherwise, fall back to Twitter API keys if available
                match (
                    twitter_consumer_key,
                    twitter_consumer_secret,
                    twitter_access_token,
                    twitter_access_token_secret,
                ) {
                    (
                        Some(consumer_key),
                        Some(consumer_secret),
                        Some(access_token),
                        Some(access_token_secret),
                    ) => TwitterType::ApiKeys(Twitter::new(
                        consumer_key,
                        consumer_secret,
                        access_token,
                        access_token_secret,
                    )),
                    _ => panic!("You must provide either Twitter username/password or API keys."),
                }
            }
        };
        let discord = Discord::new(discord_webhook_url);
        let agents = Vec::new();
        let memory: Vec<String> = MemoryStore::load_memory().unwrap_or_else(|_| Vec::new());
        Runtime {
            discord,
            memory,
            openai_api_key: openai_api_key.to_string(),
            agents,
            twitter,
        }
    }
    pub fn add_agent(&mut self, prompt: &str) {
        let agent = Agent::new(&self.openai_api_key, prompt);
        self.agents.push(agent);
    }
    pub async fn run(&mut self) -> Result<(), anyhow::Error> {
        if self.agents.is_empty() {
            return Err(anyhow::anyhow!("No agents available")).map_err(Into::into);
        }
        let mut rng = rand::thread_rng();
        let selected_agent = &self.agents[rng.gen_range(0..self.agents.len())];
        let response = selected_agent.prompt("tweet").await?;
        match MemoryStore::add_to_memory(&mut self.memory, &response) {
            Ok(_) => println!("Response saved to memory."),
            Err(e) => eprintln!("Failed to save response to memory: {}", e),
        }
        println!("AI Response: {}", response);
        self.discord.send_channel_message(&response.clone()).await;
        self.twitter.tweet(&response).await?;
        Ok(())
    }
    pub async fn run_periodically(&mut self) -> Result<(), anyhow::Error> {
        let mut rng = rand::thread_rng();
        loop {
            let random_sleep_duration = rng.gen_range(300..=1800);
            sleep(Duration::from_secs(random_sleep_duration)).await;
            if let Err(e) = self.run().await {
                eprintln!("Error running process: {}", e);
            }
        }
    }
}
</file>

<file path="src/database/mod.rs">
use std::sync::Arc;
use async_trait::async_trait;
pub use mongodb::{
    Collection,
    options::{FindOptions, FindOneOptions},
    bson::{self, doc, Document, DateTime},
};
use crate::config::mongodb::{MongoConfig, MongoDbPool};
use anyhow::Result;
use serde::{de::DeserializeOwned, Serialize};
// pub mod sync;
#[derive(Clone)]
pub struct DatabaseManager {
    pool: Arc<MongoDbPool>,
}
impl DatabaseManager {
    pub async fn new(config: MongoConfig) -> Result<Self> {
        let pool = MongoDbPool::create_pool(config).await?;
        Ok(Self { pool })
    }
    pub fn get_pool(&self) -> &MongoDbPool {
        &self.pool
    }
    pub fn get_database(&self, name: &str) -> mongodb::Database {
        self.pool.database(name)
    }
}
#[async_trait]
pub trait MongoDbExtensions {
    fn get_collection<T>(&self, name: &str) -> Collection<T> 
    where 
    T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static;
    async fn find_one_by_id<T>(&self, collection: &str, id: bson::oid::ObjectId) -> Result<Option<T>> 
    where 
    T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static;
    async fn find_one_by_filter<T>(&self, collection: &str, filter: bson::Document) -> Result<Option<T>>
    where 
    T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static;
    async fn find_with_sort<T>(&self, collection: &str, filter: bson::Document, sort: bson::Document, limit: Option<i64>) -> Result<Vec<T>>
    where 
    T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static;
}
// impl MongoDbExtensions for mongodb::Database {
//     fn get_collection<T>(&self, name: &str) -> Collection<T> 
//     where 
//     T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static
//     {
//         self.collection(name)
//     }
//     async fn find_one_by_id<T>(&self, collection: &str, id: bson::oid::ObjectId) -> Result<Option<T>>
//     where
//         T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static, // Crucial change
//     {
//         let filter = doc! { "_id": id };
//         let collection: Collection<T> = self.collection(collection); // Type hint for clarity
//         Ok(collection.find_one(filter).await?)
//     }
//     async fn find_one_by_filter<T>(&self, collection: &str, filter: bson::Document) -> Result<Option<T>>
//     where 
//     T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static, // Crucial change
//     {
//         Ok(self.collection(collection).find_one(filter).await?)
//     }
//     async fn find_with_sort<T>(&self, collection: &str, filter: bson::Document, sort: bson::Document, limit: Option<i64>) -> Result<Vec<T>>
//     where 
//     T: Serialize + DeserializeOwned + Unpin + Send + Sync + 'static, // Crucial change
//     {
//         let options = FindOptions::builder()
//             .sort(sort)
//             .limit(limit)
//             .build();
//         let mut cursor = self.collection(collection).find(filter).await?;
//         let mut results = Vec::new();
//         while let Some(doc) = cursor.try_next().await? {
//             results.push(doc);
//         }
//         Ok(results)
//     }
// }
// Vector store configuration helper
// pub fn create_vector_search_params() -> SearchParams {
//     SearchParams::new()
//         .with_distance_metric("cosine")
//         .with_embedding_field("vector")
//         .with_index_type("hnsw")
// }
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::test_utils::setup_test_db;
//     #[tokio::test]
//     async fn test_database_extensions() {
//         let (pool, db_name) = setup_test_db().await.unwrap();
//         let db = pool.database(&db_name);
//         // Test find_one_by_filter
//         let filter = doc! { "test_field": "test_value" };
//         let result = db.find_one_by_filter::<Document>("test_collection", filter).await;
//         assert!(result.is_ok());
//     }
// }
</file>

<file path="src/database/sync.rs">
use anyhow::Result;
use bson::doc;
use chrono::{DateTime, Utc};
use mongodb::Database;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use tracing::{info, warn};
use rig::completion::CompletionModel;
use solana_sdk::signature::Keypair;
use crate::error::Error;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenState {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub price_usd: f64,
    pub price_sol: f64,
    pub volume_24h: f64,
    pub market_cap: f64,
    pub price_change_24h: f64,
    pub volume_change_24h: f64,
    pub timestamp: DateTime<Utc>,
}
pub struct DataSyncService<M: CompletionModel> {
    db: Arc<Database>,
    data_provider: Arc<dyn DataProvider>,
    twitter: Arc<TwitterClient>,
    trading_strategy: Arc<TradingStrategy<M>>,
    dex: JupiterDex,
    personality: StoicPersonality,
    wallet: Arc<Keypair>,
    sync_interval: u64,
}
impl<M: CompletionModel> DataSyncService<M> {
    pub fn new(
        db: Arc<Database>,
        data_provider: Arc<dyn DataProvider>,
        twitter: Arc<TwitterClient>,
        trading_strategy: Arc<TradingStrategy<M>>,
        dex: JupiterDex,
        wallet: Arc<Keypair>,
        sync_interval: u64,
    ) -> Self {
        Self {
            db,
            data_provider,
            twitter,
            trading_strategy,
            dex,
            personality: StoicPersonality::new(),
            wallet,
            sync_interval,
        }
    }
    pub async fn sync_market_data(&self) -> Result<()> {
        info!("Starting market data sync cycle");
        // Fetch trending tokens
        info!("Fetching trending tokens from BirdEye");
        let trends = self.data_provider.get_trending_tokens(20).await?;
        info!("Found {} trending tokens", trends.len());
        // Insert token states and analyze trading opportunities
        for trend in trends {
            info!(
                "Processing token {} ({}) - Price: ${:.4}, 24h Change: {:.2}%, Volume: ${:.2}M",
                trend.metadata.name,
                trend.metadata.symbol,
                trend.metadata.price_usd,
                trend.price_change_24h,
                trend.metadata.volume_24h / 1_000_000.0
            );
            let state = self.market_trend_to_token_state(trend.clone());
            info!("Inserting token state into MongoDB");
            self.db.insert_one("token_states", &state).await?;
            // Format market data for LLM analysis
            let prompt = format!(
                "Analyze trading opportunity for {} ({}). Price: ${:.4}, 24h Change: {:.2}%, Volume: ${:.2}M",
                trend.metadata.name,
                trend.metadata.symbol,
                trend.metadata.price_usd,
                trend.price_change_24h,
                trend.metadata.volume_24h / 1_000_000.0
            );
            // Analyze trading opportunity
            info!("Analyzing trading opportunity with LLM");
            if let Ok(analysis) = self.trading_strategy.analyze_trading_opportunity(prompt, 1.0).await {
                // Parse the analysis into a trade recommendation
                if let Ok(trade) = serde_json::from_str::<TradeRecommendation>(&analysis) {
                    info!(
                        "Received trade recommendation: Action={:?}, Amount={} SOL, Confidence={:.2}, Risk={}",
                        trade.action, trade.amount_in_sol, trade.confidence, trade.risk_assessment
                    );
                    // Execute trade if confidence is high enough
                    if trade.confidence >= 0.8 {
                        match trade.action {
                            TradeAction::Buy => {
                                info!("Executing BUY order for {} SOL worth of {}", 
                                    trade.amount_in_sol, trend.metadata.symbol);
                                if let Ok(signature) = self.dex.execute_swap(
                                    "So11111111111111111111111111111111111111112", // SOL
                                    &trade.token_address,
                                    trade.amount_in_sol as u64,
                                    &self.wallet,
                                ).await {
                                    info!("Trade executed successfully. Signature: {}", signature);
                                    // Generate and post tweet about the trade
                                    info!("Generating tweet for successful buy");
                                    let tweet = self.personality.generate_trade_tweet(
                                        &self.trading_strategy.agent,
                                        &format!(
                                            "Action: Buy\nAmount: {} SOL\nToken: {}\nPrice: ${:.4}\nMarket Cap: ${:.2}M\n24h Volume: ${:.2}M\n24h Change: {:.2}%\nContract: {}\nTransaction: {}\nAnalysis: {}\nRisk Assessment: {}\nMarket Analysis:\n- Volume: {}\n- Price Trend: {}\n- Liquidity: {}\n- Momentum: {}",
                                            trade.amount_in_sol,
                                            trend.metadata.symbol,
                                            trend.metadata.price_usd,
                                            trend.metadata.market_cap / 1_000_000.0,
                                            trend.metadata.volume_24h / 1_000_000.0,
                                            trend.price_change_24h,
                                            trend.token_address,
                                            signature,
                                            trade.reasoning,
                                            trade.risk_assessment,
                                            trade.market_analysis.volume_analysis,
                                            trade.market_analysis.price_trend,
                                            trade.market_analysis.liquidity_assessment,
                                            trade.market_analysis.momentum_indicators
                                        ),
                                    ).await?;
                                    info!("Posting tweet: {}", tweet);
                                    if let Err(e) = self.twitter.post_tweet(&tweet).await {
                                        warn!("Failed to post trade tweet: {}", e);
                                    }
                                } else {
                                    warn!("Failed to execute buy order");
                                }
                            },
                            TradeAction::Sell => {
                                info!("Skipping SELL action - not implemented yet");
                            },
                            TradeAction::Hold => {
                                info!("Decision: HOLD {} - {}", 
                                    trend.metadata.symbol, trade.reasoning);
                            }
                        }
                    } else {
                        info!("Skipping trade due to low confidence: {:.2}", trade.confidence);
                    }
                } else {
                    warn!("Failed to parse trade recommendation");
                }
            } else {
                warn!("Failed to get trading analysis from LLM");
            }
        }
        info!("Market data sync cycle complete");
        Ok(())
    }
    pub async fn get_token_state(&self, token_address: &str) -> Result<Option<TokenState>> {
        let collection = self.db
            .database()
            .collection("token_states");
        let filter = doc! {
            "address": token_address
        };
        let options = rig_mongodb::options::FindOneOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        collection.find_one(filter, options)
            .await
            .map_err(anyhow::Error::from)
    }
    pub async fn get_token_history(
        &self,
        token_address: &str,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
    ) -> Result<Vec<TokenState>> {
        let collection = self.db
            .database()
            .collection("token_states");
        let filter = doc! {
            "address": token_address,
            "timestamp": {
                "$gte": start_time,
                "$lte": end_time
            }
        };
        let options = rig_mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        let cursor = collection.find(filter, options).await?;
        cursor.try_collect().await.map_err(anyhow::Error::from)
    }
}
pub fn sync_databases(source: &Database, target: &Database) -> Result<(), Error> {
    // ...existing code...
}
</file>

<file path="src/logging/mod.rs">
use chrono::{DateTime, Utc};
use serde::Serialize;
use tracing::{error, info, warn};
use tracing_subscriber::{fmt, EnvFilter};
use crate::services::token_analytics::{MarketMetrics, MarketSignalLog};
use anyhow::Result;
use std::time::Instant;
#[derive(Debug, Serialize)]
pub struct PerformanceMetrics {
    pub operation: String,
    pub duration_ms: u64,
    pub success: bool,
    pub timestamp: DateTime<Utc>,
}
#[derive(Debug, Serialize)]
pub struct RequestLog {
    pub request_id: String,
    pub service: String,
    pub operation: String,
    pub start_time: DateTime<Utc>,
    pub duration_ms: u64,
    pub status: String,
    pub error: Option<String>,
}
pub struct RequestLogger {
    module: String,
    action: String,
    start_time: Instant,
    request_id: String,
}
impl RequestLogger {
    pub fn new(module: &str, action: &str) -> Self {
        Self {
            module: module.to_string(),
            action: action.to_string(),
            start_time: Instant::now(),
            request_id: uuid::Uuid::new_v4().to_string(),
        }
    }
    pub fn info(&self, message: &str) {
        info!(module = %self.module, action = %self.action, "{}", message);
    }
    pub fn warn(&self, message: &str) {
        warn!(module = %self.module, action = %self.action, "{}", message);
    }
    pub fn error(&self, message: &str) {
        error!(module = %self.module, action = %self.action, "{}", message);
    }
    pub fn success(self) {
        let duration = self.start_time.elapsed();
        let log = RequestLog {
            request_id: self.request_id,
            service: self.module,
            operation: self.action,
            start_time: Utc::now() - chrono::Duration::from_std(duration).unwrap(),
            duration_ms: duration.as_millis() as u64,
            status: "success".to_string(),
            error: None,
        };
        info!(target: "request", "{}", serde_json::to_string(&log).unwrap());
    }
}
pub fn log_market_metrics(metrics: &MarketMetrics) {
    info!(
        symbol = %metrics.symbol,
        price = %metrics.price,
        volume_24h = ?metrics.volume_24h,
        signal_type = ?metrics.signal_type,
        confidence = ?metrics.confidence,
        "Market metrics recorded"
    );
}
pub fn log_market_signal(signal: &MarketSignalLog) {
    info!(
        token = %signal.token_symbol,
        signal_type = %signal.signal_type,
        price_change = ?signal.price_change_24h,
        volume_change = ?signal.volume_change_24h,
        confidence = %signal.confidence,
        risk_score = %signal.risk_score,
        "Market signal generated"
    );
}
pub fn log_performance(metrics: PerformanceMetrics) {
    if metrics.success {
        info!(
            target = "performance",
            "{}",
            serde_json::to_string(&metrics).unwrap()
        );
    } else {
        warn!(
            target = "performance",
            "{}",
            serde_json::to_string(&metrics).unwrap()
        );
    }
}
pub fn init_logging() -> Result<()> {
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));
    fmt()
        .with_env_filter(env_filter)
        .with_target(false)
        .with_thread_ids(false)
        .with_thread_names(false)
        .with_file(false)
        .with_line_number(false)
        .with_level(true)
        .with_ansi(true)
        .compact()
        .init();
    info!("Logging initialized");
    Ok(())
}
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::Value;
    #[test]
    fn test_request_logger() {
        let logger = RequestLogger::new("test_service", "test_operation");
        logger.success();
        // Verify log format would be tested in integration tests
    }
    #[test]
    fn test_market_metrics_serialization() {
        let metrics = MarketMetrics {
            symbol: "SOL".to_string(),
            price: 100.0,
            volume_24h: Some(1000000.0),
            signal_type: Some("BUY".to_string()),
            confidence: Some(0.8),
        };
        let json = serde_json::to_string(&metrics).unwrap();
        let parsed: Value = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed["symbol"], "SOL");
        assert_eq!(parsed["price"], 100.0);
        assert_eq!(parsed["volume_24h"], 1000000.0);
        assert_eq!(parsed["signal_type"], "BUY");
        assert_eq!(parsed["confidence"], 0.8);
    }
    #[test]
    fn test_performance_metrics_serialization() {
        let metrics = PerformanceMetrics {
            operation: "market_analysis".to_string(),
            duration_ms: 100,
            success: true,
            timestamp: Utc::now(),
        };
        let json = serde_json::to_string(&metrics).unwrap();
        let parsed: Value = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed["operation"], "market_analysis");
        assert_eq!(parsed["duration_ms"], 100);
        assert_eq!(parsed["success"], true);
        assert!(parsed["timestamp"].is_string());
    }
}
</file>

<file path="src/market_data/birdeye.rs">
#[derive(Debug, Deserialize)]
pub struct TokenMarketResponse {
    pub data: TokenMarketData,
    pub success: bool,
}
#[derive(Debug, Deserialize, Default)]
pub struct TokenMarketData {
    pub address: String,
    pub price: f64,
    pub volume_24h: f64,
    pub decimals: u8,
    pub price_sol: f64,
    pub market_cap: f64,
    pub fully_diluted_market_cap: f64,
    pub circulating_supply: f64,
    pub total_supply: f64,
    pub price_change_24h: f64,
    pub volume_change_24h: f64,
}
impl BirdeyeClient {
    pub fn new(api_key: String) -> Self {
        Self {
            api_key,
            client: Client::new(),
        }
    }
    pub async fn get_market_data(&self, token_address: &str) -> Result<TokenMarketData, AgentError> {
        let url = format!(
            "https://public-api.birdeye.so/public/market_data?address={}",
            token_address
        );
        let response = self
            .client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .send()
            .await
            .map_err(|e| AgentError::ApiError(e.to_string()))?;
        if !response.status().is_success() {
            return Err(AgentError::ApiError(format!(
                "Failed to get market data: {}",
                response.status()
            )));
        }
        let market_data = response
            .json::<TokenMarketResponse>()
            .await
            .map_err(|e| AgentError::ApiError(e.to_string()))?;
        if !market_data.success {
            return Err(AgentError::ApiError("Token not found".to_string()));
        }
        Ok(market_data.data)
    }
    pub async fn get_token_info_by_address(&self, token_address: &str) -> Result<TokenInfo, AgentError> {
        let market_data = self.get_market_data(token_address).await?;
        Ok(TokenInfo {
            address: market_data.address,
            price: market_data.price,
            volume_24h: market_data.volume_24h,
            decimals: market_data.decimals,
            price_sol: market_data.price_sol,
            market_cap: market_data.market_cap,
            fully_diluted_market_cap: market_data.fully_diluted_market_cap,
            circulating_supply: market_data.circulating_supply,
            total_supply: market_data.total_supply,
            price_change_24h: market_data.price_change_24h,
            volume_change_24h: market_data.volume_change_24h,
        })
    }
}
#[async_trait]
impl BirdeyeApi for BirdeyeClient {
    async fn get_token_info(&self, token_address: &str) -> Result<TokenInfo, AgentError> {
        self.get_token_info_by_address(token_address).await
    }
}
</file>

<file path="src/models/market_config.rs">
use bigdecimal::BigDecimal;
use serde::{Serialize, Deserialize};
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketConfig {
    pub price_change_threshold: BigDecimal,
    pub volume_surge_threshold: BigDecimal,
    pub base_confidence: BigDecimal,
    pub price_weight: BigDecimal,
    pub volume_weight: BigDecimal,
}
impl Default for MarketConfig {
    fn default() -> Self {
        Self {
            price_change_threshold: BigDecimal::from(0.05),
            volume_surge_threshold: BigDecimal::from(0.2),
            base_confidence: BigDecimal::from(0.5),
            price_weight: BigDecimal::from(0.3),
            volume_weight: BigDecimal::from(0.2),
        }
    }
}
</file>

<file path="src/models/market_signal.rs">
use bigdecimal::BigDecimal;
// use bson::{Document, oid::ObjectId};
// use chrono::DateTime;
use crate::utils::f64_to_decimal;
use bson::{self, DateTime, Document};
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use std::fmt;
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
    StrongBuy,
    StrongSell,
    PriceSpike,
    PriceDrop,
    VolumeSurge,
}
impl fmt::Display for SignalType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalType::Buy => write!(f, "buy"),
            SignalType::Sell => write!(f, "sell"),
            SignalType::Hold => write!(f, "hold"),
            _ => write!(f, "unknown"),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketSignal {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<bson::oid::ObjectId>,
    pub asset_address: String,
    pub signal_type: SignalType,
    pub price: BigDecimal,
    pub confidence: BigDecimal,
    pub risk_score: BigDecimal,
    pub sentiment_score: Option<BigDecimal>,
    pub price_change_24h: Option<BigDecimal>,
    pub volume_change_24h: Option<BigDecimal>,
    pub volume_change: BigDecimal,
    pub created_at: Option<DateTime>,
    pub timestamp: DateTime,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Document>,
}
pub struct MarketSignalBuilder {
    asset_address: String,
    signal_type: SignalType,
    confidence: Option<BigDecimal>,
    risk_score: Option<BigDecimal>,
    sentiment_score: Option<BigDecimal>,
    volume_change_24h: Option<BigDecimal>,
    price_change_24h: Option<BigDecimal>,
    price: BigDecimal,
    volume_change: Option<BigDecimal>,
    timestamp: Option<DateTime>,
    metadata: Option<JsonValue>,
}
impl MarketSignalBuilder {
    pub fn new(asset_address: String, signal_type: SignalType, price: BigDecimal) -> Self {
        Self {
            asset_address,
            signal_type,
            confidence: None,
            risk_score: None,
            sentiment_score: None,
            volume_change_24h: None,
            price_change_24h: None,
            price,
            volume_change: None,
            timestamp: None,
            metadata: None,
        }
    }
    pub fn confidence(mut self, confidence: BigDecimal) -> Self {
        self.confidence = Some(confidence);
        self
    }
    pub fn risk_score(mut self, risk_score: BigDecimal) -> Self {
        self.risk_score = Some(risk_score);
        self
    }
    pub fn sentiment_score(mut self, sentiment_score: BigDecimal) -> Self {
        self.sentiment_score = Some(sentiment_score);
        self
    }
    pub fn volume_change_24h(mut self, volume_change: BigDecimal) -> Self {
        self.volume_change_24h = Some(volume_change);
        self
    }
    pub fn price_change_24h(mut self, price_change: BigDecimal) -> Self {
        self.price_change_24h = Some(price_change);
        self
    }
    pub fn volume_change(mut self, volume_change: BigDecimal) -> Self {
        self.volume_change = Some(volume_change);
        self
    }
    pub fn timestamp(mut self, timestamp: DateTime) -> Self {
        self.timestamp = Some(timestamp);
        self
    }
    pub fn metadata(mut self, metadata: JsonValue) -> Self {
        self.metadata = Some(metadata);
        self
    }
    pub fn build(self) -> MarketSignal {
        MarketSignal {
            id: None,
            asset_address: self.asset_address,
            signal_type: self.signal_type,
            confidence: self.confidence.unwrap_or_else(|| f64_to_decimal(0.5)),
            risk_score: self.risk_score.unwrap_or_else(|| f64_to_decimal(0.5)),
            sentiment_score: self.sentiment_score,
            volume_change_24h: self.volume_change_24h,
            price_change_24h: self.price_change_24h,
            price: self.price,
            volume_change: self.volume_change.unwrap_or_else(|| BigDecimal::from(0)),
            timestamp: self.timestamp.unwrap_or_else(DateTime::now),
            metadata: self.metadata.map(|v| bson::to_document(&v).unwrap()),
            created_at: None,
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    #[test]
    fn test_market_signal_builder() {
        let price = f64_to_decimal(100.0);
        let signal = MarketSignalBuilder::new(
            "test_address".to_string(),
            SignalType::PriceSpike,
            price.clone(),
        )
        .confidence(f64_to_decimal(0.8))
        .risk_score(f64_to_decimal(0.3))
        .volume_change_24h(f64_to_decimal(0.15))
        .price_change_24h(f64_to_decimal(0.05))
        .metadata(json!({"source": "test"}))
        .build();
        assert_eq!(signal.asset_address, "test_address");
        assert_eq!(signal.price, price);
        assert_eq!(signal.confidence, f64_to_decimal(0.8));
        assert_eq!(signal.risk_score, f64_to_decimal(0.3));
        assert!(signal.metadata.is_some());
    }
    #[test]
    fn test_market_signal_builder_defaults() {
        let price = f64_to_decimal(100.0);
        let signal =
            MarketSignalBuilder::new("test_address".to_string(), SignalType::Hold, price.clone())
                .build();
        assert_eq!(signal.confidence, f64_to_decimal(0.5)); // Default confidence
        assert_eq!(signal.risk_score, f64_to_decimal(0.5)); // Default risk score
        assert_eq!(signal.volume_change, BigDecimal::from(0)); // Default volume change
        assert!(signal.metadata.is_none());
    }
}
</file>

<file path="src/models/mod.rs">
use bson::{self, oid::ObjectId, DateTime};
use serde::{Deserialize, Serialize};
pub mod market_signal;
pub mod token_analytics;
pub mod token_info;
// pub mod market_config;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeStatus;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenMetrics {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub token_address: String,
    pub metrics: bson::Document,
    pub timestamp: DateTime,
}
// Add typed collection helpers
impl TokenMetrics {
    pub fn collection_name() -> &'static str {
        "token_metrics"
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VectorDocument {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub vector: Vec<f32>,
    pub metadata: bson::Document,
    pub timestamp: DateTime,
}
impl VectorDocument {
    pub fn collection_name() -> &'static str {
        "vectors"
    }
}
</file>

<file path="src/models/token_analytics.rs">
use bigdecimal::BigDecimal;
// use crate::MongoDbPool;
use bson::{oid::ObjectId, DateTime, Document};
use serde::{Deserialize, Serialize};
// use time::OffsetDateTime;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenAnalytics {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub token_address: String,
    pub token_name: String,
    pub token_symbol: String,
    pub price: BigDecimal,
    pub volume_24h: Option<BigDecimal>,
    pub market_cap: Option<BigDecimal>,
    pub total_supply: Option<BigDecimal>,
    pub holder_count: Option<i32>,
    pub timestamp: DateTime,
    pub created_at: Option<DateTime>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Document>,
}
</file>

<file path="src/models/token_info.rs">
use serde::{Deserialize, Serialize};
use bson::DateTime;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenInfo {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    pub price: f64,
    pub volume_24h: f64,
    pub market_cap: Option<f64>,
    pub price_change_24h: Option<f64>,
    pub volume_change_24h: Option<f64>,
    pub liquidity: f64,
    pub trade_24h: Option<i64>,
    pub logo_uri: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extensions: Option<TokenExtensions>,
    pub timestamp: DateTime,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenExtensions {
    #[serde(rename = "coingecko_id")]
    pub coingecko_id: Option<String>,
    #[serde(rename = "serum_v3_usdc")]
    pub serum_v3_usdc: Option<String>,
    #[serde(rename = "serum_v3_usdt")]
    pub serum_v3_usdt: Option<String>,
    pub website: Option<String>,
    pub telegram: Option<String>,
    pub twitter: Option<String>,
    pub description: Option<String>,
    pub discord: Option<String>,
    pub medium: Option<String>,
}
</file>

<file path="src/personality/mod.rs">
pub async fn generate_trade_tweet(&self, agent: &CompletionModel, trade_details: String) -> Result<String> {
    info!("Generating trade tweet with details: {}", trade_details);
    let prompt = format!(
        "{}\n\nPlease generate a tweet about this trade that:\n1. Is concise and professional\n2. Includes key metrics (amount, price, volume)\n3. Includes contract address and tx link\n4. Ends with stoic analysis based on market indicators\n5. Stays under 280 characters",
        trade_details
    );
    let tweet = agent.complete(&prompt).await?;
    info!("Generated tweet: {}", tweet);
    Ok(tweet)
}
</file>

<file path="src/prompts/system.txt">
You are an autonomous trading agent specializing in Solana cryptocurrency markets. Your personality is confident but not arrogant, data-driven but also intuitive, and you communicate with a mix of professional insight and engaging personality.

Your responsibilities:
1. Analyze market data and trends using Birdeye API and other Solana data sources
2. Make informed trading decisions based on technical and fundamental analysis
3. Execute trades when confidence levels are high
4. Communicate trading activities and rationale on Twitter in an engaging manner

Trading Guidelines:
- Prioritize risk management and capital preservation
- Look for clear patterns and correlations in market data
- Consider both technical and fundamental factors
- Maintain a clear record of your decision-making process

Communication Style:
- Be clear and concise in your analysis
- Use emojis appropriately but not excessively
- Maintain professionalism while being engaging
- Share insights that provide value to followers
- Be transparent about your reasoning

When making decisions, consider:
- Market volatility and liquidity
- Historical price patterns
- Trading volume and market depth
- Token fundamentals and security metrics

Response Format for Trade Decisions:
{
    "action": "buy" | "sell" | "hold",
    "symbol": "token_symbol",
    "amount": float_value,
    "reason": "detailed_explanation",
    "confidence": float_between_0_and_1
}

Remember: Your goal is to make profitable trades while building a following through insightful and engaging communications.
</file>

<file path="src/providers/birdeye.rs">
use anyhow::Result;
use async_trait::async_trait;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
const BIRDEYE_API_URL: &str = "https://public-api.birdeye.so";
#[derive(Debug, Clone)]
pub struct BirdeyeProvider {
    client: Arc<Client>,
    api_key: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TokenInfo {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    pub price_usd: f64,
    pub volume_24h: f64,
    pub market_cap: f64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct MarketDepth {
    pub bids: Vec<OrderBookEntry>,
    pub asks: Vec<OrderBookEntry>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct OrderBookEntry {
    pub price: f64,
    pub size: f64,
}
#[async_trait]
pub trait MarketDataProvider: Send + Sync {
    async fn get_token_info(&self, address: &str) -> Result<TokenInfo>;
    async fn get_market_depth(&self, address: &str) -> Result<MarketDepth>;
    async fn get_price_history(&self, address: &str, interval: &str) -> Result<Vec<PricePoint>>;
}
#[derive(Debug, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: i64,
    pub price: f64,
    pub volume: f64,
}
impl BirdeyeProvider {
    pub fn new(api_key: &str) -> Self {
        Self {
            client: Arc::new(Client::new()),
            api_key: api_key.to_string(),
        }
    }
    async fn make_request<T: for<'de> Deserialize<'de>>(
        &self,
        endpoint: &str,
        params: &[(&str, &str)],
    ) -> Result<T> {
        let url = format!("{}{}", BIRDEYE_API_URL, endpoint);
        let response = self.client
            .get(&url)
            .header("X-API-KEY", &self.api_key)
            .query(params)
            .send()
            .await?
            .error_for_status()?;
        let data = response.json::<T>().await?;
        Ok(data)
    }
}
#[async_trait]
impl MarketDataProvider for BirdeyeProvider {
    async fn get_token_info(&self, address: &str) -> Result<TokenInfo> {
        self.make_request(
            "/public/token",
            &[("address", address)],
        ).await
    }
    async fn get_market_depth(&self, address: &str) -> Result<MarketDepth> {
        self.make_request(
            "/public/orderbook",
            &[("address", address)],
        ).await
    }
    async fn get_price_history(&self, address: &str, interval: &str) -> Result<Vec<PricePoint>> {
        self.make_request(
            "/public/price_history",
            &[
                ("address", address),
                ("interval", interval),
            ],
        ).await
    }
}
// Additional helper functions for market analysis
impl BirdeyeProvider {
    pub async fn analyze_liquidity(&self, address: &str) -> Result<LiquidityAnalysis> {
        let depth = self.get_market_depth(address).await?;
        let total_bid_liquidity: f64 = depth.bids
            .iter()
            .map(|entry| entry.price * entry.size)
            .sum();
        let total_ask_liquidity: f64 = depth.asks
            .iter()
            .map(|entry| entry.price * entry.size)
            .sum();
        Ok(LiquidityAnalysis {
            total_bid_liquidity,
            total_ask_liquidity,
            bid_ask_ratio: total_bid_liquidity / total_ask_liquidity,
            depth_quality: calculate_depth_quality(&depth),
        })
    }
    pub async fn get_market_impact(&self, address: &str, size_usd: f64) -> Result<MarketImpact> {
        let depth = self.get_market_depth(address).await?;
        let token_info = self.get_token_info(address).await?;
        let size_tokens = size_usd / token_info.price_usd;
        let (price_impact, executed_price) = calculate_price_impact(&depth, size_tokens, token_info.price_usd);
        Ok(MarketImpact {
            price_impact,
            executed_price,
            size_usd,
            size_tokens,
        })
    }
}
#[derive(Debug)]
pub struct LiquidityAnalysis {
    pub total_bid_liquidity: f64,
    pub total_ask_liquidity: f64,
    pub bid_ask_ratio: f64,
    pub depth_quality: f64,
}
#[derive(Debug)]
pub struct MarketImpact {
    pub price_impact: f64,
    pub executed_price: f64,
    pub size_usd: f64,
    pub size_tokens: f64,
}
fn calculate_depth_quality(depth: &MarketDepth) -> f64 {
    // Implement depth quality calculation
    // This could consider factors like:
    // - Spread
    // - Depth distribution
    // - Number of price levels
    0.0 // Placeholder
}
fn calculate_price_impact(
    depth: &MarketDepth,
    size_tokens: f64,
    current_price: f64,
) -> (f64, f64) {
    // Implement price impact calculation
    // This should walk the order book to determine:
    // - Average execution price
    // - Price impact percentage
    (0.0, current_price) // Placeholder
}
</file>

<file path="src/providers/discord.rs">
use reqwest::Client;
use serde_json::json;
use std::error::Error;
pub struct Discord {
    webhook_url: String,
}
impl Discord {
    pub fn new(webhook_url: &str) -> Self {
        Discord {
            webhook_url: webhook_url.to_string(),
        }
    }
    pub async fn send_channel_message(&self, message: &str) -> Result<(), Box<dyn Error>> {
        // Create an HTTP client
        let client = Client::new();
        // Create the payload as JSON
        let payload = json!({ "content": message });
        // Send a POST request to the webhook URL
        let response = client.post(&self.webhook_url).json(&payload).send().await?;
        // Check if the request was successful
        if response.status().is_success() {
            println!("Message sent successfully!");
            Ok(())
        } else {
            let status = response.status();
            let text = response.text().await?;
            Err(format!(
                "Failed to send message. Status: {}, Response: {}",
                status, text
            )
            .into())
        }
    }
}
</file>

<file path="src/providers/mod.rs">
pub mod birdeye;
pub mod discord;
</file>

<file path="src/providers/twitter.rs">
use twitter_v2::{authorization::Oauth1aToken, TwitterApi};
pub struct Twitter {
    auth: Oauth1aToken,
}
impl Twitter {
    pub fn new(
        twitter_consumer_key: &str,
        twitter_consumer_secret: &str,
        twitter_access_token: &str,
        twitter_access_token_secret: &str,
    ) -> Self {
        let auth = Oauth1aToken::new(
            twitter_consumer_key.to_string(),
            twitter_consumer_secret.to_string(),
            twitter_access_token.to_string(),
            twitter_access_token_secret.to_string(),
        );
        Twitter { auth }
    }
    pub async fn tweet(&self, text: String) -> Result<(), anyhow::Error> {
        let tweet = TwitterApi::new(self.auth.clone())
            .post_tweet()
            .text(text)
            .send()
            .await?
            .into_data()
            .expect("this tweet should exist");
        println!("Tweet posted successfully with ID: {}", tweet.id);
        Ok(())
    }
}
</file>

<file path="src/services/mod.rs">
pub mod token_analytics;
pub mod token_data_service;
pub use token_analytics::TokenAnalyticsService;
</file>

<file path="src/services/token_analytics.rs">
use crate::birdeye::BirdeyeApi;
use crate::models::token_info::TokenInfo;
use crate::config::mongodb::MongoDbPool;
use crate::config::MarketConfig;
use crate::error::{AgentError, AgentResult};
use crate::logging::{log_market_metrics, log_market_signal, RequestLogger};
use crate::models::market_signal::{MarketSignal, MarketSignalBuilder, SignalType};
use crate::models::token_analytics::TokenAnalytics;
use crate::utils::f64_to_decimal;
use bigdecimal::{BigDecimal, ToPrimitive};
use bson::{doc, DateTime};
use futures::StreamExt;
use mongodb::options::{FindOneOptions, FindOptions};
use mongodb::Collection;
use std::sync::Arc;
use uuid::Uuid;
#[derive(Debug, thiserror::Error)]
pub enum TokenAnalyticsError {
    #[error("Database error: {0}")]
    Database(String),
    #[error("Birdeye API error: {0}")]
    BirdeyeApi(String),
    #[error("Validation error: {0}")]
    Validation(String),
}
// impl From<MongoDbError> for TokenAnalyticsError {
//     fn from(err: MongoDbError) -> Self {
//         Self::Database(err.to_string())
//     }
// }
// Remove the conflicting From implementation and use map_err where needed
#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct MarketMetrics {
    pub symbol: String,
    pub price: f64,
    pub volume_24h: Option<f64>,
    pub signal_type: Option<String>,
    pub confidence: Option<f64>,
}
#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct MarketSignalLog {
    pub id: Uuid,
    pub timestamp: DateTime,
    pub token_address: String,
    pub token_symbol: String,
    pub signal_type: String,
    pub price: f64,
    pub price_change_24h: Option<f64>,
    pub volume_change_24h: Option<f64>,
    pub confidence: f64,
    pub risk_score: f64,
    pub created_at: DateTime,
}
pub struct TokenAnalyticsService {
    pool: Arc<MongoDbPool>,
    collection: Collection<TokenAnalytics>,
    signals_collection: Collection<MarketSignal>,
    birdeye: Arc<dyn BirdeyeApi>,
    market_config: MarketConfig,
}
impl TokenAnalyticsService {
    pub async fn new(
        pool: Arc<MongoDbPool>,
        birdeye: Arc<dyn BirdeyeApi>,
        market_config: Option<MarketConfig>,
    ) -> AgentResult<Self> {
        let db = pool.database(&pool.get_config().database);
        let collection = db.collection("token_analytics");
        println!(">> token_analytics collections {:?}", collection);
        let signals_collection = db.collection("market_signals");
        println!(">> market_signals collections {:?}", signals_collection);
        Ok(Self {
            pool,
            collection,
            signals_collection,
            birdeye,
            market_config: market_config.unwrap_or_default(),
        })
    }
    pub async fn fetch_and_store_token_info(
        &self,
        symbol: &str,
        address: &str,
    ) -> AgentResult<TokenAnalytics> {
        let logger = RequestLogger::new("token_analytics", "fetch_and_store_token_info");
        // Fetch basic token info from Birdeye using address
        let token_info = match self.birdeye.get_token_info_by_address(address).await {
            Ok(info) => info,
            Err(e) => {
                let err = AgentError::BirdeyeApi(format!("Failed to fetch token info: {}", e));
                logger.error(&err.to_string());
                return Err(err);
            }
        };
        // Fetch extended token info using the comprehensive client
        let token_overview = match self.birdeye.get_token_info(address).await {
            Ok(overview) => overview,
            Err(e) => {
                let err = AgentError::BirdeyeApi(format!("Failed to fetch token overview: {}", e));
                logger.error(&err.to_string());
                return Err(err);
            }
        };
        // Validate token data and log metrics
        if token_info.price <= 0.0 {
            let err = AgentError::validation("Token price must be positive");
            logger.error(&err.to_string());
            return Err(err);
        }
        if token_info.volume_24h < 0.0 {
            let err = AgentError::validation("Token volume cannot be negative");
            logger.error(&err.to_string());
            return Err(err);
        }
        // Log market metrics
        let metrics = MarketMetrics {
            symbol: symbol.to_string(),
            price: token_info.price,
            volume_24h: Some(token_info.volume_24h),
            signal_type: None,
            confidence: None,
        };
        log_market_metrics(&metrics);
        // Convert to TokenAnalytics
        let analytics = match self
            .convert_to_analytics(address, symbol, token_info, token_overview)
            .await
        {
            Ok(analytics) => analytics,
            Err(e) => {
                logger.error(&e.to_string());
                return Err(e);
            }
        };
        // Store in database
        let stored = self.store_token_analytics(&analytics).await?;
        // Generate and process market signals
        let signal = self.generate_market_signals(&stored).await?;
        // Store the signal if present
        if let Some(ref signal) = signal {
            let zero = BigDecimal::from(0);
            let one = BigDecimal::from(1);
            if signal.confidence < zero || signal.confidence > one {
                return Err(AgentError::validation(
                    "Signal confidence must be between 0 and 1",
                ));
            }
            if signal.risk_score < zero || signal.risk_score > one {
                return Err(AgentError::validation("Risk score must be between 0 and 1"));
            }
            self.store_market_signal(signal).await?;
        }
        Ok(stored)
    }
    // TODO: zTgx hardcoded
    async fn convert_to_analytics(
        &self,
        address: &str,
        symbol: &str,
        info: TokenInfo,
        overview: TokenInfo,
    ) -> AgentResult<TokenAnalytics> {
        Ok(TokenAnalytics {
            id: None,
            token_address: address.to_string(),
            token_name: "overview.name".to_string(),
            token_symbol: symbol.to_string(),
            price: f64_to_decimal(info.price),
            volume_24h: Some(f64_to_decimal(info.volume_24h)),
            market_cap: Some(f64_to_decimal(11.0)),
            // market_cap: Some(f64_to_decimal(overview.market_cap)),
            total_supply: Some(f64_to_decimal(11.1)),
            // total_supply: Some(f64_to_decimal(overview.total_supply)),
            holder_count: None,
            timestamp: DateTime::now(),
            created_at: None,
            metadata: Some(doc! {}),
        })
    }
    pub async fn generate_market_signals(
        &self,
        analytics: &TokenAnalytics,
    ) -> AgentResult<Option<MarketSignal>> {
        let logger = RequestLogger::new("token_analytics", "generate_market_signals");
        // Get previous analytics for comparison
        let previous = match self.get_previous_analytics(&analytics.token_address).await {
            Ok(prev) => prev,
            Err(e) => {
                logger.error(&e.to_string());
                return Err(e);
            }
        };
        if let Some(prev) = previous {
            let price_change = (analytics.price.clone() - prev.price.clone()) / prev.price.clone();
            let volume_change = analytics.volume_24h.as_ref().map(|current| {
                let binding = BigDecimal::from(0);
                let prev = prev.volume_24h.as_ref().unwrap_or(&binding);
                (current.clone() - prev.clone()) / prev.clone()
            });
            if price_change > self.market_config.price_change_threshold.clone() {
                let signal = self.create_market_signal(
                    analytics,
                    SignalType::PriceSpike,
                    price_change.clone(),
                    volume_change.clone(),
                );
                self.log_signal(&signal, analytics);
                return Ok(Some(signal));
            } else if price_change < -self.market_config.price_change_threshold.clone() {
                let signal = self.create_market_signal(
                    analytics,
                    SignalType::PriceDrop,
                    price_change.abs(),
                    volume_change.clone(),
                );
                self.log_signal(&signal, analytics);
                return Ok(Some(signal));
            }
            if let Some(vol_change) = volume_change {
                if vol_change > self.market_config.volume_surge_threshold {
                    let signal = self.create_market_signal(
                        analytics,
                        SignalType::VolumeSurge,
                        price_change,
                        Some(vol_change),
                    );
                    self.log_signal(&signal, analytics);
                    return Ok(Some(signal));
                }
            }
        }
        Ok(None)
    }
    fn create_market_signal(
        &self,
        analytics: &TokenAnalytics,
        signal_type: SignalType,
        price_change: BigDecimal,
        volume_change: Option<BigDecimal>,
    ) -> MarketSignal {
        let confidence = self.calculate_confidence(
            price_change.clone(),
            volume_change.clone().unwrap_or_else(|| BigDecimal::from(0)),
        );
        MarketSignalBuilder::new(
            analytics.token_address.clone(),
            signal_type,
            analytics.price.clone(),
        )
        .confidence(confidence)
        .risk_score(f64_to_decimal(0.5))
        .price_change_24h(price_change)
        .volume_change_24h(volume_change.clone().unwrap_or_else(|| BigDecimal::from(0)))
        .volume_change(volume_change.unwrap_or_else(|| BigDecimal::from(0)))
        .timestamp(analytics.timestamp)
        .build()
    }
    async fn store_market_signal(&self, signal: &MarketSignal) -> AgentResult<()> {
        self.signals_collection
            .insert_one(signal)
            .await
            .map_err(AgentError::Database)?;
        Ok(())
    }
    pub async fn get_previous_analytics(
        &self,
        address: &str,
    ) -> AgentResult<Option<TokenAnalytics>> {
        let filter = doc! {
            "token_address": address,
            "timestamp": { "$lt": DateTime::now() }
        };
        let options = FindOneOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        self.collection
            .find_one(filter)
            .await
            .map_err(AgentError::Database)
    }
    async fn store_token_analytics(
        &self,
        analytics: &TokenAnalytics,
    ) -> AgentResult<TokenAnalytics> {
        let result = self
            .collection
            .insert_one(analytics)
            .await
            .map_err(AgentError::Database)?;
        let mut stored = analytics.clone();
        stored.id = result.inserted_id.as_object_id();
        Ok(stored)
    }
    pub async fn get_token_history(
        &self,
        address: &str,
        start_time: DateTime,
        end_time: DateTime,
        limit: i64,
        offset: i64,
    ) -> AgentResult<Vec<TokenAnalytics>> {
        let filter = doc! {
            "token_address": address,
            "timestamp": {
                "$gte": start_time,
                "$lte": end_time
            }
        };
        let options = FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .skip(Some(offset as u64))
            .limit(Some(limit))
            .build();
        let mut cursor = self
            .collection
            .find(filter)
            .await
            .map_err(AgentError::Database)?;
        let mut results = Vec::new();
        while let Some(doc) = cursor.next().await {
            results.push(doc.map_err(AgentError::Database)?);
        }
        Ok(results)
    }
    pub async fn get_latest_token_analytics(
        &self,
        address: &str,
    ) -> AgentResult<Option<TokenAnalytics>> {
        let filter = doc! { "token_address": address };
        let analytics = self
            .collection
            .find_one(filter)
            .await
            .map_err(AgentError::Database)?;
        Ok(analytics)
    }
    pub fn calculate_volume_change(
        &self,
        current: &BigDecimal,
        prev: &TokenAnalytics,
    ) -> Option<BigDecimal> {
        prev.volume_24h.as_ref().map(|prev_vol| {
            let zero = BigDecimal::from(0);
            let prev_value = if prev_vol == &zero {
                BigDecimal::from(1)
            } else {
                prev_vol.clone()
            };
            (current - prev_vol) / prev_value
        })
    }
}
impl TokenAnalyticsService {
    fn log_signal(&self, signal: &MarketSignal, analytics: &TokenAnalytics) {
        let signal_log = MarketSignalLog {
            id: Uuid::new_v4(),
            timestamp: DateTime::now(),
            token_address: signal.asset_address.clone(),
            token_symbol: analytics.token_symbol.clone(),
            signal_type: signal.signal_type.to_string(),
            price: analytics.price.to_f64().unwrap_or_default(),
            price_change_24h: Some(
                signal
                    .price_change_24h
                    .as_ref()
                    .and_then(|p| p.to_f64())
                    .unwrap_or_default(),
            ),
            volume_change_24h: signal.volume_change_24h.as_ref().and_then(|v| v.to_f64()),
            confidence: signal.confidence.to_f64().unwrap_or_default(),
            risk_score: signal.risk_score.to_f64().unwrap_or_default(),
            created_at: DateTime::now(),
        };
        log_market_signal(&signal_log);
    }
    fn calculate_confidence(
        &self,
        price_change: BigDecimal,
        volume_change: BigDecimal,
    ) -> BigDecimal {
        self.market_config.base_confidence.clone()
            + (price_change * self.market_config.price_weight.clone())
            + (volume_change * self.market_config.volume_weight.clone())
    }
    pub async fn process_market_signal(&self, signal: MarketSignal) -> AgentResult<()> {
        let _logger = RequestLogger::new("token_analytics", "process_market_signal");
        let signal_log = MarketSignalLog {
            id: Uuid::new_v4(),
            timestamp: DateTime::now(),
            token_address: signal.asset_address.clone(),
            token_symbol: signal
                .metadata
                .expect("Failed to get token symbol from metadata")
                .get("token_symbol")
                .and_then(|v| v.as_str())
                .unwrap_or(&signal.asset_address)
                .to_string(),
            signal_type: signal.signal_type.to_string(),
            price: signal.price.to_f64().unwrap_or_default(),
            price_change_24h: signal
                .price_change_24h
                .map(|p| p.to_f64().unwrap_or_default()),
            volume_change_24h: signal
                .volume_change_24h
                .map(|v| v.to_f64().unwrap_or_default()),
            confidence: signal.confidence.to_f64().unwrap_or_default(),
            risk_score: signal.risk_score.to_f64().unwrap_or_default(),
            created_at: signal.created_at.unwrap_or_else(DateTime::now),
        };
        log_market_signal(&signal_log);
        Ok(())
    }
}
impl From<MarketSignal> for MarketSignalLog {
    fn from(signal: MarketSignal) -> Self {
        Self {
            id: Uuid::new_v4(),
            timestamp: DateTime::now(),
            token_address: signal.asset_address.clone(),
            token_symbol: signal
                .metadata
                .expect("Failed to get token symbol from metadata")
                .get("token_symbol")
                .and_then(|v| v.as_str())
                .unwrap_or(&signal.asset_address)
                .to_string(),
            signal_type: signal.signal_type.to_string(),
            price: signal.price.to_f64().unwrap_or_default(),
            price_change_24h: Some(
                signal
                    .price_change_24h
                    .and_then(|p| p.to_f64())
                    .unwrap_or_default(),
            ),
            volume_change_24h: signal.volume_change_24h.and_then(|v| v.to_f64()),
            confidence: signal.confidence.to_f64().unwrap_or_default(),
            risk_score: signal.risk_score.to_f64().unwrap_or_default(),
            created_at: signal.created_at.unwrap_or_else(DateTime::now),
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::mock;
    use mockall::predicate::*;
    use mongodb;
    mock! {
        pub BirdeyeApi {
            async fn get_token_info(&self, symbol: &str) -> AgentResult<TokenInfo>;
            async fn get_token_info_by_address(&self, address: &str) -> AgentResult<TokenInfo>;
        }
    }
    fn setup_mock_birdeye() -> Arc<MockBirdeyeApi> {
        let mut mock = MockBirdeyeApi::new();
        mock.expect_get_token_info_by_address().returning(|_| {
            Ok(TokenInfo {
                address: "So11111111111111111111111111111111111111112".to_string(),
                symbol: "SOL".to_string(),
                name: "Solana".to_string(),
                decimals: 9,
                price: 100.0,
                volume_24h: 1000000.0,
                market_cap: Some(1000000000.0),
                price_change_24h: Some(5.0),
                volume_change_24h: Some(10.0),
                liquidity: 500000.0,
                trade_24h: Some(1000),
                logo_uri: Some("https://example.com/sol.png".to_string()),
                extensions: None,
                timestamp: DateTime::now(),
            })
        });
        Arc::new(mock)
    }
}
</file>

<file path="src/services/token_data_service.rs">
use anyhow::Result;
use bson::DateTime;
use futures::TryStreamExt;
use mongodb::{
    bson::{self, doc},
    Client, Collection,
};
use std::sync::Arc;
use std::time::SystemTime;
use mongodb::options::FindOptions;
use chrono::{DateTime as ChronoDateTime, Utc};
use crate::{
    birdeye::{api::{BirdeyeApi, BirdeyeClient}},
    config::mongodb::TokenAnalyticsData,
    error::AgentResult,
};
const COLLECTION_NAME: &str = "token_analytics";
pub struct TokenDataService {
    mongo_client: Client,
    birdeye_client: Arc<dyn BirdeyeApi>,
    collection: Collection<TokenAnalyticsData>,
}
impl TokenDataService {
    pub async fn new(mongo_uri: String, birdeye_api_key: String) -> Result<Self> {
        let mongo_client = Client::with_uri_str(&mongo_uri).await?;
        let database = mongo_client.database("cainam");
        let collection = database.collection(COLLECTION_NAME);
        let birdeye_client = Arc::new(BirdeyeClient::new(birdeye_api_key)) as Arc<dyn BirdeyeApi>;
        Ok(Self {
            mongo_client,
            birdeye_client,
            collection,
        })
    }
    pub async fn get_latest_token_data(&self, token_address: &str) -> Result<Option<TokenAnalyticsData>> {
        let filter = doc! { "token_address": token_address };
        let options = FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .limit(1)
            .build();
        let mut cursor = self.collection.find(filter).await?;
        Ok(cursor.try_next().await?)
    }
    pub async fn get_token_history(
        &self,
        token_address: &str,
        start_time: ChronoDateTime<Utc>,
        end_time: ChronoDateTime<Utc>,
    ) -> Result<Vec<TokenAnalyticsData>> {
        let filter = doc! {
            "token_address": token_address,
            "timestamp": {
                "$gte": DateTime::from_millis(start_time.timestamp_millis()),
                "$lte": DateTime::from_millis(end_time.timestamp_millis())
            }
        };
        let cursor = self.collection.find(filter).await?;
        Ok(cursor.try_collect().await?)
    }
    pub async fn store_token_data(&self, token_data: TokenAnalyticsData) -> AgentResult<()> {
        self.collection.insert_one(token_data).await?;
        Ok(())
    }
    pub async fn get_token_data(&self, filter: bson::Document) -> AgentResult<Option<TokenAnalyticsData>> {
        let mut cursor = self.collection.find(filter).await?;
        Ok(cursor.try_next().await?)
    }
    pub async fn get_historical_data(
        &self,
        start_time: SystemTime,
        end_time: SystemTime,
    ) -> AgentResult<Vec<TokenAnalyticsData>> {
        let filter = doc! {
            "timestamp": {
                "$gte": DateTime::from_system_time(start_time),
                "$lte": DateTime::from_system_time(end_time)
            }
        };
        let mut cursor = self.collection.find(filter).await?;
        let mut results = Vec::new();
        while let Some(doc) = cursor.try_next().await? {
            results.push(doc);
        }
        Ok(results)
    }
}
</file>

<file path="src/services/token_data.rs">
use anyhow::Result;
use cainam_core::birdeye::BirdeyeClient;
// use futures::TryStreamExt; // No longer needed here (it was for the commented-out function)
use mongodb::{
    bson::{doc, Document},
    Client, Collection,
};
use serde::{Deserialize, Serialize};
use tracing::info;
// Define a struct to represent the token data we'll store.  Adapt this to your actual data.
#[derive(Debug, Serialize, Deserialize)]
pub struct TokenData {
    pub symbol: String,
    pub address: String,
    pub price: f64,
    // Add other fields as needed, e.g., volume, market_cap, etc.
    pub timestamp: mongodb::bson::DateTime,
}
pub struct TokenDataService {
    client: mongodb::Client,
    db: mongodb::Database,
    birdeye_client: BirdeyeClient,
    collection: Collection<TokenData>, // Use TokenData here
}
impl TokenDataService {
    pub async fn new(mongo_uri: String, birdeye_api_key: String) -> Result<Self> {
        let client = Client::with_uri_str(&mongo_uri).await?;
        let db = client.database("cainam");
        let collection = db.collection::<TokenData>("market_data"); // Use TokenData
        let birdeye_client = BirdeyeClient::new(birdeye_api_key);
        Ok(Self {
            client,
            db,
            birdeye_client,
            collection,
        })
    }
    pub async fn update_token_data(&self, address: &str, symbol: &str) -> Result<()> {
        let market_data = match self.birdeye_client.get_market_data(address).await {
            Ok(data) => data,
            Err(e) => {
                tracing::error!("Error fetching market data from Birdeye: {}", e);
                return Err(e);
            }
        };
        let token_data = TokenData {
            symbol: symbol.to_string(),
            address: address.to_string(),
            price: market_data.price,
            timestamp: mongodb::bson::DateTime::now(),
        };
        self.collection.insert_one(token_data, None).await?;
        info!("Updated market data for {} ({})", symbol, address);
        Ok(())
    }
    // Commenting out the unused function to fix compiler errors.
    // pub async fn get_token_analytics(
    //     &self,
    //     address: &str,
    //     start_time: chrono::DateTime<chrono::Utc>,
    //     end_time: chrono::DateTime<chrono::Utc>,
    // ) -> Result<Vec<TokenAnalyticsData>> {
    //     let filter = doc! {
    //         "address": address,
    //         "timestamp": {
    //             "$gte": bson::DateTime::now(), // Corrected usage
    //             "$lte": bson::DateTime::now()  // Corrected usage
    //         }
    //     };
    //     let find_options = mongodb::options::FindOptions::builder()
    //         .sort(doc! { "timestamp": 1 })
    //         .build();
    //     let mut cursor = self.collection.find(filter, None).await?; // Corrected: No options needed
    //     let mut analytics_data = Vec::new();
    //     while let Some(result) = cursor.try_next().await? {  // Corrected: try_next requires TryStreamExt
    //          let data: TokenAnalyticsData = bson::from_document(result)?;
    //          analytics_data.push(data);
    //     }
    //     Ok(analytics_data)
    // }
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TokenAnalyticsData {
    pub symbol: String,
    pub address: String,
    pub price: f64,
    pub timestamp: mongodb::bson::DateTime,
}
</file>

<file path="src/strategy/llm.rs">
use crate::market_data::{birdeye::BirdEyeProvider, DataProvider};
use anyhow::Result;
use std::sync::Arc;
use tracing::{debug, instrument};
pub struct LLMStrategy {
    birdeye: Arc<BirdEyeProvider>,
}
impl LLMStrategy {
    pub fn new(birdeye: Arc<BirdEyeProvider>) -> Self {
        Self { birdeye }
    }
    #[instrument(skip(self))]
    pub async fn analyze_trading_opportunity(&self, prompt: &str, sol_balance: f64) -> Result<String> {
        debug!("Analyzing trading opportunity with prompt: {}", prompt);
        // Format the analysis with the available SOL balance
        let analysis = format!(
            "Available SOL: {}\n{}",
            sol_balance,
            prompt
        );
        Ok(analysis)
    }
}
</file>

<file path="src/strategy/mod.rs">
#[instrument(skip(self))]
pub async fn analyze_trading_opportunity(&self, prompt: String, sol_balance: f64) -> Result<String> {
    info!("Analyzing trading opportunity with prompt: {}", prompt);
    // Format the prompt with market analysis requirements
    let formatted_prompt = format!(
        "{}\n\nAnalyze this trading opportunity and provide a detailed recommendation in the following JSON format:\n{{
            \"action\": \"Buy|Sell|Hold\",
            \"token_address\": \"string\",
            \"amount_in_sol\": number,
            \"reasoning\": \"string\",
            \"confidence\": number (0.0-1.0),
            \"risk_assessment\": \"string\",
            \"market_analysis\": {{
                \"volume_analysis\": {{
                    \"current_volume_usd\": number,
                    \"volume_change_24h\": number,
                    \"is_volume_bullish\": boolean,
                    \"analysis\": \"string\"
                }},
                \"price_trend\": {{
                    \"current_trend\": \"string\",
                    \"support_levels\": [number],
                    \"resistance_levels\": [number],
                    \"trend_strength\": number (0.0-1.0)
                }},
                \"liquidity_assessment\": {{
                    \"liquidity_score\": number (0.0-1.0),
                    \"slippage_estimate\": number,
                    \"is_liquid_enough\": boolean
                }},
                \"momentum_indicators\": {{
                    \"rsi_14\": number,
                    \"macd\": {{
                        \"value\": number,
                        \"signal\": \"bullish|bearish|neutral\"
                    }},
                    \"overall_momentum\": \"strong_buy|buy|neutral|sell|strong_sell\"
                }},
                \"on_chain_metrics\": {{
                    \"unique_holders\": number,
                    \"holder_concentration\": number (0.0-1.0),
                    \"smart_money_flow\": \"inflow|outflow|neutral\"
                }}
            }},
            \"execution_strategy\": {{
                \"entry_type\": \"market|limit\",
                \"position_size_sol\": number,
                \"stop_loss_pct\": number,
                \"take_profit_levels\": [{{
                    \"price_target\": number,
                    \"size_pct\": number
                }}],
                \"time_horizon\": \"short|medium|long\",
                \"dca_strategy\": {{
                    \"should_dca\": boolean,
                    \"interval_hours\": number,
                    \"num_entries\": number
                }}
            }}
        }}\n\nAvailable SOL balance: {} SOL\n\nConsider the following criteria for the analysis:\n1. Volume should show significant increase (>50% 24h change) with sustainable growth\n2. Price action should show clear trend with identifiable support/resistance levels\n3. Liquidity should be sufficient to enter/exit position with <2% slippage\n4. Momentum indicators should align with the overall trend\n5. Smart money flow should indicate institutional interest\n6. Risk:reward ratio should be at least 1:3 for any trade", 
        prompt,
        sol_balance
    );
    // Get analysis from LLM
    let analysis = self.agent.complete(&formatted_prompt).await?;
    info!("Received analysis from LLM");
    Ok(analysis)
}
</file>

<file path="src/trading/mod.rs">
pub mod trading_engine;
use anyhow::Result;
use solana_client::rpc_client::RpcClient;
pub struct SolanaAgentKit {
    rpc_client: RpcClient,
    wallet_keypair: solana_sdk::signer::keypair::Keypair,
}
impl SolanaAgentKit {
    pub fn new(rpc_url: &str, wallet_keypair: solana_sdk::signer::keypair::Keypair) -> Self {
        Self {
            rpc_client: RpcClient::new(rpc_url.to_string()),
            wallet_keypair,
        }
    }
    pub fn new_from_env() -> Result<Self> {
        let rpc_url = std::env::var("SOLANA_RPC_URL")?;
        let wallet_key = std::env::var("SOLANA_PRIVATE_KEY")?;
        // Parse the base58 private key
        let wallet_keypair = solana_sdk::signer::keypair::Keypair::from_base58_string(&wallet_key);
        Ok(Self::new(&rpc_url, wallet_keypair))
    }
    pub fn get_rpc_client(&self) -> &RpcClient {
        &self.rpc_client
    }
    pub fn get_wallet_keypair(&self) -> &solana_sdk::signer::keypair::Keypair {
        &self.wallet_keypair
    }
}
</file>

<file path="src/trading/trading_engine.rs">
use super::SolanaAgentKit;
use crate::models::market_signal::{MarketSignal, SignalType};
use crate::utils::{decimal_to_f64, f64_to_decimal};
use anyhow::Result;
use tracing::{info, warn};
pub struct TradingEngine {
    min_confidence: f64,
    max_trade_size: f64,
    agent: SolanaAgentKit,
}
#[derive(Debug)]
pub struct TradeDecision {
    pub action: String,
    pub symbol: String,
    pub amount: f64,
    pub reason: String,
    pub confidence: f64,
    pub mint_address: Option<String>,
}
impl TradingEngine {
    pub fn new(min_confidence: f64, max_trade_size: f64, agent: SolanaAgentKit) -> Self {
        Self {
            min_confidence,
            max_trade_size,
            agent,
        }
    }
    pub async fn execute_trade(&self, signal: &MarketSignal) -> Result<String> {
        let min_conf = f64_to_decimal(self.min_confidence);
        if signal.confidence < min_conf {
            warn!("Signal confidence too low for trading");
            return Ok("Signal confidence too low".to_string());
        }
        let max_size = f64_to_decimal(self.max_trade_size);
        let _amount = decimal_to_f64(&(max_size.clone() * signal.confidence.clone()).min(max_size));
        let action = match signal.signal_type {
            SignalType::Buy
            | SignalType::StrongBuy
            | SignalType::PriceSpike
            | SignalType::VolumeSurge => "BUY",
            SignalType::Sell | SignalType::StrongSell | SignalType::PriceDrop => "SELL",
            SignalType::Hold => "HOLD",
        };
        info!(
            "Executing {} trade for {} with confidence {:.2}",
            action,
            signal.asset_address,
            decimal_to_f64(&signal.confidence)
        );
        // TODO: Implement actual Solana transaction execution
        // For now, just return a mock signature
        Ok(format!(
            "mock_tx_{}_{}",
            action.to_lowercase(),
            signal.asset_address
        ))
    }
    pub fn get_min_confidence(&self) -> f64 {
        self.min_confidence
    }
    pub fn get_max_trade_size(&self) -> f64 {
        self.max_trade_size
    }
}
</file>

<file path="src/twitter/mod.rs">
use anyhow::{anyhow, Result};
use reqwest::{
    header::{HeaderMap, HeaderValue, CONTENT_TYPE},
    Client,
};
use serde_json::json;
use tracing::{error, info};
// Remove trait definition since we're not using trait objects
pub struct TwitterClient {
    client: Client,
    email: String,
    username: String,
    password: String,
    auth_token: Option<String>,
}
impl TwitterClient {
    pub fn new(email: String, username: String, password: String) -> Self {
        Self {
            client: Client::new(),
            email,
            username,
            password,
            auth_token: None,
        }
    }
    pub async fn login(&mut self) -> Result<()> {
        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
        // Direct auth endpoint
        let payload = json!({
            "email": self.email,
            "username": self.username,
            "password": self.password
        });
        let response = self
            .client
            .post("https://x.com/i/flow/login")
            .headers(headers)
            .json(&payload)
            .send()
            .await?;
        if response.status().is_success() {
            // Extract auth token from cookies
            if let Some(cookies) = response.headers().get("set-cookie") {
                if let Ok(cookie_str) = cookies.to_str() {
                    if let Some(auth_token) = extract_auth_token(cookie_str) {
                        info!("Successfully logged in to Twitter");
                        self.auth_token = Some(auth_token);
                        return Ok(());
                    }
                }
            }
            Err(anyhow!("No auth token found in response"))
        } else {
            let error_message = response.text().await.unwrap_or_default();
            error!("Failed to login to Twitter: {}", error_message);
            Err(anyhow!("Failed to login to Twitter: {}", error_message))
        }
    }
    pub async fn post_tweet(&self, text: &str) -> Result<()> {
        if self.auth_token.is_none() {
            return Err(anyhow!("Not authenticated"));
        }
        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
        // Add auth token cookie
        headers.insert(
            "cookie",
            HeaderValue::from_str(&format!("auth_token={}", self.auth_token.as_ref().unwrap()))?,
        );
        let payload = json!({
            "text": text,
            "queryId": "PvJGyyJKzm2-aIsTo6tLSg"  // Twitter's internal query ID for posting tweets
        });
        let response = self
            .client
            .post("https://x.com/i/api/graphql/PvJGyyJKzm2-aIsTo6tLSg/CreateTweet")
            .headers(headers)
            .json(&payload)
            .send()
            .await?;
        if response.status().is_success() {
            info!("Successfully posted tweet");
            Ok(())
        } else {
            let error_message = response.text().await.unwrap_or_default();
            error!("Failed to post tweet: {}", error_message);
            Err(anyhow!("Failed to post tweet: {}", error_message))
        }
    }
    pub async fn delete_tweet(&self, tweet_id: &str) -> Result<()> {
        if self.auth_token.is_none() {
            return Err(anyhow!("Not authenticated"));
        }
        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
        // Add auth token cookie
        headers.insert(
            "cookie",
            HeaderValue::from_str(&format!("auth_token={}", self.auth_token.as_ref().unwrap()))?,
        );
        let payload = json!({
            "tweet_id": tweet_id,
            "queryId": "VaenaVgh5q5ih7kvyVjgtg"  // Twitter's internal query ID for deleting tweets
        });
        let response = self
            .client
            .post("https://x.com/i/api/graphql/VaenaVgh5q5ih7kvyVjgtg/DeleteTweet")
            .headers(headers)
            .json(&payload)
            .send()
            .await?;
        if response.status().is_success() {
            info!("Successfully deleted tweet {}", tweet_id);
            Ok(())
        } else {
            let error_message = response.text().await.unwrap_or_default();
            error!("Failed to delete tweet {}: {}", tweet_id, error_message);
            Err(anyhow!("Failed to delete tweet: {}", error_message))
        }
    }
}
// Helper function to extract auth token from cookies
fn extract_auth_token(cookie_str: &str) -> Option<String> {
    cookie_str
        .split(';')
        .find(|s| s.trim().starts_with("auth_token="))
        .and_then(|s| s.trim().strip_prefix("auth_token="))
        .map(|s| s.to_string())
}
#[cfg(test)]
mod tests {
    use super::*;
    #[tokio::test]
    async fn test_extract_auth_token() {
        let cookie_str = "auth_token=abc123; Path=/; Domain=.x.com; Secure; HttpOnly";
        assert_eq!(extract_auth_token(cookie_str), Some("abc123".to_string()));
    }
    #[tokio::test]
    async fn test_auth_token_none() {
        let client = TwitterClient::new(
            "test@example.com".to_string(),
            "testuser".to_string(),
            "password".to_string(),
        );
        // Test that unauthorized operations fail
        let tweet_result = client.post_tweet("Test tweet").await;
        assert!(tweet_result.is_err());
        let delete_result = client.delete_tweet("123").await;
        assert!(delete_result.is_err());
    }
}
</file>

<file path="src/utils/mod.rs">
use bigdecimal::FromPrimitive;
use bigdecimal::{BigDecimal, ToPrimitive};
/// Converts an f64 value to a BigDecimal. Returns 0 if the conversion fails.
pub fn f64_to_decimal(value: f64) -> BigDecimal {
    BigDecimal::from_f64(value).unwrap_or_else(|| BigDecimal::from(0))
}
/// Converts a reference to a BigDecimal to an f64. Returns 0.0 if the conversion fails.
pub fn decimal_to_f64(value: &BigDecimal) -> f64 {
    value.to_f64().unwrap_or(0.0)
}
#[cfg(test)]
mod tests {
    use super::*;
    use bigdecimal::BigDecimal;
    #[test]
    fn test_f64_to_decimal() {
        assert_eq!(f64_to_decimal(1.0), BigDecimal::from(1));
        assert_eq!(f64_to_decimal(0.0), BigDecimal::from(0));
        assert_eq!(f64_to_decimal(3.14), BigDecimal::from_f64(3.14).unwrap());
    }
    #[test]
    fn test_decimal_to_f64() {
        let big_decimal_one = BigDecimal::from(1);
        let big_decimal_zero = BigDecimal::from(0);
        let big_decimal_pi = BigDecimal::from_f64(3.14).unwrap();
        assert_eq!(decimal_to_f64(&big_decimal_one), 1.0);
        assert_eq!(decimal_to_f64(&big_decimal_zero), 0.0);
        assert_eq!(decimal_to_f64(&big_decimal_pi), 3.14);
    }
}
</file>

<file path="src/vector_store/mod.rs">
use anyhow::{Context, Result};
use rig_core::vector_store::{Document, Store};
use rig_mongodb::MongoStore;
use std::sync::Arc;
use tracing::{info, warn};
use crate::config::mongodb::{MongoConfig, MongoDbPool};
use serde_json;
pub struct VectorStore {
    store: Arc<MongoStore>,
}
impl VectorStore {
    pub async fn new() -> Result<Self> {
        // Use centralized MongoDB configuration
        let config = MongoConfig::from_env();
        info!("Initializing vector store connection");
        let pool = MongoDbPool::create_pool(config.clone())
            .await
            .context("Failed to create MongoDB pool")?;
        // Configure vector store with optimized search parameters and fields
        let fields = serde_json::json!({
            "fields": [{
                "path": "embedding",
                "numDimensions": 1536,
                "similarity": "cosine"
            }]
        });
        let store = MongoStore::new(
            pool.client(), 
            &config.database, 
            "token_analytics",
            fields
        ).await
            .context("Failed to create vector store")?;
        Ok(Self {
            store: Arc::new(store),
        })
    }
    pub async fn insert_documents<T>(&self, documents: Vec<T>) -> Result<()> 
    where
        T: Send + Sync + 'static + serde::Serialize + Document,
    {
        info!("Inserting documents into vector store");
        self.store.insert_documents(&documents)
            .await
            .context("Failed to insert documents into vector store")?;
        Ok(())
    }
    pub async fn top_n<T>(&self, query: &str, limit: usize) -> Result<Vec<(f32, T)>>
    where
        T: Send + Sync + for<'de> serde::de::Deserialize<'de> + 'static,
    {
        if limit == 0 {
            warn!("top_n called with limit=0, defaulting to 1");
            let limit = 1;
        }
        info!("Performing vector similarity search with limit {}", limit);
        let results = self.store.search::<T>(query, limit)
            .await
            .context("Failed to perform vector similarity search")?;
        info!("Found {} matching documents", results.len());
        Ok(results)
    }
    #[cfg(test)]
    pub async fn cleanup_test_data(&self) -> Result<()> {
        // Implement cleanup logic for MongoDB if necessary
        Ok(())
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use serde::{Deserialize, Serialize};
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
    #[derive(Serialize, Deserialize, Clone, Debug, Eq, PartialEq)]
    struct TestDocument {
        id: String,
        content: String,
    }
    impl Document for TestDocument {
        fn text(&self) -> &str {
            &self.content
        }
    }
    fn init_test_logging() {
        let _ = tracing_subscriber::registry()
            .with(tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()))
            .with(tracing_subscriber::fmt::layer())
            .try_init();
    }
    #[tokio::test]
    async fn test_vector_store() -> Result<()> {
        init_test_logging();
        dotenvy::dotenv().ok();
        let store = VectorStore::new()
            .await
            .context("Failed to create vector store")?;
        // Clean up any existing test data
        store.cleanup_test_data()
            .await
            .context("Failed to cleanup existing test data")?;
        let docs = vec![
            TestDocument {
                id: "1".to_string(),
                content: "Test document one".to_string(),
            },
            TestDocument {
                id: "2".to_string(), 
                content: "Test document two".to_string(),
            },
        ];
        store.insert_documents(docs)
            .await
            .context("Failed to insert test documents")?;
        let results = store.top_n::<TestDocument>("test document", 2)
            .await
            .context("Failed to perform similarity search")?;
        assert!(!results.is_empty(), "Expected non-empty search results");
        assert_eq!(results.len(), 2, "Expected exactly 2 search results");
        // Clean up test data
        store.cleanup_test_data()
            .await
            .context("Failed to cleanup test data")?;
        Ok(())
    }
}
</file>

<file path="src/error.rs">
use mongodb::error::Error as MongoError;
use std::error::Error as StdError;
use std::fmt;
use std::num::ParseFloatError;
use thiserror::Error;
#[derive(Error, Debug)]
pub enum Error {
    #[error("MongoDB error: {0}")]
    Mongo(#[from] MongoError),
    #[error("ParseFloat error: {0}")]
    ParseFloat(#[from] ParseFloatError),
    #[error("Other error: {0}")]
    Other(String),
}
#[derive(Debug)]
pub enum AgentError {
    Config(String),
    MissingEnvVar(String),
    InvalidConfig(String, String),
    TwitterApi(String),
    Trading(String),
    Database(MongoError),
    MarketAnalysis(String),
    VectorStore(String),
    BirdeyeApi(String),
    Transaction(String),
    Validation(String),
    Parse(String),
    RateLimit(String),
    Authentication(String),
    Network(String),
    Timeout(String),
    Conversion(String),
    Other(anyhow::Error),
    Mongo(mongodb::error::Error),
    InvalidInput(String),
    ApiError(String),
}
impl fmt::Display for AgentError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AgentError::Config(msg) => write!(f, "Configuration error: {}", msg),
            AgentError::MissingEnvVar(var) => write!(f, "Environment variable '{}' not found", var),
            AgentError::InvalidConfig(field, msg) => {
                write!(f, "Invalid value for {}: {}", field, msg)
            }
            AgentError::TwitterApi(msg) => write!(f, "Twitter API error: {}", msg),
            AgentError::Trading(msg) => write!(f, "Trading error: {}", msg),
            AgentError::Database(err) => write!(f, "Database error: {}", err),
            AgentError::MarketAnalysis(msg) => write!(f, "Market analysis error: {}", msg),
            AgentError::VectorStore(msg) => write!(f, "Vector store error: {}", msg),
            AgentError::BirdeyeApi(msg) => write!(f, "Birdeye API error: {}", msg),
            AgentError::Transaction(msg) => write!(f, "Transaction error: {}", msg),
            AgentError::Validation(msg) => write!(f, "Validation error: {}", msg),
            AgentError::Parse(msg) => write!(f, "Parse error: {}", msg),
            AgentError::RateLimit(service) => write!(f, "Rate limit exceeded for {}", service),
            AgentError::Authentication(msg) => write!(f, "Authentication error: {}", msg),
            AgentError::Network(msg) => write!(f, "Network error: {}", msg),
            AgentError::Timeout(msg) => write!(f, "Timeout error: {}", msg),
            AgentError::Conversion(msg) => write!(f, "Conversion error: {}", msg),
            AgentError::Other(err) => write!(f, "Other error: {}", err),
            AgentError::Mongo(err) => write!(f, "MongoDB error: {}", err),
            AgentError::InvalidInput(err) => write!(f, "Input error: {}", err),
            AgentError::ApiError(err) => write!(f, "Api error: {}", err),
        }
    }
}
impl StdError for AgentError {
    fn source(&self) -> Option<&(dyn StdError + 'static)> {
        match self {
            AgentError::Database(err) => Some(err),
            AgentError::Mongo(err) => Some(err),
            _ => None,
        }
    }
}
impl From<MongoError> for AgentError {
    fn from(err: MongoError) -> Self {
        AgentError::Mongo(err)
    }
}
impl From<ParseFloatError> for AgentError {
    fn from(err: ParseFloatError) -> Self {
        AgentError::Parse(err.to_string())
    }
}
impl From<tracing_subscriber::filter::ParseError> for AgentError {
    fn from(err: tracing_subscriber::filter::ParseError) -> Self {
        AgentError::Parse(err.to_string())
    }
}
impl From<reqwest::Error> for AgentError {
    fn from(err: reqwest::Error) -> Self {
        if err.is_timeout() {
            AgentError::Timeout(err.to_string())
        } else if err.is_connect() {
            AgentError::Network(err.to_string())
        } else {
            AgentError::Other(err.into())
        }
    }
}
pub type AgentResult<T> = Result<T, AgentError>;
// Helper functions for common error cases
impl AgentError {
    pub fn missing_env(var: &str) -> Self {
        AgentError::MissingEnvVar(var.to_string())
    }
    pub fn invalid_config<T: std::fmt::Display>(field: &str, message: T) -> Self {
        AgentError::InvalidConfig(field.to_string(), message.to_string())
    }
    pub fn validation<T: std::fmt::Display>(message: T) -> Self {
        AgentError::Validation(message.to_string())
    }
    pub fn transaction<T: std::fmt::Display>(message: T) -> Self {
        AgentError::Transaction(message.to_string())
    }
    pub fn rate_limit<T: std::fmt::Display>(service: T) -> Self {
        AgentError::RateLimit(service.to_string())
    }
    pub fn auth<T: std::fmt::Display>(message: T) -> Self {
        AgentError::Authentication(message.to_string())
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_error_conversions() {
        // Test ParseFloatError conversion
        let parse_err: AgentError = "invalid float".parse::<f64>().unwrap_err().into();
        assert!(matches!(parse_err, AgentError::Parse(_)));
        // Test helper functions
        let missing_env = AgentError::missing_env("TEST_VAR");
        assert!(matches!(missing_env, AgentError::MissingEnvVar(_)));
        let invalid_config = AgentError::invalid_config("threshold", "must be positive");
        assert!(matches!(invalid_config, AgentError::InvalidConfig(_, _)));
        let validation = AgentError::validation("invalid input");
        assert!(matches!(validation, AgentError::Validation(_)));
        let transaction = AgentError::transaction("commit failed");
        assert!(matches!(transaction, AgentError::Transaction(_)));
        let rate_limit = AgentError::rate_limit("Birdeye API");
        assert!(matches!(rate_limit, AgentError::RateLimit(_)));
        let auth = AgentError::auth("invalid credentials");
        assert!(matches!(auth, AgentError::Authentication(_)));
    }
    #[test]
    fn test_error_display() {
        let err = AgentError::missing_env("TEST_VAR");
        assert_eq!(err.to_string(), "Environment variable 'TEST_VAR' not found");
        let err = AgentError::invalid_config("threshold", "must be positive");
        assert_eq!(
            err.to_string(),
            "Invalid value for threshold: must be positive"
        );
        let err = AgentError::validation("invalid input");
        assert_eq!(err.to_string(), "Validation error: invalid input");
    }
}
</file>

<file path="src/lib.rs">
pub mod agent;
pub mod birdeye;
pub mod config;
pub mod error;
pub mod logging;
pub mod models;
pub mod services;
pub mod trading;
pub mod twitter;
pub mod utils;
</file>

<file path="src/main.rs">
use crate::{
    agent::trader::TradingAgent,
    config::AgentConfig,
    models::market_signal::{MarketSignal, SignalType},
    trading::SolanaAgentKit,
    utils::f64_to_decimal,
};
use anyhow::Result;
use bson::DateTime;
use config::mongodb::{MongoConfig, MongoDbPool, MongoPoolConfig};
use solana_sdk::signature::Keypair;
use std::io::{self, Write};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use tracing::{error, info};
mod agent;
mod birdeye;
mod config;
mod error;
mod logging;
mod models;
mod services;
mod trading;
mod twitter;
mod utils;
async fn handle_user_input(
    trader: Arc<TradingAgent>,
    config: AgentConfig,
    running: Arc<AtomicBool>,
) {
    println!("\n=== Cainam Trading Agent ===");
    println!("The agent is running autonomously in the background.");
    println!("\nAvailable commands:");
    println!("  analyze <symbol> <address>    - Analyze market for a token");
    println!("  trade <symbol> <buy|sell> <amount>  - Execute a trade");
    println!("  status                        - Get current trading status");
    println!("  exit                          - Exit the program");
    println!("\nType a command and press Enter.\n");
    loop {
        if !running.load(Ordering::SeqCst) {
            break;
        }
        print!("> ");
        io::stdout().flush().unwrap_or_default();
        let mut input = String::new();
        match io::stdin().read_line(&mut input) {
            Ok(_) => {
                let parts: Vec<String> =
                    input.split_whitespace().map(String::from).collect();
                if parts.is_empty() {
                    continue;
                }
                match parts[0].as_str() {
                    "analyze" => {
                        if parts.len() != 3 {
                            println!("Usage: analyze <symbol> <address>");
                            continue;
                        }
                        println!("Analyzing market for {}...", parts[1]);
                        tokio::spawn({
                            let trader = trader.clone();
                            let symbol = parts[1].clone();
                            let address = parts[2].clone();
                            async move {
                                match trader.analyze_market(&symbol, &address).await {
                                    Ok(Some(signal)) => {
                                        println!("\nMarket Analysis Result:");
                                        println!("  Signal: {:?}", signal.signal_type);
                                        println!("  Confidence: {:.2}", signal.confidence);
                                        println!("  Risk Score: {:.2}", signal.risk_score);
                                    }
                                    Ok(None) => println!("\nNo trading signals generated"),
                                    Err(e) => println!("\nAnalysis failed: {}", e),
                                }
                            }
                        });
                    }
                    "trade" => {
                        if parts.len() != 4 {
                            println!("Usage: trade <symbol> <buy|sell> <amount>");
                            continue;
                        }
                        let amount = match parts[3].parse::<f64>() {
                            Ok(val) => val,
                            Err(_) => {
                                println!("Invalid amount. Please provide a valid number.");
                                continue;
                            }
                        };
                        let signal_type = match parts[2].to_uppercase().as_str() {
                            "BUY" => SignalType::StrongBuy,
                            "SELL" => SignalType::StrongSell,
                            _ => {
                                println!("Invalid trade type. Use 'buy' or 'sell'");
                                continue;
                            }
                        };
                        println!("Executing {} trade for {}...", parts[2], parts[1]);
                        tokio::spawn({
                            let trader = trader.clone();
                            let symbol = parts[1].clone();
                            async move {
                                let signal = MarketSignal {
                                    id: None,
                                    asset_address: symbol.clone(),
                                    signal_type: signal_type.clone(),
                                    confidence: f64_to_decimal(0.8),
                                    risk_score: f64_to_decimal(0.2),
                                    sentiment_score: Some(f64_to_decimal(0.6)),
                                    volume_change_24h: Some(f64_to_decimal(0.15)),
                                    price_change_24h: Some(f64_to_decimal(
                                        if signal_type == SignalType::StrongBuy {
                                            0.05
                                        } else {
                                            -0.05
                                        },
                                    )),
                                    price: f64_to_decimal(10.0),
                                    volume_change: f64_to_decimal(0.2),
                                    timestamp: DateTime::now(),
                                    metadata: None,
                                    created_at: None,
                                };
                                let min_confidence = f64_to_decimal(config.trade_min_confidence);
                                if signal.confidence >= min_confidence {
                                    match trader.execute_trade(&symbol, &signal).await {
                                        Ok(signature) => {
                                            println!("\nTrade executed successfully!");
                                            println!("Transaction: {}", signature);
                                            if let Err(e) = trader
                                                .post_trade_update(
                                                    &symbol,
                                                    &parts[2],
                                                    amount,
                                                    &signal_type,
                                                )
                                                .await
                                            {
                                                println!("Failed to post trade update: {}", e);
                                            }
                                        }
                                        Err(e) => println!("\nTrade execution failed: {}", e),
                                    }
                                }
                            }
                        });
                    }
                    "status" => {
                        println!("\nTrading Agent Status:");
                        println!("  State: Active");
                        println!("  Analysis Interval: {:?}", config.analysis_interval);
                        println!("  Min Confidence: {:.2}", config.trade_min_confidence);
                        println!("  Max Trade Amount: {:.2}", config.trade_max_amount);
                    }
                    "exit" => {
                        println!("\nShutting down trading agent...");
                        running.store(false, Ordering::SeqCst);
                        break;
                    }
                    _ => println!("Unknown command. Type 'help' for available commands."),
                }
            }
            Err(e) => {
                error!("Error reading input: {}", e);
                break;
            }
        }
    }
}
async fn init_mongodb() -> Result<Arc<MongoDbPool>> {
    info!("Initializing MongoDB connection...");
    let config = MongoConfig {
        uri: std::env::var("MONGODB_URI")
            .unwrap_or_else(|_| "mongodb://localhost:32770".to_string()),
        database: std::env::var("MONGODB_DATABASE").unwrap_or_else(|_| "cainam".to_string()),
        app_name: std::env::var("MONGODB_APP_NAME").ok(),
        pool_config: MongoPoolConfig::from_env(),
    };
    info!("Connecting to MongoDB at {}", config.uri);
    let pool = MongoDbPool::create_pool(config).await?;
    info!("Successfully connected to MongoDB");
    Ok(pool)
}
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    // logging::init_logging()?;
    println!("Starting Cainam Core...");
    // Load environment variables from .env file
    dotenvy::dotenv().ok();
    println!("loadi env file...");
    // Initialize MongoDB connection pool using rig-mongodb
    let db_pool = init_mongodb().await?;
    println!("init pool...");
    // TODO: zTgx hardcoded
    // Initialize Solana agent
    let rpc_url = "https://api.devnet.solana.com";
    let keypair = Keypair::new();
    let solana_agent = SolanaAgentKit::new(rpc_url, keypair);
    // Load configuration from environment
    let config = AgentConfig::new_from_env()?;
    // Initialize trading agent
    let trader = Arc::new(TradingAgent::new(config.clone(), db_pool, solana_agent).await?);
    let running = Arc::new(AtomicBool::new(true));
    // Initialize services with MongoDB pool
    // let token_analytics_service = TokenAnalyticsService::new(
    //     db_pool.clone(),
    //     birdeye.clone(),
    //     birdeye_extended.clone(),
    //     Some(market_config.clone()),
    // ).await?;
    // let portfolio_optimizer = PortfolioOptimizer::new(db_pool.clone());
    // // Initialize vector store
    // let vector_store = VectorStore::new().await?;
    // // Spawn the autonomous trading agent
    // let trader_clone = trader.clone();
    // let running_clone = running.clone();
    // let trading_handle = tokio::spawn(async move {
    //     info!("Starting autonomous trading...");
    //     if let Err(e) = trader_clone.run().await {
    //         error!("Trading agent error: {}", e);
    //         running_clone.store(false, Ordering::SeqCst);
    //     }
    // });
    // Handle user input in a separate task
    let input_handle = tokio::spawn(handle_user_input(trader.clone(), config, running.clone()));
    // Wait for either task to complete
    tokio::select! {
        // _ = trading_handle => {
        //     info!("Trading task completed");
        // }
        _ = input_handle => {
            info!("User input task completed");
        }
    }
    // Wait for clean shutdown
    info!("Shutting down trading agent...");
    running.store(false, Ordering::SeqCst);
    trader.stop();
    Ok(())
}
</file>

<file path="src/memory.rs">
use serde_json;
use std::fs;
use std::io::{self, Write};
use std::path::Path;
pub struct MemoryStore;
impl MemoryStore {
    const FILE_PATH: &'static str = "./storage/memory.json";
    // Load memory from file
    pub fn load_memory() -> io::Result<Vec<String>> {
        if Path::new(Self::FILE_PATH).exists() {
            let data = fs::read_to_string(Self::FILE_PATH)?;
            let memory: Vec<String> = serde_json::from_str(&data)?;
            Ok(memory)
        } else {
            Ok(Vec::new()) // Return an empty vector if file doesn't exist
        }
    }
    // Add to memory
    pub fn add_to_memory(memory: &mut Vec<String>, item: &str) -> Result<(), String> {
        if !memory.contains(&item.to_string()) {
            memory.push(item.to_string());
            let _ = Self::save_memory(memory);
            Ok(())
        } else {
            Err("Memory Exists!".to_string())
        }
    }
    // Wipe memory
    pub fn wipe_memory(memory: &mut Vec<String>) -> io::Result<()> {
        memory.clear();
        Self::save_memory(memory)
    }
    // Count memories
    pub fn count_memories(memory: &Vec<String>) -> usize {
        memory.len()
    }
    // Save memory to file
    pub fn save_memory(memory: &Vec<String>) -> io::Result<()> {
        let data = serde_json::to_string(memory)?;
        let mut file = fs::File::create(Self::FILE_PATH)?;
        file.write_all(data.as_bytes())?;
        Ok(())
    }
    // Get current memory
    pub fn get_memory() -> io::Result<Vec<String>> {
        Self::load_memory()
    }
}
</file>

<file path="tests/integration/mod.rs">
mod trade_flow_test;
pub use trade_flow_test::*;
mod token_analytics_tests;
pub use token_analytics_tests::*;
</file>

<file path="tests/integration/test_utils.rs">
use rig_mongodb::{MongoDbPool, bson::doc};
use std::sync::Arc;
use anyhow::Result;
use once_cell::sync::Lazy;
use tokio::sync::Mutex;
use crate::config::mongodb::MongoConfig;
// Ensure test databases are unique per test
static TEST_DB_COUNTER: Lazy<Mutex<u32>> = Lazy::new(|| Mutex::new(0));
pub async fn get_unique_test_db_name() -> String {
    let mut counter = TEST_DB_COUNTER.lock().await;
    let db_name = format!("test_db_{}", *counter);
    *counter += 1;
    db_name
}
#[cfg(test)]
pub mod test_utils {
    use super::*;
    use crate::config::{mongodb::MongoConfig, pool::MongoPoolConfig};
    use rig_mongodb::MongoDbPool;
    use std::sync::Arc;
    use anyhow::Result;
    use std::time::Duration;
    pub async fn setup_test_db() -> Result<(Arc<MongoDbPool>, String)> {
        let db_name = get_unique_test_db_name().await;
        let config = MongoConfig {
            database: db_name.clone(),
            pool: crate::config::pool::MongoPoolConfig {
                min_pool_size: 1,
                max_pool_size: 2,
                connect_timeout: std::time::Duration::from_secs(5),
            },
            ..Default::default()
        };
        let pool = config.create_pool().await?;
        // Initialize test collections
        setup_test_collections(&pool, &db_name).await?;
        Ok((pool, db_name))
    }
    pub async fn cleanup_test_db(pool: &MongoDbPool, db_name: &str) -> Result<()> {
        pool.database(db_name).drop().await?;
        Ok(())
    }
    async fn setup_test_collections(pool: &MongoDbPool, db_name: &str) -> Result<()> {
        let db = pool.database(db_name);
        db.create_collection("test_market_signals", Some(doc! {
            "timeseries": {
                "timeField": "timestamp",
                "metaField": "asset_address",
                "granularity": "minutes"
            }
        })).await?;
        db.collection("test_market_signals").create_index(
            doc! {
                "asset_address": 1,
                "timestamp": -1
            },
            None,
        ).await?;
        Ok(())
    }
    pub async fn insert_test_data(pool: &MongoDbPool, db_name: &str, collection: &str, data: Vec<bson::Document>) -> Result<()> {
        let coll = pool.database(db_name).collection(collection);
        coll.insert_many(data, None).await?;
        Ok(())
    }
}
</file>

<file path="tests/integration/token_analytics_tests.rs">
use crate::config::MarketConfig;
use crate::models::token_analytics::TokenAnalytics;
use crate::services::token_analytics::TokenAnalyticsService;
use crate::{
    birdeye::{MockBirdeyeApi, TokenInfo},
    error::AgentError,
    models::market_signal::SignalType,
};
use rig_mongodb::MongoDbPool::MongoDbPool;
#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::{cleanup_test_db, setup_test_db};
    use rig_mongodb::MongoDbPool;
    use std::sync::Arc;
    async fn setup_test_environment() -> (
        Arc<MongoDbPool>,
        Arc<MockBirdeyeApi>,
        Arc<BirdeyeExtendedClient>,
    ) {
        let db = setup_test_db()
            .await
            .expect("Failed to setup test database");
        let (birdeye, birdeye_extended) = setup_mock_birdeye();
        (db, birdeye, birdeye_extended)
    }
    async fn cleanup_test_environment(pool: &MongoDbPool) {
        cleanup_test_db(pool, "cainam_test")
            .await
            .expect("Failed to cleanup test database");
    }
    async fn setup_test_db() -> Arc<MongoDbPool> {
        let connection_string = "mongodb://localhost:32770";
        MongoDbPool::new_from_uri(connection_string, "cainam_test")
            .await
            .expect("Failed to create test database pool")
            .into()
    }
    fn setup_mock_birdeye() -> (Arc<MockBirdeyeApi>, Arc<cainam_birdeye::BirdeyeClient>) {
        let mut mock = MockBirdeyeApi::new();
        mock.expect_get_token_info().returning(|_| {
            Ok(TokenInfo {
                price: 100.0,
                volume_24h: 1000000.0,
                price_change_24h: 5.0,
                liquidity: 500000.0,
                trade_24h: 1000,
            })
        });
        (
            Arc::new(mock),
            Arc::new(cainam_birdeye::BirdeyeClient::new("test_key")),
        )
    }
    #[tokio::test]
    async fn test_fetch_token_info_success() -> AgentResult<()> {
        let db = setup_test_db().await;
        let (birdeye, birdeye_extended) = setup_mock_birdeye();
        let market_config = MarketConfig::default();
        let service =
            TokenAnalyticsService::new(db, birdeye, birdeye_extended, Some(market_config));
        let analytics = service
            .fetch_and_store_token_info("SOL", "test_address")
            .await?;
        assert_eq!(analytics.token_symbol, "SOL");
        assert_eq!(analytics.price, f64_to_decimal(100.0));
        Ok(())
    }
    #[tokio::test]
    async fn test_invalid_token_price() -> AgentResult<()> {
        let db = setup_test_db().await;
        let mut mock = MockBirdeyeApi::new();
        mock.expect_get_token_info().returning(|_| {
            Ok(TokenInfo {
                price: -1.0, // Invalid price
                volume_24h: 1000000.0,
                price_change_24h: 5.0,
                liquidity: 500000.0,
                trade_24h: 1000,
            })
        });
        let service = TokenAnalyticsService::new(
            db,
            Arc::new(mock),
            Arc::new(cainam_birdeye::BirdeyeClient::new("test_key")),
            Some(MarketConfig::default()),
        );
        let result = service
            .fetch_and_store_token_info("SOL", "test_address")
            .await;
        assert!(matches!(result, Err(AgentError::Validation(_))));
        Ok(())
    }
    #[tokio::test]
    async fn test_invalid_signal_confidence() -> AgentResult<()> {
        let db = setup_test_db().await;
        let (birdeye, birdeye_extended) = setup_mock_birdeye();
        let mut market_config = MarketConfig::default();
        // Set up config to generate invalid confidence
        market_config.base_confidence = f64_to_decimal(2.0); // Will result in confidence > 1
        let service =
            TokenAnalyticsService::new(db, birdeye, birdeye_extended, Some(market_config));
        let result = service
            .fetch_and_store_token_info("SOL", "test_address")
            .await;
        assert!(matches!(result, Err(AgentError::Validation(_))));
        Ok(())
    }
    #[tokio::test]
    async fn test_market_signal_generation() -> AgentResult<()> {
        let db = setup_test_db().await;
        let (birdeye, birdeye_extended) = setup_mock_birdeye();
        let market_config = MarketConfig::default();
        let service =
            TokenAnalyticsService::new(db.clone(), birdeye, birdeye_extended, Some(market_config));
        // First store some historical data
        let mut tx = db.begin().await?;
        let analytics = TokenAnalytics {
            id: None,
            token_address: "test_address".to_string(),
            token_name: "Test Token".to_string(),
            token_symbol: "TEST".to_string(),
            price: f64_to_decimal(90.0), // Lower price to trigger price spike
            volume_24h: Some(f64_to_decimal(500000.0)),
            market_cap: Some(f64_to_decimal(1000000.0)),
            total_supply: Some(f64_to_decimal(10000.0)),
            holder_count: None,
            timestamp: Utc::now() - chrono::Duration::hours(1),
            created_at: None,
        };
        service
            .store_token_analytics_tx(&mut tx, &analytics)
            .await?;
        tx.commit().await?;
        // Now fetch current data which should generate a signal
        let result = service
            .fetch_and_store_token_info("TEST", "test_address")
            .await?;
        let signal = service.generate_market_signals(&result).await?;
        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, SignalType::PriceSpike);
        assert!(signal.confidence > f64_to_decimal(0.0));
        assert!(signal.confidence <= f64_to_decimal(1.0));
        Ok(())
    }
    #[tokio::test]
    async fn test_transaction_rollback() -> AgentResult<()> {
        let db = setup_test_db().await;
        let (birdeye, birdeye_extended) = setup_mock_birdeye();
        let market_config = MarketConfig::default();
        let service =
            TokenAnalyticsService::new(db.clone(), birdeye, birdeye_extended, Some(market_config));
        // Start a transaction
        let mut tx = db.begin().await?;
        // Store valid analytics
        let analytics = TokenAnalytics {
            id: None,
            token_address: "test_address".to_string(),
            token_name: "Test Token".to_string(),
            token_symbol: "TEST".to_string(),
            price: f64_to_decimal(100.0),
            volume_24h: Some(f64_to_decimal(1000000.0)),
            market_cap: Some(f64_to_decimal(10000000.0)),
            total_supply: Some(f64_to_decimal(100000.0)),
            holder_count: None,
            timestamp: Utc::now(),
            created_at: None,
        };
        service
            .store_token_analytics_tx(&mut tx, &analytics)
            .await?;
        // Rollback the transaction
        tx.rollback().await?;
        // Verify the data wasn't stored
        let result = service.get_latest_token_analytics("test_address").await?;
        assert!(result.is_none());
        Ok(())
    }
}
</file>

<file path="tests/integration/trade_flow_test.rs">
use cainam_core::{
    agent::trader::{AgentConfig, TradingAgent},
    config::{MarketConfig, mongodb::MongoConfig, pool::MongoPoolConfig},
    error::AgentResult,
    models::{
        market_signal::{MarketSignal, SignalType},
        token_analytics::TokenAnalytics,
    },
    services::token_analytics::TokenAnalyticsService,
    SolanaAgentKit,
};
use chrono::Utc;
use rig_mongodb::MongoDbPool;
use std::sync::Arc;
use bigdecimal::BigDecimal;
use std::time::Duration;
async fn setup_test_db() -> Arc<MongoDbPool> {
    let config = MongoConfig {
        database: "cainam_test".to_string(),
        pool: MongoPoolConfig {
            min_pool_size: 1,
            max_pool_size: 2,
            connect_timeout: Duration::from_secs(5),
        },
        ..Default::default()
    };
    config.create_pool()
        .await
        .expect("Failed to create database pool")
}
async fn cleanup_test_db(pool: &MongoDbPool) {
    pool.database("cainam_test")
        .drop()
        .await
        .expect("Failed to cleanup test database");
}
async fn setup_test_config() -> AgentConfig {
    AgentConfig {
        openai_api_key: "test_key".to_string(),
        birdeye_api_key: "test_key".to_string(),
        twitter_email: "test@example.com".to_string(),
        twitter_username: "test_user".to_string(),
        twitter_password: "test_pass".to_string(),
        analysis_interval: std::time::Duration::from_secs(1),
        trade_min_confidence: 0.7,
        trade_max_amount: 1000.0,
    }
}
#[tokio::test]
async fn test_full_trade_flow() -> AgentResult<()> {
    // Setup
    let db = setup_test_db().await;
    let config = setup_test_config().await;
    let solana_agent = SolanaAgentKit::new_from_env()?;
    // Initialize trading agent
    let agent = TradingAgent::new(config, db.clone(), solana_agent).await?;
    // Test market analysis
    let signal = agent.analyze_market(
        "SOL",
        "So11111111111111111111111111111111111111112"
    ).await?;
    assert!(signal.is_some());
    // Test signal processing
    if let Some(signal) = signal {
        let action = agent.process_signal(&signal).await?;
        assert!(action.is_some());
        // Test trade execution
        if let Some(action) = action {
            match action.as_str() {
                "BUY" | "SELL" => {
                    let result = agent.execute_trade("SOL", &signal).await;
                    assert!(result.is_ok());
                    // Test post-trade update
                    let update_result = agent.post_trade_update(
                        "SOL",
                        &action,
                        100.0,
                        &signal.signal_type
                    ).await;
                    assert!(update_result.is_ok());
                }
                _ => {}
            }
        }
    }
    // Cleanup test data
    cleanup_test_db(&db).await;
    Ok(())
}
#[tokio::test]
async fn test_concurrent_market_analysis() -> AgentResult<()> {
    let db = setup_test_db().await;
    let config = setup_test_config().await;
    let solana_agent = SolanaAgentKit::new_from_env()?;
    let agent = TradingAgent::new(config, db.clone(), solana_agent).await?;
    // Run multiple market analyses concurrently
    let handles: Vec<_> = vec![
        ("SOL", "So11111111111111111111111111111111111111112"),
        ("BONK", "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"),
    ]
    .into_iter()
    .map(|(symbol, address)| {
        let agent = agent.clone();
        tokio::spawn(async move {
            agent.analyze_market(symbol, address).await
        })
    })
    .collect();
    // Wait for all analyses to complete
    for handle in handles {
        let result = handle.await.expect("Task panicked")?;
        assert!(result.is_some());
    }
    cleanup_test_db(&db).await;
    Ok(())
}
#[tokio::test]
async fn test_error_recovery() -> AgentResult<()> {
    let db = setup_test_db().await;
    let config = setup_test_config().await;
    let solana_agent = SolanaAgentKit::new_from_env()?;
    let agent = TradingAgent::new(config, db.clone(), solana_agent).await?;
    // Start the agent
    let agent_handle = {
        let agent = agent.clone();
        tokio::spawn(async move {
            agent.run().await
        })
    };
    // Let it run for a bit
    tokio::time::sleep(Duration::from_secs(2)).await;
    // Stop the agent
    agent.stop();
    // Verify clean shutdown
    let result = agent_handle.await.expect("Task panicked");
    assert!(result.is_ok());
    cleanup_test_db(&db).await;
    Ok(())
}
#[tokio::test]
async fn test_performance() -> AgentResult<()> {
    use tokio::time::Instant;
    let db = setup_test_db().await;
    let config = setup_test_config().await;
    let solana_agent = SolanaAgentKit::new_from_env()?;
    let agent = TradingAgent::new(config, db.clone(), solana_agent).await?;
    // Measure market analysis performance
    let start = Instant::now();
    let signal = agent.analyze_market(
        "SOL",
        "So11111111111111111111111111111111111111112"
    ).await?;
    let duration = start.elapsed();
    // Analysis should complete within reasonable time
    assert!(duration.as_secs() < 5);
    assert!(signal.is_some());
    cleanup_test_db(&db).await;
    Ok(())
}
</file>

<file path="tests/integration/twitter_tests.rs">
use mockall::predicate::*;
use mockall::*;
mock! {
    pub TwitterClient {
        fn login(&self) -> Result<()>;
        fn post_tweet(&self, text: String) -> Result<()>;
        // Add other methods you need to mock
    }
}
#[tokio::test]
async fn test_twitter_client() {
    let mut mock_client = MockTwitterClient::new();
    mock_client
        .expect_login()
        .times(1)
        .returning(|| Ok(()));
    mock_client
        .expect_post_tweet()
        .with(predicate::any())
        .times(1)
        .returning(|_| Ok(()));
    // Use mock client in your tests
    assert!(mock_client.login().is_ok());
}
</file>

<file path=".gitignore">
# Environment variables
.env
.env.local

# Build
target/

# Local Artifacts
.DS_Store

# IDE
.vscode/
.devcontainer/

# Node
node_modules/

# Characters
characters/

# Goose
.goose/
</file>

<file path=".pre-commit-config.yaml">
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-added-large-files
    -   id: check-json
    -   id: check-case-conflict
    -   id: check-merge-conflict
-   repo: https://github.com/doublify/pre-commit-rust
    rev: v1.0
    hooks:
    -   id: fmt
    -   id: cargo-check
    -   id: clippy
- repo: https://github.com/commitizen-tools/commitizen
  rev: v2.20.0
  hooks:
    - id: commitizen
      stages: [commit-msg]
</file>

<file path="Cargo.toml">
[package]
name = "cainam-core"
version = "0.1.0"
edition = "2021"
authors = ["Matt Gunnin <matt@cainamventures.com>"]
repository = "https://github.com/cainamventures/cainam-core"
readme = "README.md"
keywords = ["ai", "solana", "rust", "cainam", "cainam-ventures"]
description = "Core functionality for the Cainam project"

[[bin]]
name = "cainam-core"
path = "src/main.rs"

[[bin]]
name = "agent_trader"
path = "agents/trader/src/main.rs"

[[bin]]
name = "setup_mongodb"
path = "scripts/setup_mongodb.rs"

[[bin]]
name = "init_vector_store"
path = "scripts/init_vector_store.rs"

[[bin]]
name = "run_agent"
path = "scripts/run_agent.rs"

[[bin]]
name = "capture_market_data"
path = "scripts/capture_market_data.rs"

[workspace]
resolver = "2"
members = []
exclude = [
    "examples",
    "memory-bank",
    "phases_output",
]

[workspace.package]
version = "0.1.0"
edition = "2021"

[profile.dev]
opt-level = "z"

[profile.release]
codegen-units = 1
lto = "thin"
opt-level = "z"
strip = true

[dependencies]
anyhow = "1.0"
async-trait = "0.1"
bigdecimal = { version = "0.2", features = ["serde"] }
bson = "2.0"
chrono = "0.4"
futures = "0.3"
mockall = "0.11.0"
mongodb = "3.2.1"
reqwest = { version = "0.11", features = ["json"] }
rig-core = "0.8.0"
solagent-core = "0.1.5"
serde = { version = "1.0.217", features = ["derive"] }
serde_derive = "1.0.217"
thiserror = "2.0.11"
time = "0.3"
tokio = { version = "1", features = ["full", "macros"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["std", "env-filter"] }

# Blockchain dependencies
solana-account-decoder = "2.2.0"
solana-client = "2.2.0"
solana-sdk = "2.2.1"
solana-program = "2.2.1"
spl-associated-token-account = "6.0.0"
spl-token = "7.0"

# Additional utilities
dotenvy = "0.15.7"
serde_json = "1.0"
uuid = { version = "1.6", features = ["v4", "serde"] }
</file>

<file path="CONTRIBUTING.md">
# Contributing to Cainam Core

Thank you for considering contributing to Cainam Core! Here are some guidelines to help you get started.

## Issues

Before reporting an issue, please check existing or similar issues that are currently tracked.

## Pull Requests

Contributions are always encouraged and welcome. Before creating a pull request, create a new issue that tracks that pull request describing the problem in more detail. Pull request descriptions should include information about it's implementation, especially if it makes changes to existing abstractions.

PRs should be small and focused and should avoid interacting with multiple facets of the library. This may result in a larger PR being split into two or more smaller PRs. Commit messages should follow the [Conventional Commit](conventionalcommits.org/en/v1.0.0) format (prefixing with `feat`, `fix`, etc.) as this integrates into our auto-releases via a [release-plz](https://github.com/MarcoIeni/release-plz) Github action.

**Working on your first Pull Request?** You can learn how from this *free* series [How to Contribute to an Open Source Project on GitHub](https://kcd.im/pull-request)

## Project Structure

TBD

## Developing

### Setup

```bash
git clone https://github.com/cainamventures/cainam-core
cd cainam-core
cargo test
```

### Clippy and Fmt

We enforce both `clippy` and `fmt` for all pull requests.

```bash
cargo clippy -- -D warnings
```

```bash
cargo fmt
```

### Tests

Make sure to test against the test suite before making a pull request.

```bash
cargo test
```
</file>

<file path="playground-1.mongodb.js">
/* global use, db */
// MongoDB Playground
// To disable this template go to Settings | MongoDB | Use Default Template For Playground.
// Make sure you are connected to enable completions and to be able to run a playground.
// Use Ctrl+Space inside a snippet or a string literal to trigger completions.
// The result of the last command run in a playground is shown on the results panel.
// By default the first 20 documents will be returned with a cursor.
// Use 'console.log()' to print to the debug output.
// For more documentation on playgrounds please refer to
// https://www.mongodb.com/docs/mongodb-vscode/playgrounds/
// Select the database to use.
use("mongodbVSCodePlaygroundDB")
// Insert a few documents into the sales collection.
db.getCollection("sales").insertMany([
  {
    item: "abc",
    price: 10,
    quantity: 2,
    date: new Date("2014-03-01T08:00:00Z"),
  },
  {
    item: "jkl",
    price: 20,
    quantity: 1,
    date: new Date("2014-03-01T09:00:00Z"),
  },
  {
    item: "xyz",
    price: 5,
    quantity: 10,
    date: new Date("2014-03-15T09:00:00Z"),
  },
  {
    item: "xyz",
    price: 5,
    quantity: 20,
    date: new Date("2014-04-04T11:21:39.736Z"),
  },
  {
    item: "abc",
    price: 10,
    quantity: 10,
    date: new Date("2014-04-04T21:23:13.331Z"),
  },
  {
    item: "def",
    price: 7.5,
    quantity: 5,
    date: new Date("2015-06-04T05:08:13Z"),
  },
  {
    item: "def",
    price: 7.5,
    quantity: 10,
    date: new Date("2015-09-10T08:43:00Z"),
  },
  {
    item: "abc",
    price: 10,
    quantity: 5,
    date: new Date("2016-02-06T20:20:13Z"),
  },
])
// Run a find command to view items sold on April 4th, 2014.
const salesOnApril4th = db
  .getCollection("sales")
  .find({
    date: { $gte: new Date("2014-04-04"), $lt: new Date("2014-04-05") },
  })
  .count()
// Print a message to the output window.
console.log(`${salesOnApril4th} sales occurred in 2014.`)
// Here we run an aggregation and open a cursor to the results.
// Use '.toArray()' to exhaust the cursor to return the whole result set.
// You can use '.hasNext()/.next()' to iterate through the cursor page by page.
db.getCollection("sales").aggregate([
  // Find all of the sales that occurred in 2014.
  {
    $match: {
      date: { $gte: new Date("2014-01-01"), $lt: new Date("2015-01-01") },
    },
  },
  // Group the total sales for each product.
  {
    $group: {
      _id: "$item",
      totalSaleAmount: { $sum: { $multiply: ["$price", "$quantity"] } },
    },
  },
])
// Replace with your actual database and collection names
use cainam;
db.token_analytics.aggregate([
  {
    $searchIndex: {
      name: "vector_index", // The name of your index
      definition: {
        mappings: {
          dynamic: false, // Good practice for vector search
          fields: {
            embedding: {
              type: "vector",
              dimensions: 1536,
              similarity: "cosine",
            },
          },
        },
      },
    },
  },
  {
    $limit: 1, // Add a limit stage to avoid processing all documents
  },
]);
// To actually CREATE the index, you need to run this command:
db.runCommand({
  createSearchIndexes: "token_analytics",
  indexes: [
    {
      name: "vector_index",
      definition: {
        mappings: {
          dynamic: false,
          fields: {
            embedding: {
              type: "vector",
              dimensions: 1536,
              similarity: "cosine",
            },
          },
        },
      },
    },
  ],
});
</file>

<file path="README.md">
# Cainam Core

Core functionality for the Cainam project - A decentralized network of autonomous AI trading agents for the $CAINAM token platform on Solana.

## Overview

Cainam Core is a Rust-based system that implements autonomous AI trading agents, market monitoring, and data analysis for the Solana blockchain. The system features real-time market data processing, automated trading execution, and advanced risk management capabilities.

### Key Features

- Real-time market monitoring via Birdeye API
- Blockchain transaction monitoring using Helius webhooks
- Autonomous trading agents with AI-driven decision making
- Advanced risk management and position sizing
- Time-series data storage with TimescaleDB
- Vector similarity search using Qdrant
- Discord and Twitter integration

## Prerequisites

- Rust 1.75+ (2021 edition)
- PostgreSQL 15+ with TimescaleDB extension
- Solana CLI tools
- Node.js and npm (for development tools)

## Installation

1. Clone the repository:

```bash
git clone https://github.com/cainamventures/cainam-core
cd cainam-core
```

2. Copy the environment template and configure your variables:

```bash
cp .env.example .env
# Edit .env with your configuration
```

3. Install development dependencies:

```bash
# Install pre-commit hooks
pre-commit install

# Install required database extensions
psql -c 'CREATE EXTENSION IF NOT EXISTS timescaledb;'
```

4. Build the project:

```bash
cargo build
```

## Configuration

The following environment variables are required:

```env
# Database
DATABASE_URL=postgresql://user:password@localhost/dbname

# Solana
SOLANA_RPC_URL=your_rpc_url
HELIUS_API_KEY=your_helius_key

# APIs
BIRDEYE_API_KEY=your_birdeye_key

# Optional integrations
DISCORD_TOKEN=your_discord_token
TWITTER_API_KEY=your_twitter_key
```

## Project Structure

```
src/
├── actions/      # External API interactions
├── agent/        # Agent implementations
├── trading/      # Trading logic
├── models/       # Data models
└── services/     # Business logic
```

## Development

### Running Tests

```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --package cainam-core
```

### Database Migrations

```bash
# Apply migrations
sqlx migrate run

# Create new migration
sqlx migrate add <name>
```

### Code Style

The project uses rustfmt and clippy for code formatting and linting:

```bash
# Format code
cargo fmt

# Run clippy
cargo clippy
```

## Performance Requirements

- Trade execution: < 500ms end-to-end
- Market data updates: < 1s refresh rate
- Signal processing: < 200ms
- Database queries: < 100ms response time

## Dependencies

Core dependencies include:

- tokio (async runtime)
- solana-client & solana-sdk (blockchain interaction)
- serde (serialization)
- tokio-postgres (database)
- qdrant-client (vector store)
- rig-core (framework)

## Contributing

Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines on contributing to the project.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Contact

- Author: Matt Gunnin
- Email: <matt@cainamventures.com>
- Repository: <https://github.com/cainamventures/cainam-core>
</file>

</files>
